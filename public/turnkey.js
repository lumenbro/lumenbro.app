var Turnkey = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from5, except, desc) => {
    if (from5 && typeof from5 === "object" || typeof from5 === "function") {
      for (let key of __getOwnPropNames(from5))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // node_modules/@turnkey/encoding/dist/index.mjs
  function pointEncode(raw) {
    if (raw.length !== 65 || raw[0] !== 4) {
      throw new Error("Invalid uncompressed P-256 key");
    }
    const x = raw.slice(1, 33);
    const y = raw.slice(33, 65);
    if (x.length !== 32 || y.length !== 32) {
      throw new Error("Invalid x or y length");
    }
    const prefix = (y[31] & 1) === 0 ? 2 : 3;
    const compressed = new Uint8Array(33);
    compressed[0] = prefix;
    compressed.set(x, 1);
    return compressed;
  }
  function stringToBase64urlString(input) {
    const base64String = btoa2(input);
    return base64StringToBase64UrlEncodedString(base64String);
  }
  function hexStringToBase64url(input, length) {
    const hexString = input.padStart(Math.ceil(input.length / 2) * 2, "0");
    const buffer2 = uint8ArrayFromHexString(hexString, length);
    return stringToBase64urlString(buffer2.reduce((result, x) => result + String.fromCharCode(x), ""));
  }
  function base64StringToBase64UrlEncodedString(input) {
    return input.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function uint8ArrayToHexString(input) {
    return input.reduce((result, x) => result + x.toString(16).padStart(2, "0"), "");
  }
  function hexToAscii(hexString) {
    let asciiStr = "";
    for (let i = 0; i < hexString.length; i += 2) {
      asciiStr += String.fromCharCode(parseInt(hexString.substr(i, 2), 16));
    }
    return asciiStr;
  }
  function btoa2(s) {
    if (arguments.length === 0) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    let i;
    s = `${s}`;
    for (i = 0; i < s.length; i++) {
      if (s.charCodeAt(i) > 255) {
        throw new Error(`InvalidCharacterError: found code point greater than 255:${s.charCodeAt(i)} at position ${i}`);
      }
    }
    let out = "";
    for (i = 0; i < s.length; i += 3) {
      const groupsOfSix = [
        void 0,
        void 0,
        void 0,
        void 0
      ];
      groupsOfSix[0] = s.charCodeAt(i) >> 2;
      groupsOfSix[1] = (s.charCodeAt(i) & 3) << 4;
      if (s.length > i + 1) {
        groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;
        groupsOfSix[2] = (s.charCodeAt(i + 1) & 15) << 2;
      }
      if (s.length > i + 2) {
        groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;
        groupsOfSix[3] = s.charCodeAt(i + 2) & 63;
      }
      for (let j = 0; j < groupsOfSix.length; j++) {
        if (typeof groupsOfSix[j] === "undefined") {
          out += "=";
        } else {
          out += btoaLookup(groupsOfSix[j]);
        }
      }
    }
    return out;
  }
  function btoaLookup(index2) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    if (index2 >= 0 && index2 < 64) {
      return keystr[index2];
    }
    return void 0;
  }
  var DEFAULT_JWK_MEMBER_BYTE_LENGTH, uint8ArrayFromHexString, normalizePadding;
  var init_dist = __esm({
    "node_modules/@turnkey/encoding/dist/index.mjs"() {
      DEFAULT_JWK_MEMBER_BYTE_LENGTH = 32;
      uint8ArrayFromHexString = (hexString, length) => {
        const hexRegex = /^[0-9A-Fa-f]+$/;
        if (!hexString || hexString.length % 2 != 0 || !hexRegex.test(hexString)) {
          throw new Error(`cannot create uint8array from invalid hex string: "${hexString}"`);
        }
        const buffer2 = new Uint8Array(hexString.match(/../g).map((h) => parseInt(h, 16)));
        if (!length) {
          return buffer2;
        }
        if (hexString.length / 2 > length) {
          throw new Error("hex value cannot fit in a buffer of " + length + " byte(s)");
        }
        let paddedBuffer = new Uint8Array(length);
        paddedBuffer.set(buffer2, length - buffer2.length);
        return paddedBuffer;
      };
      normalizePadding = (byteArray, targetLength) => {
        const paddingLength = targetLength - byteArray.length;
        if (paddingLength > 0) {
          const padding = new Uint8Array(paddingLength).fill(0);
          return new Uint8Array([...padding, ...byteArray]);
        }
        if (paddingLength < 0) {
          const expectedZeroCount = paddingLength * -1;
          let zeroCount = 0;
          for (let i = 0; i < expectedZeroCount && i < byteArray.length; i++) {
            if (byteArray[i] === 0) {
              zeroCount++;
            }
          }
          if (zeroCount !== expectedZeroCount) {
            throw new Error(`invalid number of starting zeroes. Expected number of zeroes: ${expectedZeroCount}. Found: ${zeroCount}.`);
          }
          return byteArray.slice(expectedZeroCount, expectedZeroCount + targetLength);
        }
        return byteArray;
      };
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs
  function fromHex(hex) {
    if (hex.length % 2 != 0) {
      throw new Error("Hex string length must be multiple of 2");
    }
    const arr = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);
    }
    return arr;
  }
  function toHex(bytes) {
    let result = "";
    for (let i = 0; i < bytes.length; i++) {
      const hexByte = bytes[i].toString(16);
      result += hexByte.length > 1 ? hexByte : "0" + hexByte;
    }
    return result;
  }
  function toBase64(bytes, opt_webSafe) {
    const encoded = btoa(
      /* padding */
      toByteString(bytes)
    ).replace(/=/g, "");
    {
      return encoded.replace(/\+/g, "-").replace(/\//g, "_");
    }
  }
  function toByteString(bytes) {
    let str = "";
    for (let i = 0; i < bytes.length; i += 1) {
      str += String.fromCharCode(bytes[i]);
    }
    return str;
  }
  var init_bytes = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs"() {
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs
  function getModulus() {
    return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951");
  }
  function getB() {
    return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
  }
  function byteArrayToInteger(bytes) {
    return BigInt("0x" + toHex(bytes));
  }
  function integerToByteArray(i, length) {
    const input = i.toString(16);
    const numHexChars = length * 2;
    let padding = "";
    if (numHexChars < input.length) {
      throw new Error(`cannot pack integer with ${input.length} hex chars into ${length} bytes`);
    } else {
      padding = "0".repeat(numHexChars - input.length);
    }
    return fromHex(padding + input);
  }
  function testBit(n, i) {
    const m = BigInt(1) << BigInt(i);
    return (n & m) !== BigInt(0);
  }
  function modPow(b, exp, p) {
    if (exp === BigInt(0)) {
      return BigInt(1);
    }
    let result = b;
    const exponentBitString = exp.toString(2);
    for (let i = 1; i < exponentBitString.length; ++i) {
      result = result * result % p;
      if (exponentBitString[i] === "1") {
        result = result * b % p;
      }
    }
    return result;
  }
  function modSqrt(x, p) {
    if (p <= BigInt(0)) {
      throw new Error("p must be positive");
    }
    const base2 = x % p;
    if (testBit(p, 0) && /* istanbul ignore next */
    testBit(p, 1)) {
      const q = p + BigInt(1) >> BigInt(2);
      const squareRoot = modPow(base2, q, p);
      if (squareRoot * squareRoot % p !== base2) {
        throw new Error("could not find a modular square root");
      }
      return squareRoot;
    }
    throw new Error("unsupported modulus value");
  }
  function getY(x, lsb) {
    const p = getModulus();
    const a = p - BigInt(3);
    const b = getB();
    const rhs = ((x * x + a) * x + b) % p;
    let y = modSqrt(rhs, p);
    if (lsb !== testBit(y, 0)) {
      y = (p - y) % p;
    }
    return y;
  }
  function isP256CurvePoint(x, y) {
    const p = getModulus();
    const a = p - BigInt(3);
    const b = getB();
    const rhs = ((x * x + a) * x + b) % p;
    const lhs = y ** BigInt(2) % p;
    return lhs === rhs;
  }
  function pointDecode(point) {
    const fieldSize = fieldSizeInBytes();
    const compressedLength = fieldSize + 1;
    const uncompressedLength = 2 * fieldSize + 1;
    if (point.length !== compressedLength && point.length !== uncompressedLength) {
      throw new Error("Invalid length: point is not in compressed or uncompressed format");
    }
    if ((point[0] === 2 || point[0] === 3) && point.length == compressedLength) {
      const lsb = point[0] === 3;
      const x = byteArrayToInteger(point.subarray(1, point.length));
      const p = getModulus();
      if (x < BigInt(0) || x >= p) {
        throw new Error("x is out of range");
      }
      const y = getY(x, lsb);
      const result = {
        kty: "EC",
        crv: "P-256",
        x: toBase64(integerToByteArray(x, 32)),
        y: toBase64(integerToByteArray(y, 32)),
        ext: true
      };
      return result;
    } else if (point[0] === 4 && point.length == uncompressedLength) {
      const x = byteArrayToInteger(point.subarray(1, fieldSize + 1));
      const y = byteArrayToInteger(point.subarray(fieldSize + 1, 2 * fieldSize + 1));
      const p = getModulus();
      if (x < BigInt(0) || x >= p || y < BigInt(0) || y >= p || !isP256CurvePoint(x, y)) {
        throw new Error("invalid uncompressed x and y coordinates");
      }
      const result = {
        kty: "EC",
        crv: "P-256",
        x: toBase64(integerToByteArray(x, 32)),
        y: toBase64(integerToByteArray(y, 32)),
        ext: true
      };
      return result;
    }
    throw new Error("invalid format");
  }
  function fieldSizeInBytes() {
    return 32;
  }
  var init_elliptic_curves = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs"() {
      init_bytes();
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/utils.mjs
  function convertTurnkeyApiKeyToJwk(input) {
    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;
    let jwk;
    try {
      jwk = pointDecode(uint8ArrayFromHexString(compressedPublicKeyHex));
    } catch (e) {
      throw new Error(`unable to load API key: invalid public key. Did you switch your public and private key by accident? Is your public key a valid, compressed P-256 public key?`);
    }
    jwk.d = hexStringToBase64url(uncompressedPrivateKeyHex, DEFAULT_JWK_MEMBER_BYTE_LENGTH);
    return jwk;
  }
  var init_utils = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/utils.mjs"() {
      init_elliptic_curves();
      init_dist();
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs
  var webcrypto_exports = {};
  __export(webcrypto_exports, {
    signWithApiKey: () => signWithApiKey
  });
  async function importTurnkeyApiKey(input) {
    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;
    const jwk = convertTurnkeyApiKeyToJwk({
      uncompressedPrivateKeyHex,
      compressedPublicKeyHex
    });
    return await crypto.subtle.importKey(
      "jwk",
      jwk,
      {
        name: "ECDSA",
        namedCurve: "P-256"
      },
      false,
      // not extractable
      ["sign"]
    );
  }
  async function signMessage(input) {
    const { key, content } = input;
    const signatureIeee1363 = await crypto.subtle.sign({
      name: "ECDSA",
      hash: "SHA-256"
    }, key, new TextEncoder().encode(content));
    const signatureDer = convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));
    return uint8ArrayToHexString(signatureDer);
  }
  function convertEcdsaIeee1363ToDer(ieee) {
    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
      throw new Error("Invalid IEEE P1363 signature encoding. Length: " + ieee.length);
    }
    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));
    let offset = 0;
    const length = 1 + 1 + r.length + 1 + 1 + s.length;
    let der;
    if (length >= 128) {
      der = new Uint8Array(length + 3);
      der[offset++] = 48;
      der[offset++] = 128 + 1;
      der[offset++] = length;
    } else {
      der = new Uint8Array(length + 2);
      der[offset++] = 48;
      der[offset++] = length;
    }
    der[offset++] = 2;
    der[offset++] = r.length;
    der.set(r, offset);
    offset += r.length;
    der[offset++] = 2;
    der[offset++] = s.length;
    der.set(s, offset);
    return der;
  }
  function toUnsignedBigNum(bytes) {
    let start = 0;
    while (start < bytes.length && bytes[start] == 0) {
      start++;
    }
    if (start == bytes.length) {
      start = bytes.length - 1;
    }
    let extraZero = 0;
    if ((bytes[start] & 128) == 128) {
      extraZero = 1;
    }
    const res = new Uint8Array(bytes.length - start + extraZero);
    res.set(bytes.subarray(start), extraZero);
    return res;
  }
  var signWithApiKey;
  var init_webcrypto = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs"() {
      init_utils();
      init_dist();
      signWithApiKey = async (input) => {
        const { content, publicKey, privateKey } = input;
        const key = await importTurnkeyApiKey({
          uncompressedPrivateKeyHex: privateKey,
          compressedPublicKeyHex: publicKey
        });
        return await signMessage({ key, content });
      };
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs
  var nodecrypto_exports = {};
  __export(nodecrypto_exports, {
    signWithApiKey: () => signWithApiKey2
  });
  var crypto2, signWithApiKey2;
  var init_nodecrypto = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs"() {
      crypto2 = __toESM(require_crypto(), 1);
      init_utils();
      signWithApiKey2 = async (input) => {
        const { content, publicKey, privateKey } = input;
        const privateKeyObject = (void 0)({
          // @ts-expect-error -- the key can be a JWK object since Node v15.12.0
          // https://nodejs.org/api/crypto.html#cryptocreateprivatekeykey
          key: convertTurnkeyApiKeyToJwk({
            uncompressedPrivateKeyHex: privateKey,
            compressedPublicKeyHex: publicKey
          }),
          format: "jwk"
        });
        const sign = (void 0)("SHA256");
        sign.write(Buffer.from(content));
        sign.end();
        return sign.sign(privateKeyObject, "hex");
      };
    }
  });

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto3;
  var init_crypto = __esm({
    "node_modules/@noble/hashes/esm/crypto.js"() {
      crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
    return arr;
  }
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  function asciiToBase16(ch2) {
    if (ch2 >= asciis._0 && ch2 <= asciis._9)
      return ch2 - asciis._0;
    if (ch2 >= asciis.A && ch2 <= asciis.F)
      return ch2 - (asciis.A - 10);
    if (ch2 >= asciis.a && ch2 <= asciis.f)
      return ch2 - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad4 = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad4);
      pad4 += a.length;
    }
    return res;
  }
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto3 && typeof crypto3.getRandomValues === "function") {
      return crypto3.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto3 && typeof crypto3.randomBytes === "function") {
      return Uint8Array.from(crypto3.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var isLE, swap32IfBE, hasHexBuiltin, hexes, asciis, Hash;
  var init_utils2 = __esm({
    "node_modules/@noble/hashes/esm/utils.js"() {
      init_crypto();
      isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      swap32IfBE = isLE ? (u) => u : byteSwap32;
      hasHexBuiltin = /* @__PURE__ */ (() => (
        // @ts-ignore
        typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
      ))();
      hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      Hash = class {
      };
    }
  });

  // node_modules/@noble/curves/esm/abstract/utils.js
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes2(item) {
    if (!isBytes2(item))
      throw new Error("Uint8Array expected");
  }
  function abool(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded(num2) {
    const hex = num2.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  function bytesToHex2(bytes) {
    abytes2(bytes);
    if (hasHexBuiltin2)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes2[bytes[i]];
    }
    return hex;
  }
  function asciiToBase162(ch2) {
    if (ch2 >= asciis2._0 && ch2 <= asciis2._9)
      return ch2 - asciis2._0;
    if (ch2 >= asciis2.A && ch2 <= asciis2.F)
      return ch2 - (asciis2.A - 10);
    if (ch2 >= asciis2.a && ch2 <= asciis2.f)
      return ch2 - (asciis2.a - 10);
    return;
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin2)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase162(hex.charCodeAt(hi));
      const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex2(bytes));
  }
  function bytesToNumberLE(bytes) {
    abytes2(bytes);
    return hexToNumber(bytesToHex2(Uint8Array.from(bytes).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes2(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes2(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad4 = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad4);
      pad4 += a.length;
    }
    return res;
  }
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset2 = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset2();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset2();
      return res;
    };
    return genUntil;
  }
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error("invalid validator function");
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
  var _0n, _1n, hasHexBuiltin2, hexes2, asciis2, isPosBig, bitMask, u8n, u8fr, validatorFns;
  var init_utils3 = __esm({
    "node_modules/@noble/curves/esm/abstract/utils.js"() {
      _0n = /* @__PURE__ */ BigInt(0);
      _1n = /* @__PURE__ */ BigInt(1);
      hasHexBuiltin2 = // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function";
      hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      isPosBig = (n) => typeof n === "bigint" && _0n <= n;
      bitMask = (n) => (_1n << BigInt(n)) - _1n;
      u8n = (len) => new Uint8Array(len);
      u8fr = (arr) => Uint8Array.from(arr);
      validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
    }
  });

  // node_modules/@noble/curves/esm/abstract/modular.js
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (Z < P && FpIsSquare(_Fp, Z)) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1) {
      const p1div4 = (P + _1n2) / _4n;
      return function tonelliFast(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp2, n) {
      if (!FpIsSquare(Fp2, n))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n, Q1div2);
      let b = Fp2.pow(n, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b); m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      return function sqrt3mod42(Fp2, n) {
        const p1div4 = (P + _1n2) / _4n;
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      return function sqrt5mod82(Fp2, n) {
        const n2 = Fp2.mul(n, _2n);
        const c1 = (P - _5n) / _8n;
        const v = Fp2.pow(n2, c1);
        const nv = Fp2.mul(n, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(Fp2, num2, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp2.ONE;
    if (power === _1n2)
      return num2;
    let p = Fp2.ONE;
    let d = num2;
    while (power > _0n2) {
      if (power & _1n2)
        p = Fp2.mul(p, d);
      d = Fp2.sqr(d);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num2);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num2);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp2, n) {
    const legc = (Fp2.ORDER - _1n2) / _2n;
    const powered = Fp2.pow(n, legc);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero && !no)
      throw new Error("Cannot find square root: probably non-prime P");
    return yes ? 1 : zero ? 0 : -1;
  }
  function FpIsSquare(Fp2, n) {
    const l = FpLegendre(Fp2, n);
    return l === 0 || l === 1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen3, isLE3 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE3,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num2) => mod(num2, ORDER),
      isValid: (num2) => {
        if (typeof num2 !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num2);
        return _0n2 <= num2 && num2 < ORDER;
      },
      is0: (num2) => num2 === _0n2,
      isOdd: (num2) => (num2 & _1n2) === _1n2,
      neg: (num2) => mod(-num2, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num2) => mod(num2 * num2, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num2, power) => FpPow(f, num2, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num2) => num2 * num2,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num2) => invert(num2, ORDER),
      sqrt: redef.sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num2) => isLE3 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
      fromBytes: (bytes) => {
        if (bytes.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
        return isLE3 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE3 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
    return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }
  var _0n2, _1n2, _2n, _3n, _4n, _5n, _8n, _9n, _16n, isNegativeLE, FIELD_FIELDS;
  var init_modular = __esm({
    "node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_utils2();
      init_utils3();
      _0n2 = BigInt(0);
      _1n2 = BigInt(1);
      _2n = /* @__PURE__ */ BigInt(2);
      _3n = /* @__PURE__ */ BigInt(3);
      _4n = /* @__PURE__ */ BigInt(4);
      _5n = /* @__PURE__ */ BigInt(5);
      _8n = /* @__PURE__ */ BigInt(8);
      _9n = /* @__PURE__ */ BigInt(9);
      _16n = /* @__PURE__ */ BigInt(16);
      isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n2) === _1n2;
      FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD, SHA256_IV, SHA384_IV, SHA512_IV;
  var init_md = __esm({
    "node_modules/@noble/hashes/esm/_md.js"() {
      init_utils2();
      HashMD = class extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE3) {
          super();
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE3;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
        }
        update(data) {
          aexists(this);
          data = toBytes(data);
          abytes(data);
          const { view, buffer: buffer2, blockLen } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = createView(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          aexists(this);
          aoutput(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          clean(this.buffer.subarray(pos));
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer2[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE3);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.destroyed = destroyed;
          to.finished = finished;
          to.length = length;
          to.pos = pos;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
      };
      SHA256_IV = /* @__PURE__ */ Uint32Array.from([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      SHA384_IV = /* @__PURE__ */ Uint32Array.from([
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ]);
      SHA512_IV = /* @__PURE__ */ Uint32Array.from([
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ]);
    }
  });

  // node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var U32_MASK64, _32n, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H;
  var init_u64 = __esm({
    "node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      _32n = /* @__PURE__ */ BigInt(32);
      shrSH = (h, _l, s) => h >>> s;
      shrSL = (h, l, s) => h << 32 - s | l >>> s;
      rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    }
  });

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K, SHA256_W, SHA256, K512, SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, SHA384, sha256, sha512, sha384;
  var init_sha2 = __esm({
    "node_modules/@noble/hashes/esm/sha2.js"() {
      init_md();
      init_u64();
      init_utils2();
      SHA256_K = /* @__PURE__ */ Uint32Array.from([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      SHA256 = class extends HashMD {
        constructor(outputLen = 32) {
          super(64, outputLen, 8, false);
          this.A = SHA256_IV[0] | 0;
          this.B = SHA256_IV[1] | 0;
          this.C = SHA256_IV[2] | 0;
          this.D = SHA256_IV[3] | 0;
          this.E = SHA256_IV[4] | 0;
          this.F = SHA256_IV[5] | 0;
          this.G = SHA256_IV[6] | 0;
          this.H = SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma12 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = H + sigma12 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma02 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = sigma02 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          clean(SHA256_W);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          clean(this.buffer);
        }
      };
      K512 = /* @__PURE__ */ (() => split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
      SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
      SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      SHA512 = class extends HashMD {
        constructor(outputLen = 64) {
          super(128, outputLen, 16, false);
          this.Ah = SHA512_IV[0] | 0;
          this.Al = SHA512_IV[1] | 0;
          this.Bh = SHA512_IV[2] | 0;
          this.Bl = SHA512_IV[3] | 0;
          this.Ch = SHA512_IV[4] | 0;
          this.Cl = SHA512_IV[5] | 0;
          this.Dh = SHA512_IV[6] | 0;
          this.Dl = SHA512_IV[7] | 0;
          this.Eh = SHA512_IV[8] | 0;
          this.El = SHA512_IV[9] | 0;
          this.Fh = SHA512_IV[10] | 0;
          this.Fl = SHA512_IV[11] | 0;
          this.Gh = SHA512_IV[12] | 0;
          this.Gl = SHA512_IV[13] | 0;
          this.Hh = SHA512_IV[14] | 0;
          this.Hl = SHA512_IV[15] | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
            const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
            const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
            const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
            const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
            const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = add3L(T1l, sigma0l, MAJl);
            Ah = add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          clean(SHA512_W_H, SHA512_W_L);
        }
        destroy() {
          clean(this.buffer);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      SHA384 = class extends SHA512 {
        constructor() {
          super(48);
          this.Ah = SHA384_IV[0] | 0;
          this.Al = SHA384_IV[1] | 0;
          this.Bh = SHA384_IV[2] | 0;
          this.Bl = SHA384_IV[3] | 0;
          this.Ch = SHA384_IV[4] | 0;
          this.Cl = SHA384_IV[5] | 0;
          this.Dh = SHA384_IV[6] | 0;
          this.Dl = SHA384_IV[7] | 0;
          this.Eh = SHA384_IV[8] | 0;
          this.El = SHA384_IV[9] | 0;
          this.Fh = SHA384_IV[10] | 0;
          this.Fl = SHA384_IV[11] | 0;
          this.Gh = SHA384_IV[12] | 0;
          this.Gl = SHA384_IV[13] | 0;
          this.Hh = SHA384_IV[14] | 0;
          this.Hl = SHA384_IV[15] | 0;
        }
      };
      sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
      sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
      sha384 = /* @__PURE__ */ createHasher(() => new SHA384());
    }
  });

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC, hmac;
  var init_hmac = __esm({
    "node_modules/@noble/hashes/esm/hmac.js"() {
      init_utils2();
      HMAC = class extends Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          ahash(hash2);
          const key = toBytes(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad4 = new Uint8Array(blockLen);
          pad4.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54;
          this.iHash.update(pad4);
          this.oHash = hash2.create();
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54 ^ 92;
          this.oHash.update(pad4);
          clean(pad4);
        }
        update(buf) {
          aexists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          aexists(this);
          abytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // node_modules/@noble/curves/esm/abstract/curve.js
  function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function validateW(W2, bits) {
    if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
  }
  function calcWOpts(W2, scalarBits) {
    validateW(W2, scalarBits);
    const windows = Math.ceil(scalarBits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    const maxNumber = 2 ** W2;
    const mask = bitMask(W2);
    const shiftBy = BigInt(W2);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function wNAF(c, bits) {
    return {
      constTimeNegate,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      // non-const time multiplication ladder
      unsafeLadder(elm, n, p = c.ZERO) {
        let d = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p = p.add(d);
          d = d.double();
          n >>= _1n3;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param elm Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W2) {
        const { windows, windowSize } = calcWOpts(W2, bits);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W2, precomputes, n) {
        let p = c.ZERO;
        let f = c.BASE;
        const wo = calcWOpts(W2, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(constTimeNegate(isNeg, precomputes[offset]));
          }
        }
        return { p, f };
      },
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W2, precomputes, n, acc = c.ZERO) {
        const wo = calcWOpts(W2, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n3)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        return acc;
      },
      getPrecomputes(W2, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W2);
          if (W2 !== 1)
            pointPrecomputes.set(P, transform(comp));
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W2 = getW(P);
        return this.wNAF(W2, this.getPrecomputes(W2, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W2 = getW(P);
        if (W2 === 1)
          return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W2, this.getPrecomputes(W2, P, transform), n, prev);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W2) {
        validateW(W2, bits);
        pointWindowSizes.set(P, W2);
        pointPrecomputes.delete(P);
      }
    };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    if (points.length !== scalars.length)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen(BigInt(points.length));
    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
    const MASK = bitMask(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < scalars.length; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  var _0n3, _1n3, pointPrecomputes, pointWindowSizes;
  var init_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_modular();
      init_utils3();
      _0n3 = BigInt(0);
      _1n3 = BigInt(1);
      pointPrecomputes = /* @__PURE__ */ new WeakMap();
      pointWindowSizes = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0)
      abool("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool("prehash", opts.prehash);
  }
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes3 = CURVE.fromBytes || ((bytes) => {
      const tail = bytes.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num2) {
      return inRange(num2, _1n4, CURVE.n);
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes2(key))
          key = bytesToHex2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("invalid private key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num2;
      try {
        num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
      }
      if (wrapPrivateKey)
        num2 = mod(num2, N);
      aInRange("private key", num2, _1n4, N);
      return num2;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { px: x, py: y, pz: z } = p;
      if (Fp2.eql(z, Fp2.ONE))
        return { x, y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class Point2 {
      constructor(px, py, pz) {
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py) || Fp2.is0(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
        this.px = px;
        this.py = py;
        this.pz = pz;
        Object.freeze(this);
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = FpInvertBatch(Fp2, points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes3(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point2, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point2.normalizeZ);
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo, n: N } = CURVE;
        aInRange("scalar", sc, _0n4, N);
        const I = Point2.ZERO;
        if (sc === _0n4)
          return I;
        if (this.is0() || sc === _1n4)
          return this;
        if (!endo || wnaf.hasPrecomputes(this))
          return wnaf.wNAFCachedUnsafe(this, sc, Point2.normalizeZ);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n4 || k2 > _0n4) {
          if (k1 & _1n4)
            k1p = k1p.add(d);
          if (k2 & _1n4)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n4;
          k2 >>= _1n4;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo, n: N } = CURVE;
        aInRange("scalar", scalar, _1n4, N);
        let point, fake;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(scalar);
          point = p;
          fake = f;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point2.BASE;
        const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul3(this, a).add(mul3(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n4)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n4)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        abool("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes4(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        abool("isCompressed", isCompressed);
        return bytesToHex2(this.toRawBytes(isCompressed));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function modN2(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes2;
        abool("isCompressed", isCompressed);
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes) {
        const len = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!inRange(x, _1n4, Fp2.ORDER))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp2.sqrt(y2);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y & _1n4) === _1n4;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          const cl = compressedLen;
          const ul = uncompressedLen;
          throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
        }
      }
    });
    const numToNByteHex = (num2) => bytesToHex2(numberToBytesBE(num2, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n4;
      return number > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
    }
    const slcNum = (b, from5, to) => bytesToNumberBE(b.slice(from5, to));
    class Signature {
      constructor(r, s, recovery) {
        aInRange("r", r, _1n4, CURVE_ORDER);
        aInRange("s", s, _1n4, CURVE_ORDER);
        this.r = r;
        this.s = s;
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature(r, s);
      }
      /**
       * @todo remove
       * @deprecated
       */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point2.fromHex(prefix + numToNByteHex(radj));
        const ir = invN(radj);
        const u1 = modN2(-h * ir);
        const u2 = modN2(s * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes2(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig(this);
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes2(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteHex(this.r) + numToNByteHex(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = isBytes2(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num2 = bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
      return modN2(bits2int(bytes));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num2) {
      aInRange("num < 2^" + CURVE.nBitLength, num2, _0n4, ORDER_MASK);
      return numberToBytesBE(num2, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes2(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = modN2(q.x);
        if (r === _0n4)
          return;
        const s = modN2(ik * modN2(m + r * d));
        if (s === _0n4)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      const { lowS, prehash, format } = opts;
      validateSigVerOpts(opts);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format !== void 0 && format !== "compact" && format !== "der")
        throw new Error("format must be compact or der");
      const isHex2 = typeof sg === "string" || isBytes2(sg);
      const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex2 && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = void 0;
      let P;
      try {
        if (isObj)
          _sig = new Signature(sg.r, sg.s);
        if (isHex2) {
          try {
            if (format !== "compact")
              _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
          }
          if (!_sig && format !== "der")
            _sig = Signature.fromCompact(sg);
        }
        P = Point2.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig)
        return false;
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN2(h * is);
      const u2 = modN2(r * is);
      const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN2(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point2,
      Signature,
      utils
    };
  }
  var DERErr, DER, _0n4, _1n4, _2n2, _3n2, _4n2;
  var init_weierstrass = __esm({
    "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_curve();
      init_modular();
      init_utils3();
      DERErr = class extends Error {
        constructor(m = "") {
          super(m);
        }
      };
      DER = {
        // asn.1 DER encoding utils
        Err: DERErr,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: (tag, data) => {
            const { Err: E } = DER;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length & 1)
              throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = numberToHexUnpadded(dataLen);
            if (len.length / 2 & 128)
              throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
            const t = numberToHexUnpadded(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
            const { Err: E } = DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag)
              throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128);
            let length = 0;
            if (!isLong)
              length = first;
            else {
              const lenLen = first & 127;
              if (!lenLen)
                throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4)
                throw new E("tlv.decode(long): byte length is too big");
              const lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen)
                throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0)
                throw new E("tlv.decode(long): zero leftmost byte");
              for (const b of lengthBytes)
                length = length << 8 | b;
              pos += lenLen;
              if (length < 128)
                throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
              throw new E("tlv.decode: wrong value length");
            return { v, l: data.subarray(pos + length) };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode(num2) {
            const { Err: E } = DER;
            if (num2 < _0n4)
              throw new E("integer: negative integers are not allowed");
            let hex = numberToHexUnpadded(num2);
            if (Number.parseInt(hex[0], 16) & 8)
              hex = "00" + hex;
            if (hex.length & 1)
              throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex;
          },
          decode(data) {
            const { Err: E } = DER;
            if (data[0] & 128)
              throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128))
              throw new E("invalid signature integer: unnecessary leading zero");
            return bytesToNumberBE(data);
          }
        },
        toSig(hex) {
          const { Err: E, _int: int, _tlv: tlv } = DER;
          const data = ensureBytes("signature", hex);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
          if (seqLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
          if (sLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
        },
        hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = DER;
          const rs = tlv.encode(2, int.encode(sig.r));
          const ss = tlv.encode(2, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };
      _0n4 = BigInt(0);
      _1n4 = BigInt(1);
      _2n2 = BigInt(2);
      _3n2 = BigInt(3);
      _4n2 = BigInt(4);
    }
  });

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create2 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
    return { ...create2(defHash), create: create2 };
  }
  var init_shortw_utils = __esm({
    "node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_hmac();
      init_utils2();
      init_weierstrass();
    }
  });

  // node_modules/@noble/curves/esm/nist.js
  var Fp256, p256_a, p256_b, p256, Fp384, p384_a, p384_b, p384, Fp521, p521_a, p521_b, p521;
  var init_nist = __esm({
    "node_modules/@noble/curves/esm/nist.js"() {
      init_sha2();
      init_shortw_utils();
      init_modular();
      Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
      p256_a = Fp256.create(BigInt("-3"));
      p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
      p256 = createCurve({
        a: p256_a,
        b: p256_b,
        Fp: Fp256,
        n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
        Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
        Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
        h: BigInt(1),
        lowS: false
      }, sha256);
      Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
      p384_a = Fp384.create(BigInt("-3"));
      p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
      p384 = createCurve({
        a: p384_a,
        b: p384_b,
        Fp: Fp384,
        n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
        Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
        Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
        h: BigInt(1),
        lowS: false
      }, sha384);
      Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
      p521_a = Fp521.create(BigInt("-3"));
      p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
      p521 = createCurve({
        a: p521_a,
        b: p521_b,
        Fp: Fp521,
        n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
        Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
        Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
        h: BigInt(1),
        lowS: false,
        allowedPrivateKeyLengths: [130, 131, 132]
        // P521 keys are variable-length. Normalize to 132b
      }, sha512);
    }
  });

  // node_modules/@noble/curves/esm/p256.js
  var p2562;
  var init_p256 = __esm({
    "node_modules/@noble/curves/esm/p256.js"() {
      init_nist();
      p2562 = p256;
    }
  });

  // node_modules/sha256-uint8array/dist/sha256-uint8array.mjs
  function createHash(algorithm) {
    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {
      throw new Error("Digest method not supported");
    }
    return new Hash2();
  }
  function isBE() {
    const buf = new Uint8Array(new Uint16Array([65279]).buffer);
    return buf[0] === 254;
  }
  var K, algorithms, Hash2, W, sharedBuffer, sharedOffset, hex32, swapLE, swapBE, swap32, ch, maj, sigma0, sigma1, gamma0, gamma1;
  var init_sha256_uint8array = __esm({
    "node_modules/sha256-uint8array/dist/sha256-uint8array.mjs"() {
      K = [
        1116352408 | 0,
        1899447441 | 0,
        3049323471 | 0,
        3921009573 | 0,
        961987163 | 0,
        1508970993 | 0,
        2453635748 | 0,
        2870763221 | 0,
        3624381080 | 0,
        310598401 | 0,
        607225278 | 0,
        1426881987 | 0,
        1925078388 | 0,
        2162078206 | 0,
        2614888103 | 0,
        3248222580 | 0,
        3835390401 | 0,
        4022224774 | 0,
        264347078 | 0,
        604807628 | 0,
        770255983 | 0,
        1249150122 | 0,
        1555081692 | 0,
        1996064986 | 0,
        2554220882 | 0,
        2821834349 | 0,
        2952996808 | 0,
        3210313671 | 0,
        3336571891 | 0,
        3584528711 | 0,
        113926993 | 0,
        338241895 | 0,
        666307205 | 0,
        773529912 | 0,
        1294757372 | 0,
        1396182291 | 0,
        1695183700 | 0,
        1986661051 | 0,
        2177026350 | 0,
        2456956037 | 0,
        2730485921 | 0,
        2820302411 | 0,
        3259730800 | 0,
        3345764771 | 0,
        3516065817 | 0,
        3600352804 | 0,
        4094571909 | 0,
        275423344 | 0,
        430227734 | 0,
        506948616 | 0,
        659060556 | 0,
        883997877 | 0,
        958139571 | 0,
        1322822218 | 0,
        1537002063 | 0,
        1747873779 | 0,
        1955562222 | 0,
        2024104815 | 0,
        2227730452 | 0,
        2361852424 | 0,
        2428436474 | 0,
        2756734187 | 0,
        3204031479 | 0,
        3329325298 | 0
      ];
      algorithms = {
        sha256: 1
      };
      Hash2 = class {
        constructor() {
          this.A = 1779033703 | 0;
          this.B = 3144134277 | 0;
          this.C = 1013904242 | 0;
          this.D = 2773480762 | 0;
          this.E = 1359893119 | 0;
          this.F = 2600822924 | 0;
          this.G = 528734635 | 0;
          this.H = 1541459225 | 0;
          this._size = 0;
          this._sp = 0;
          if (!sharedBuffer || sharedOffset >= 8e3) {
            sharedBuffer = new ArrayBuffer(
              8e3
              /* N.allocTotal */
            );
            sharedOffset = 0;
          }
          this._byte = new Uint8Array(
            sharedBuffer,
            sharedOffset,
            80
            /* N.allocBytes */
          );
          this._word = new Int32Array(
            sharedBuffer,
            sharedOffset,
            20
            /* N.allocWords */
          );
          sharedOffset += 80;
        }
        update(data) {
          if ("string" === typeof data) {
            return this._utf8(data);
          }
          if (data == null) {
            throw new TypeError("Invalid type: " + typeof data);
          }
          const byteOffset = data.byteOffset;
          const length = data.byteLength;
          let blocks = length / 64 | 0;
          let offset = 0;
          if (blocks && !(byteOffset & 3) && !(this._size % 64)) {
            const block = new Int32Array(
              data.buffer,
              byteOffset,
              blocks * 16
              /* N.inputWords */
            );
            while (blocks--) {
              this._int32(block, offset >> 2);
              offset += 64;
            }
            this._size += offset;
          }
          const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
          if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
            const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);
            return this._uint8(rest);
          }
          if (offset === length)
            return this;
          return this._uint8(data, offset);
        }
        _uint8(data, offset) {
          const { _byte, _word } = this;
          const length = data.length;
          offset = offset | 0;
          while (offset < length) {
            const start = this._size % 64;
            let index2 = start;
            while (offset < length && index2 < 64) {
              _byte[index2++] = data[offset++];
            }
            if (index2 >= 64) {
              this._int32(_word);
            }
            this._size += index2 - start;
          }
          return this;
        }
        _utf8(text) {
          const { _byte, _word } = this;
          const length = text.length;
          let surrogate = this._sp;
          for (let offset = 0; offset < length; ) {
            const start = this._size % 64;
            let index2 = start;
            while (offset < length && index2 < 64) {
              let code = text.charCodeAt(offset++) | 0;
              if (code < 128) {
                _byte[index2++] = code;
              } else if (code < 2048) {
                _byte[index2++] = 192 | code >>> 6;
                _byte[index2++] = 128 | code & 63;
              } else if (code < 55296 || code > 57343) {
                _byte[index2++] = 224 | code >>> 12;
                _byte[index2++] = 128 | code >>> 6 & 63;
                _byte[index2++] = 128 | code & 63;
              } else if (surrogate) {
                code = ((surrogate & 1023) << 10) + (code & 1023) + 65536;
                _byte[index2++] = 240 | code >>> 18;
                _byte[index2++] = 128 | code >>> 12 & 63;
                _byte[index2++] = 128 | code >>> 6 & 63;
                _byte[index2++] = 128 | code & 63;
                surrogate = 0;
              } else {
                surrogate = code;
              }
            }
            if (index2 >= 64) {
              this._int32(_word);
              _word[0] = _word[
                16
                /* N.inputWords */
              ];
            }
            this._size += index2 - start;
          }
          this._sp = surrogate;
          return this;
        }
        _int32(data, offset) {
          let { A, B, C, D, E, F, G, H } = this;
          let i = 0;
          offset = offset | 0;
          while (i < 16) {
            W[i++] = swap32(data[offset++]);
          }
          for (i = 16; i < 64; i++) {
            W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
          }
          for (i = 0; i < 64; i++) {
            const T1 = H + sigma1(E) + ch(E, F, G) + K[i] + W[i] | 0;
            const T2 = sigma0(A) + maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          this.A = A + this.A | 0;
          this.B = B + this.B | 0;
          this.C = C + this.C | 0;
          this.D = D + this.D | 0;
          this.E = E + this.E | 0;
          this.F = F + this.F | 0;
          this.G = G + this.G | 0;
          this.H = H + this.H | 0;
        }
        digest(encoding) {
          const { _byte, _word } = this;
          let i = this._size % 64 | 0;
          _byte[i++] = 128;
          while (i & 3) {
            _byte[i++] = 0;
          }
          i >>= 2;
          if (i > 14) {
            while (i < 16) {
              _word[i++] = 0;
            }
            i = 0;
            this._int32(_word);
          }
          while (i < 16) {
            _word[i++] = 0;
          }
          const bits64 = this._size * 8;
          const low32 = (bits64 & 4294967295) >>> 0;
          const high32 = (bits64 - low32) / 4294967296;
          if (high32)
            _word[
              14
              /* N.highIndex */
            ] = swap32(high32);
          if (low32)
            _word[
              15
              /* N.lowIndex */
            ] = swap32(low32);
          this._int32(_word);
          return encoding === "hex" ? this._hex() : this._bin();
        }
        _hex() {
          const { A, B, C, D, E, F, G, H } = this;
          return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);
        }
        _bin() {
          const { A, B, C, D, E, F, G, H, _byte, _word } = this;
          _word[0] = swap32(A);
          _word[1] = swap32(B);
          _word[2] = swap32(C);
          _word[3] = swap32(D);
          _word[4] = swap32(E);
          _word[5] = swap32(F);
          _word[6] = swap32(G);
          _word[7] = swap32(H);
          return _byte.slice(0, 32);
        }
      };
      W = new Int32Array(
        64
        /* N.workWords */
      );
      sharedOffset = 0;
      hex32 = (num2) => (num2 + 4294967296).toString(16).substr(-8);
      swapLE = (c) => c << 24 & 4278190080 | c << 8 & 16711680 | c >> 8 & 65280 | c >> 24 & 255;
      swapBE = (c) => c;
      swap32 = isBE() ? swapBE : swapLE;
      ch = (x, y, z) => z ^ x & (y ^ z);
      maj = (x, y, z) => x & y | z & (x | y);
      sigma0 = (x) => (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      sigma1 = (x) => (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      gamma0 = (x) => (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      gamma1 = (x) => (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/purejs.mjs
  var purejs_exports = {};
  __export(purejs_exports, {
    signWithApiKey: () => signWithApiKey3
  });
  var signWithApiKey3;
  var init_purejs = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/purejs.mjs"() {
      init_p256();
      init_sha256_uint8array();
      init_dist();
      signWithApiKey3 = async (input) => {
        const publicKey = p2562.getPublicKey(input.privateKey, true);
        const publicKeyString = uint8ArrayToHexString(publicKey);
        if (publicKeyString != input.publicKey) {
          throw new Error(`Bad API key. Expected to get public key ${input.publicKey}, got ${publicKeyString}`);
        }
        const hash2 = createHash().update(input.content).digest();
        const signature = p2562.sign(hash2, input.privateKey);
        return signature.toDERHex();
      };
    }
  });

  // node_modules/@turnkey/api-key-stamper/dist/index.mjs
  var stampHeaderName, isCryptoEnabledBrowser, isNode, detectRuntime, signWithApiKey4, ApiKeyStamper;
  var init_dist2 = __esm({
    "node_modules/@turnkey/api-key-stamper/dist/index.mjs"() {
      init_dist();
      init_elliptic_curves();
      stampHeaderName = "X-Stamp";
      isCryptoEnabledBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
      isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      detectRuntime = () => {
        if (isCryptoEnabledBrowser) {
          return "browser";
        }
        if (isNode) {
          return "node";
        }
        return "purejs";
      };
      signWithApiKey4 = async (input, runtimeOverride) => {
        const runtime = runtimeOverride ?? detectRuntime();
        switch (runtime) {
          case "browser":
            return (await Promise.resolve().then(() => (init_webcrypto(), webcrypto_exports))).signWithApiKey(input);
          case "node":
            return (await Promise.resolve().then(() => (init_nodecrypto(), nodecrypto_exports))).signWithApiKey(input);
          case "purejs":
            return (await Promise.resolve().then(() => (init_purejs(), purejs_exports))).signWithApiKey(input);
          default:
            throw new Error(`Unsupported runtime: ${runtime}`);
        }
      };
      ApiKeyStamper = class {
        constructor(config2) {
          this.apiPublicKey = config2.apiPublicKey;
          this.apiPrivateKey = config2.apiPrivateKey;
          this.runtimeOverride = config2.runtimeOverride;
        }
        async stamp(payload) {
          const signature = await signWithApiKey4({
            publicKey: this.apiPublicKey,
            privateKey: this.apiPrivateKey,
            content: payload
          }, this.runtimeOverride);
          const stamp = {
            publicKey: this.apiPublicKey,
            scheme: "SIGNATURE_SCHEME_TK_API_P256",
            signature
          };
          return {
            stampHeaderName,
            stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
          };
        }
      };
    }
  });

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
      var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
      var __globalThis__ = function() {
        function F() {
          this.fetch = false;
          this.DOMException = __global__.DOMException;
        }
        F.prototype = __global__;
        return new F();
      }();
      (function(globalThis2) {
        var irrelevant = function(exports2) {
          var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
          typeof global !== "undefined" && global || {};
          var support = {
            searchParams: "URLSearchParams" in g,
            iterable: "Symbol" in g && "iterator" in Symbol,
            blob: "FileReader" in g && "Blob" in g && function() {
              try {
                new Blob();
                return true;
              } catch (e) {
                return false;
              }
            }(),
            formData: "FormData" in g,
            arrayBuffer: "ArrayBuffer" in g
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name) {
            if (typeof name !== "string") {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
              throw new TypeError('Invalid character in header field name: "' + name + '"');
            }
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                if (header.length != 2) {
                  throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
                }
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }
          Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
          };
          Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };
          Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };
          Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body._noBody) return;
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
            var encoding = match ? match[1] : "utf-8";
            reader.readAsText(blob, encoding);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this.bodyUsed = this.bodyUsed;
              this._bodyInit = body;
              if (!body) {
                this._noBody = true;
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
            }
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else if (support.blob) {
                return this.blob().then(readBlobAsArrayBuffer);
              } else {
                throw new Error("could not read as ArrayBuffer");
              }
            };
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode2);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request2(input, options) {
            if (!(this instanceof Request2)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            options = options || {};
            var body = options.body;
            if (input instanceof Request2) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal || function() {
              if ("AbortController" in g) {
                var ctrl = new AbortController();
                return ctrl.signal;
              }
            }();
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
            if (this.method === "GET" || this.method === "HEAD") {
              if (options.cache === "no-store" || options.cache === "no-cache") {
                var reParamSearch = /([?&])_=[^&]*/;
                if (reParamSearch.test(this.url)) {
                  this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                } else {
                  var reQueryString = /\?/;
                  this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                }
              }
            }
          }
          Request2.prototype.clone = function() {
            return new Request2(this, { body: this._bodyInit });
          };
          function decode2(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split2 = bytes.split("=");
                var name = split2.shift().replace(/\+/g, " ");
                var value = split2.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split("\r").map(function(header) {
              return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
            }).forEach(function(line) {
              var parts = line.split(":");
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(":").trim();
                try {
                  headers.append(key, value);
                } catch (error) {
                  console.warn("Response " + error.message);
                }
              }
            });
            return headers;
          }
          Body.call(Request2.prototype);
          function Response(bodyInit, options) {
            if (!(this instanceof Response)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            if (this.status < 200 || this.status > 599) {
              throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
            }
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
            this.headers = new Headers(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 200, statusText: "" });
            response.ok = false;
            response.status = 0;
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports2.DOMException = g.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name) {
              this.message = message;
              this.name = name;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch3(input, init2) {
            return new Promise(function(resolve, reject) {
              var request2 = new Request2(input, init2);
              if (request2.signal && request2.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                  options.status = 200;
                } else {
                  options.status = xhr.status;
                }
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                setTimeout(function() {
                  resolve(new Response(body, options));
                }, 0);
              };
              xhr.onerror = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request failed"));
                }, 0);
              };
              xhr.ontimeout = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request timed out"));
                }, 0);
              };
              xhr.onabort = function() {
                setTimeout(function() {
                  reject(new exports2.DOMException("Aborted", "AbortError"));
                }, 0);
              };
              function fixUrl(url) {
                try {
                  return url === "" && g.location.href ? g.location.href : url;
                } catch (e) {
                  return url;
                }
              }
              xhr.open(request2.method, fixUrl(request2.url), true);
              if (request2.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request2.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr) {
                if (support.blob) {
                  xhr.responseType = "blob";
                } else if (support.arrayBuffer) {
                  xhr.responseType = "arraybuffer";
                }
              }
              if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g.Headers && init2.headers instanceof g.Headers)) {
                var names = [];
                Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                  names.push(normalizeName(name));
                  xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
                });
                request2.headers.forEach(function(value, name) {
                  if (names.indexOf(name) === -1) {
                    xhr.setRequestHeader(name, value);
                  }
                });
              } else {
                request2.headers.forEach(function(value, name) {
                  xhr.setRequestHeader(name, value);
                });
              }
              if (request2.signal) {
                request2.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request2.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
            });
          }
          fetch3.polyfill = true;
          if (!g.fetch) {
            g.fetch = fetch3;
            g.Headers = Headers;
            g.Request = Request2;
            g.Response = Response;
          }
          exports2.Headers = Headers;
          exports2.Request = Request2;
          exports2.Response = Response;
          exports2.fetch = fetch3;
          Object.defineProperty(exports2, "__esModule", { value: true });
          return exports2;
        }({});
      })(__globalThis__);
      __globalThis__.fetch.ponyfill = true;
      delete __globalThis__.fetch.polyfill;
      var ctx = __global__.fetch ? __global__ : __globalThis__;
      exports = ctx.fetch;
      exports.default = ctx.fetch;
      exports.fetch = ctx.fetch;
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;
    }
  });

  // node_modules/@turnkey/http/dist/universal.mjs
  var import_cross_fetch, fetch2;
  var init_universal = __esm({
    "node_modules/@turnkey/http/dist/universal.mjs"() {
      import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
      fetch2 = import_cross_fetch.fetch;
    }
  });

  // node_modules/@turnkey/http/dist/config.mjs
  function browserInit(value) {
    browserConfig.baseUrl = assertNonEmptyString(value.baseUrl, "baseUrl");
  }
  function init(value) {
    config.apiPublicKey = assertNonEmptyString(value.apiPublicKey, "apiPublicKey");
    config.apiPrivateKey = assertNonEmptyString(value.apiPrivateKey, "apiPrivateKey");
    config.baseUrl = assertNonEmptyString(value.baseUrl, "baseUrl");
  }
  function getConfig() {
    return {
      apiPublicKey: assertNonEmptyString(config.apiPublicKey, "apiPublicKey"),
      apiPrivateKey: assertNonEmptyString(config.apiPrivateKey, "apiPrivateKey"),
      baseUrl: assertNonEmptyString(config.baseUrl, "baseUrl")
    };
  }
  function getBrowserConfig() {
    return {
      baseUrl: assertNonEmptyString(browserConfig.baseUrl, "baseUrl")
    };
  }
  function assertNonEmptyString(input, name) {
    if (typeof input !== "string" || !input) {
      throw new Error(`"${name}" must be a non-empty string`);
    }
    return input;
  }
  var config, browserConfig;
  var init_config = __esm({
    "node_modules/@turnkey/http/dist/config.mjs"() {
      config = {
        apiPublicKey: null,
        apiPrivateKey: null,
        baseUrl: null
      };
      browserConfig = {
        baseUrl: null
      };
    }
  });

  // node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs
  function bufferToBase64url(buffer2) {
    const byteView = new Uint8Array(buffer2);
    let str = "";
    for (const charCode of byteView) {
      str += String.fromCharCode(charCode);
    }
    const base64String = btoa(str);
    const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return base64urlString;
  }
  var init_base64url = __esm({
    "node_modules/@turnkey/http/dist/webauthn-json/base64url.mjs"() {
    }
  });

  // node_modules/@turnkey/http/dist/webauthn-json/convert.mjs
  function convert(conversionFn, schema, input) {
    if (schema === copyValue) {
      return input;
    }
    if (schema === convertValue) {
      return conversionFn(input);
    }
    if (schema instanceof Array) {
      return input.map((v) => convert(conversionFn, schema[0], v));
    }
    if (schema instanceof Object) {
      const output = {};
      for (const [key, schemaField] of Object.entries(schema)) {
        if (schemaField.derive) {
          const v = schemaField.derive(input);
          if (v !== void 0) {
            input[key] = v;
          }
        }
        if (!(key in input)) {
          if (schemaField.required) {
            throw new Error(`Missing key: ${key}`);
          }
          continue;
        }
        if (input[key] == null) {
          output[key] = null;
          continue;
        }
        output[key] = convert(conversionFn, schemaField.schema, input[key]);
      }
      return output;
    }
  }
  function derived(schema, derive) {
    return {
      required: true,
      schema,
      derive
    };
  }
  function required(schema) {
    return {
      required: true,
      schema
    };
  }
  function optional(schema) {
    return {
      required: false,
      schema
    };
  }
  var copyValue, convertValue;
  var init_convert = __esm({
    "node_modules/@turnkey/http/dist/webauthn-json/convert.mjs"() {
      copyValue = "copy";
      convertValue = "convert";
    }
  });

  // node_modules/@turnkey/http/dist/webauthn-json/schema.mjs
  var simplifiedClientExtensionResultsSchema, publicKeyCredentialWithAttestation, publicKeyCredentialWithAssertion;
  var init_schema = __esm({
    "node_modules/@turnkey/http/dist/webauthn-json/schema.mjs"() {
      init_convert();
      simplifiedClientExtensionResultsSchema = {
        appid: optional(copyValue),
        appidExclude: optional(copyValue),
        credProps: optional(copyValue)
      };
      publicKeyCredentialWithAttestation = {
        type: required(copyValue),
        id: required(copyValue),
        rawId: required(convertValue),
        authenticatorAttachment: optional(copyValue),
        response: required({
          clientDataJSON: required(convertValue),
          attestationObject: required(convertValue),
          transports: derived(copyValue, (response) => response.getTransports?.() || [])
        }),
        clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
      };
      publicKeyCredentialWithAssertion = {
        type: required(copyValue),
        id: required(copyValue),
        rawId: required(convertValue),
        authenticatorAttachment: optional(copyValue),
        response: required({
          clientDataJSON: required(convertValue),
          authenticatorData: required(convertValue),
          signature: required(convertValue),
          userHandle: required(convertValue)
        }),
        clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
      };
    }
  });

  // node_modules/@turnkey/http/dist/webauthn-json/api.mjs
  function createResponseToJSON(credential) {
    return convert(bufferToBase64url, publicKeyCredentialWithAttestation, credential);
  }
  function getResponseToJSON(credential) {
    return convert(bufferToBase64url, publicKeyCredentialWithAssertion, credential);
  }
  var init_api = __esm({
    "node_modules/@turnkey/http/dist/webauthn-json/api.mjs"() {
      init_base64url();
      init_convert();
      init_schema();
    }
  });

  // node_modules/@turnkey/http/dist/webauthn-json/index.mjs
  async function create(options) {
    const response = await navigator.credentials.create(options);
    response.toJSON = () => createResponseToJSON(response);
    return response;
  }
  async function get(options) {
    const response = await navigator.credentials.get(options);
    response.toJSON = () => getResponseToJSON(response);
    return response;
  }
  var init_webauthn_json = __esm({
    "node_modules/@turnkey/http/dist/webauthn-json/index.mjs"() {
      init_api();
    }
  });

  // node_modules/@turnkey/http/dist/webauthn.mjs
  async function getCredentialRequestOptions(payload, tkSigningOptions = defaultSigningOptions) {
    const challenge2 = await getChallengeFromPayload(payload);
    const signingOptions = {
      ...tkSigningOptions,
      publicKey: {
        ...defaultSigningOptions.publicKey,
        ...tkSigningOptions.publicKey,
        challenge: challenge2
      }
    };
    return signingOptions;
  }
  async function getChallengeFromPayload(payload) {
    const messageBuffer = new TextEncoder().encode(payload);
    const hashBuffer = await crypto.subtle.digest("SHA-256", messageBuffer);
    const hexString = Buffer.from(hashBuffer).toString("hex");
    const hexBuffer = Buffer.from(hexString, "utf8");
    return new Uint8Array(hexBuffer);
  }
  function protocolTransportEnumToInternalEnum(protocolEnum) {
    switch (protocolEnum) {
      case "internal": {
        return "AUTHENTICATOR_TRANSPORT_INTERNAL";
      }
      case "usb": {
        return "AUTHENTICATOR_TRANSPORT_USB";
      }
      case "nfc": {
        return "AUTHENTICATOR_TRANSPORT_NFC";
      }
      case "ble": {
        return "AUTHENTICATOR_TRANSPORT_BLE";
      }
      case "hybrid": {
        return "AUTHENTICATOR_TRANSPORT_HYBRID";
      }
      default: {
        throw new Error("unsupported transport format");
      }
    }
  }
  function toInternalAttestation(attestation) {
    return {
      credentialId: attestation.rawId,
      attestationObject: attestation.response.attestationObject,
      clientDataJson: attestation.response.clientDataJSON,
      transports: attestation.response.transports.map(protocolTransportEnumToInternalEnum)
    };
  }
  async function getWebAuthnAssertion(payload, options) {
    const webAuthnSupported = hasWebAuthnSupport();
    if (!webAuthnSupported) {
      throw new Error("webauthn is not supported by this browser");
    }
    const signingOptions = await getCredentialRequestOptions(payload, options);
    const clientGetResult = await get(signingOptions);
    const assertion = clientGetResult.toJSON();
    const stamp = {
      authenticatorData: assertion.response.authenticatorData,
      clientDataJson: assertion.response.clientDataJSON,
      credentialId: assertion.id,
      signature: assertion.response.signature
    };
    return JSON.stringify(stamp);
  }
  async function getWebAuthnAttestation(options) {
    const webAuthnSupported = hasWebAuthnSupport();
    if (!webAuthnSupported) {
      throw new Error("webauthn is not supported by this browser");
    }
    const res = await create(options);
    return toInternalAttestation(res.toJSON());
  }
  function hasWebAuthnSupport() {
    return !!window.PublicKeyCredential;
  }
  var defaultTimeout, defaultUserVerification, defaultSigningOptions;
  var init_webauthn = __esm({
    "node_modules/@turnkey/http/dist/webauthn.mjs"() {
      init_webauthn_json();
      defaultTimeout = 5 * 60 * 1e3;
      defaultUserVerification = "preferred";
      defaultSigningOptions = {
        publicKey: {
          timeout: defaultTimeout,
          userVerification: defaultUserVerification
        }
      };
    }
  });

  // node_modules/@turnkey/http/dist/base.mjs
  async function signedRequest(input) {
    const { uri: inputUri, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {} } = input;
    const url = constructUrl({
      uri: inputUri,
      query: inputQuery,
      substitution: inputSubstitution
    });
    const body = JSON.stringify(inputBody);
    const stamp = await getWebAuthnAssertion(body, input.options);
    return {
      url: url.toString(),
      body,
      stamp
    };
  }
  async function request(input) {
    const { uri: inputUri, method, headers: inputHeaders = {}, query: inputQuery = {}, substitution: inputSubstitution = {}, body: inputBody = {} } = input;
    const url = constructUrl({
      uri: inputUri,
      query: inputQuery,
      substitution: inputSubstitution
    });
    const { sealedBody, xStamp } = await sealAndStampRequestBody({
      body: inputBody
    });
    const response = await fetch2(url.toString(), {
      ...sharedRequestOptions,
      method,
      headers: {
        ...sharedHeaders,
        ...inputHeaders,
        "X-Stamp": xStamp
      },
      body: sealedBody
    });
    if (!response.ok) {
      let res;
      try {
        res = await response.json();
      } catch (_) {
        throw new Error(`${response.status} ${response.statusText}`);
      }
      throw new TurnkeyRequestError(res);
    }
    const data = await response.json();
    return data;
  }
  function constructUrl(input) {
    const { uri, query, substitution } = input;
    const baseUrl = getBaseUrl();
    const url = new URL(substitutePath(uri, substitution), baseUrl);
    for (const key in query) {
      const value = query[key];
      if (Array.isArray(value)) {
        for (const item of value) {
          url.searchParams.append(key, item);
        }
      } else {
        url.searchParams.append(key, value ?? "");
      }
    }
    return url;
  }
  function getBaseUrl() {
    try {
      const { baseUrl } = getConfig();
      return baseUrl;
    } catch (e) {
      const { baseUrl } = getBrowserConfig();
      return baseUrl;
    }
  }
  function substitutePath(uri, substitutionMap) {
    let result = uri;
    const keyList = Object.keys(substitutionMap);
    for (const key of keyList) {
      const output = result.replaceAll(`{${key}}`, substitutionMap[key]);
      invariant(output !== result, `Substitution error: cannot find "${key}" in URI "${uri}". \`substitutionMap\`: ${JSON.stringify(substitutionMap)}`);
      result = output;
    }
    invariant(!/\{.*\}/.test(result), `Substitution error: found unsubstituted components in "${result}"`);
    return result;
  }
  function invariant(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function stableStringify(input) {
    return JSON.stringify(input);
  }
  async function sealAndStampRequestBody(input) {
    const { body } = input;
    let { apiPublicKey, apiPrivateKey } = input;
    if (!apiPublicKey) {
      const config2 = getConfig();
      apiPublicKey = config2.apiPublicKey;
    }
    if (!apiPrivateKey) {
      const config2 = getConfig();
      apiPrivateKey = config2.apiPrivateKey;
    }
    const sealedBody = stableStringify(body);
    const signature = await signWithApiKey4({
      content: sealedBody,
      privateKey: apiPrivateKey,
      publicKey: apiPublicKey
    });
    const sealedStamp = stableStringify({
      publicKey: apiPublicKey,
      scheme: "SIGNATURE_SCHEME_TK_API_P256",
      signature
    });
    const xStamp = stringToBase64urlString(sealedStamp);
    return {
      sealedBody,
      xStamp
    };
  }
  function isHttpClient(client) {
    return client?.name === "TurnkeyClient";
  }
  var sharedHeaders, sharedRequestOptions, TurnkeyRequestError;
  var init_base = __esm({
    "node_modules/@turnkey/http/dist/base.mjs"() {
      init_dist2();
      init_universal();
      init_config();
      init_dist();
      init_webauthn();
      sharedHeaders = {};
      sharedRequestOptions = {
        redirect: "follow"
      };
      TurnkeyRequestError = class extends Error {
        constructor(input) {
          let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
          if (input.details != null) {
            turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
          }
          super(turnkeyErrorMessage);
          this.name = "TurnkeyRequestError";
          this.details = input.details ?? null;
          this.code = input.code;
        }
      };
    }
  });

  // node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs
  var public_api_fetcher_exports = {};
  __export(public_api_fetcher_exports, {
    approveActivity: () => approveActivity,
    createApiKeys: () => createApiKeys,
    createApiOnlyUsers: () => createApiOnlyUsers,
    createAuthenticators: () => createAuthenticators,
    createInvitations: () => createInvitations,
    createOauthProviders: () => createOauthProviders,
    createPolicies: () => createPolicies,
    createPolicy: () => createPolicy,
    createPrivateKeyTag: () => createPrivateKeyTag,
    createPrivateKeys: () => createPrivateKeys,
    createReadOnlySession: () => createReadOnlySession,
    createReadWriteSession: () => createReadWriteSession,
    createSmartContractInterface: () => createSmartContractInterface,
    createSubOrganization: () => createSubOrganization,
    createUserTag: () => createUserTag,
    createUsers: () => createUsers,
    createWallet: () => createWallet,
    createWalletAccounts: () => createWalletAccounts,
    deleteApiKeys: () => deleteApiKeys,
    deleteAuthenticators: () => deleteAuthenticators,
    deleteInvitation: () => deleteInvitation,
    deleteOauthProviders: () => deleteOauthProviders,
    deletePolicy: () => deletePolicy,
    deletePrivateKeyTags: () => deletePrivateKeyTags,
    deletePrivateKeys: () => deletePrivateKeys,
    deleteSmartContractInterface: () => deleteSmartContractInterface,
    deleteSubOrganization: () => deleteSubOrganization,
    deleteUserTags: () => deleteUserTags,
    deleteUsers: () => deleteUsers,
    deleteWallets: () => deleteWallets,
    emailAuth: () => emailAuth,
    exportPrivateKey: () => exportPrivateKey,
    exportWallet: () => exportWallet,
    exportWalletAccount: () => exportWalletAccount,
    getActivities: () => getActivities,
    getActivity: () => getActivity,
    getApiKey: () => getApiKey,
    getApiKeys: () => getApiKeys,
    getAttestationDocument: () => getAttestationDocument,
    getAuthenticator: () => getAuthenticator,
    getAuthenticators: () => getAuthenticators,
    getOauthProviders: () => getOauthProviders,
    getOrganization: () => getOrganization,
    getOrganizationConfigs: () => getOrganizationConfigs,
    getPolicies: () => getPolicies,
    getPolicy: () => getPolicy,
    getPrivateKey: () => getPrivateKey,
    getPrivateKeys: () => getPrivateKeys,
    getSmartContractInterface: () => getSmartContractInterface,
    getSmartContractInterfaces: () => getSmartContractInterfaces,
    getSubOrgIds: () => getSubOrgIds,
    getUser: () => getUser,
    getUsers: () => getUsers,
    getVerifiedSubOrgIds: () => getVerifiedSubOrgIds,
    getWallet: () => getWallet,
    getWalletAccount: () => getWalletAccount,
    getWalletAccounts: () => getWalletAccounts,
    getWallets: () => getWallets,
    getWhoami: () => getWhoami,
    importPrivateKey: () => importPrivateKey,
    importWallet: () => importWallet,
    initFiatOnRamp: () => initFiatOnRamp,
    initImportPrivateKey: () => initImportPrivateKey,
    initImportWallet: () => initImportWallet,
    initOtp: () => initOtp,
    initOtpAuth: () => initOtpAuth,
    initUserEmailRecovery: () => initUserEmailRecovery,
    listPrivateKeyTags: () => listPrivateKeyTags,
    listUserTags: () => listUserTags,
    nOOPCodegenAnchor: () => nOOPCodegenAnchor,
    oauth: () => oauth,
    oauthLogin: () => oauthLogin,
    otpAuth: () => otpAuth,
    otpLogin: () => otpLogin,
    recoverUser: () => recoverUser,
    rejectActivity: () => rejectActivity,
    removeOrganizationFeature: () => removeOrganizationFeature,
    setOrganizationFeature: () => setOrganizationFeature,
    signApproveActivity: () => signApproveActivity,
    signCreateApiKeys: () => signCreateApiKeys,
    signCreateApiOnlyUsers: () => signCreateApiOnlyUsers,
    signCreateAuthenticators: () => signCreateAuthenticators,
    signCreateInvitations: () => signCreateInvitations,
    signCreateOauthProviders: () => signCreateOauthProviders,
    signCreatePolicies: () => signCreatePolicies,
    signCreatePolicy: () => signCreatePolicy,
    signCreatePrivateKeyTag: () => signCreatePrivateKeyTag,
    signCreatePrivateKeys: () => signCreatePrivateKeys,
    signCreateReadOnlySession: () => signCreateReadOnlySession,
    signCreateReadWriteSession: () => signCreateReadWriteSession,
    signCreateSmartContractInterface: () => signCreateSmartContractInterface,
    signCreateSubOrganization: () => signCreateSubOrganization,
    signCreateUserTag: () => signCreateUserTag,
    signCreateUsers: () => signCreateUsers,
    signCreateWallet: () => signCreateWallet,
    signCreateWalletAccounts: () => signCreateWalletAccounts,
    signDeleteApiKeys: () => signDeleteApiKeys,
    signDeleteAuthenticators: () => signDeleteAuthenticators,
    signDeleteInvitation: () => signDeleteInvitation,
    signDeleteOauthProviders: () => signDeleteOauthProviders,
    signDeletePolicy: () => signDeletePolicy,
    signDeletePrivateKeyTags: () => signDeletePrivateKeyTags,
    signDeletePrivateKeys: () => signDeletePrivateKeys,
    signDeleteSmartContractInterface: () => signDeleteSmartContractInterface,
    signDeleteSubOrganization: () => signDeleteSubOrganization,
    signDeleteUserTags: () => signDeleteUserTags,
    signDeleteUsers: () => signDeleteUsers,
    signDeleteWallets: () => signDeleteWallets,
    signEmailAuth: () => signEmailAuth,
    signExportPrivateKey: () => signExportPrivateKey,
    signExportWallet: () => signExportWallet,
    signExportWalletAccount: () => signExportWalletAccount,
    signGetActivities: () => signGetActivities,
    signGetActivity: () => signGetActivity,
    signGetApiKey: () => signGetApiKey,
    signGetApiKeys: () => signGetApiKeys,
    signGetAttestationDocument: () => signGetAttestationDocument,
    signGetAuthenticator: () => signGetAuthenticator,
    signGetAuthenticators: () => signGetAuthenticators,
    signGetOauthProviders: () => signGetOauthProviders,
    signGetOrganization: () => signGetOrganization,
    signGetOrganizationConfigs: () => signGetOrganizationConfigs,
    signGetPolicies: () => signGetPolicies,
    signGetPolicy: () => signGetPolicy,
    signGetPrivateKey: () => signGetPrivateKey,
    signGetPrivateKeys: () => signGetPrivateKeys,
    signGetSmartContractInterface: () => signGetSmartContractInterface,
    signGetSmartContractInterfaces: () => signGetSmartContractInterfaces,
    signGetSubOrgIds: () => signGetSubOrgIds,
    signGetUser: () => signGetUser,
    signGetUsers: () => signGetUsers,
    signGetVerifiedSubOrgIds: () => signGetVerifiedSubOrgIds,
    signGetWallet: () => signGetWallet,
    signGetWalletAccount: () => signGetWalletAccount,
    signGetWalletAccounts: () => signGetWalletAccounts,
    signGetWallets: () => signGetWallets,
    signGetWhoami: () => signGetWhoami,
    signImportPrivateKey: () => signImportPrivateKey,
    signImportWallet: () => signImportWallet,
    signInitFiatOnRamp: () => signInitFiatOnRamp,
    signInitImportPrivateKey: () => signInitImportPrivateKey,
    signInitImportWallet: () => signInitImportWallet,
    signInitOtp: () => signInitOtp,
    signInitOtpAuth: () => signInitOtpAuth,
    signInitUserEmailRecovery: () => signInitUserEmailRecovery,
    signListPrivateKeyTags: () => signListPrivateKeyTags,
    signListUserTags: () => signListUserTags,
    signNOOPCodegenAnchor: () => signNOOPCodegenAnchor,
    signOauth: () => signOauth,
    signOauthLogin: () => signOauthLogin,
    signOtpAuth: () => signOtpAuth,
    signOtpLogin: () => signOtpLogin,
    signRawPayload: () => signRawPayload,
    signRawPayloads: () => signRawPayloads,
    signRecoverUser: () => signRecoverUser,
    signRejectActivity: () => signRejectActivity,
    signRemoveOrganizationFeature: () => signRemoveOrganizationFeature,
    signSetOrganizationFeature: () => signSetOrganizationFeature,
    signSignRawPayload: () => signSignRawPayload,
    signSignRawPayloads: () => signSignRawPayloads,
    signSignTransaction: () => signSignTransaction,
    signStampLogin: () => signStampLogin,
    signTestRateLimits: () => signTestRateLimits,
    signTransaction: () => signTransaction,
    signUpdatePolicy: () => signUpdatePolicy,
    signUpdatePrivateKeyTag: () => signUpdatePrivateKeyTag,
    signUpdateRootQuorum: () => signUpdateRootQuorum,
    signUpdateUser: () => signUpdateUser,
    signUpdateUserEmail: () => signUpdateUserEmail,
    signUpdateUserName: () => signUpdateUserName,
    signUpdateUserPhoneNumber: () => signUpdateUserPhoneNumber,
    signUpdateUserTag: () => signUpdateUserTag,
    signUpdateWallet: () => signUpdateWallet,
    signVerifyOtp: () => signVerifyOtp,
    stampLogin: () => stampLogin,
    testRateLimits: () => testRateLimits,
    updatePolicy: () => updatePolicy,
    updatePrivateKeyTag: () => updatePrivateKeyTag,
    updateRootQuorum: () => updateRootQuorum,
    updateUser: () => updateUser,
    updateUserEmail: () => updateUserEmail,
    updateUserName: () => updateUserName,
    updateUserPhoneNumber: () => updateUserPhoneNumber,
    updateUserTag: () => updateUserTag,
    updateWallet: () => updateWallet,
    verifyOtp: () => verifyOtp
  });
  var getActivity, signGetActivity, getApiKey, signGetApiKey, getApiKeys, signGetApiKeys, getAttestationDocument, signGetAttestationDocument, getAuthenticator, signGetAuthenticator, getAuthenticators, signGetAuthenticators, getOauthProviders, signGetOauthProviders, getOrganization, signGetOrganization, getOrganizationConfigs, signGetOrganizationConfigs, getPolicy, signGetPolicy, getPrivateKey, signGetPrivateKey, getSmartContractInterface, signGetSmartContractInterface, getUser, signGetUser, getWallet, signGetWallet, getWalletAccount, signGetWalletAccount, getActivities, signGetActivities, getPolicies, signGetPolicies, listPrivateKeyTags, signListPrivateKeyTags, getPrivateKeys, signGetPrivateKeys, getSmartContractInterfaces, signGetSmartContractInterfaces, getSubOrgIds, signGetSubOrgIds, listUserTags, signListUserTags, getUsers, signGetUsers, getVerifiedSubOrgIds, signGetVerifiedSubOrgIds, getWalletAccounts, signGetWalletAccounts, getWallets, signGetWallets, getWhoami, signGetWhoami, approveActivity, signApproveActivity, createApiKeys, signCreateApiKeys, createApiOnlyUsers, signCreateApiOnlyUsers, createAuthenticators, signCreateAuthenticators, createInvitations, signCreateInvitations, createOauthProviders, signCreateOauthProviders, createPolicies, signCreatePolicies, createPolicy, signCreatePolicy, createPrivateKeyTag, signCreatePrivateKeyTag, createPrivateKeys, signCreatePrivateKeys, createReadOnlySession, signCreateReadOnlySession, createReadWriteSession, signCreateReadWriteSession, createSmartContractInterface, signCreateSmartContractInterface, createSubOrganization, signCreateSubOrganization, createUserTag, signCreateUserTag, createUsers, signCreateUsers, createWallet, signCreateWallet, createWalletAccounts, signCreateWalletAccounts, deleteApiKeys, signDeleteApiKeys, deleteAuthenticators, signDeleteAuthenticators, deleteInvitation, signDeleteInvitation, deleteOauthProviders, signDeleteOauthProviders, deletePolicy, signDeletePolicy, deletePrivateKeyTags, signDeletePrivateKeyTags, deletePrivateKeys, signDeletePrivateKeys, deleteSmartContractInterface, signDeleteSmartContractInterface, deleteSubOrganization, signDeleteSubOrganization, deleteUserTags, signDeleteUserTags, deleteUsers, signDeleteUsers, deleteWallets, signDeleteWallets, emailAuth, signEmailAuth, exportPrivateKey, signExportPrivateKey, exportWallet, signExportWallet, exportWalletAccount, signExportWalletAccount, importPrivateKey, signImportPrivateKey, importWallet, signImportWallet, initFiatOnRamp, signInitFiatOnRamp, initImportPrivateKey, signInitImportPrivateKey, initImportWallet, signInitImportWallet, initOtp, signInitOtp, initOtpAuth, signInitOtpAuth, initUserEmailRecovery, signInitUserEmailRecovery, oauth, signOauth, oauthLogin, signOauthLogin, otpAuth, signOtpAuth, otpLogin, signOtpLogin, recoverUser, signRecoverUser, rejectActivity, signRejectActivity, removeOrganizationFeature, signRemoveOrganizationFeature, setOrganizationFeature, signSetOrganizationFeature, signRawPayload, signSignRawPayload, signRawPayloads, signSignRawPayloads, signTransaction, signSignTransaction, stampLogin, signStampLogin, updatePolicy, signUpdatePolicy, updatePrivateKeyTag, signUpdatePrivateKeyTag, updateRootQuorum, signUpdateRootQuorum, updateUser, signUpdateUser, updateUserEmail, signUpdateUserEmail, updateUserName, signUpdateUserName, updateUserPhoneNumber, signUpdateUserPhoneNumber, updateUserTag, signUpdateUserTag, updateWallet, signUpdateWallet, verifyOtp, signVerifyOtp, nOOPCodegenAnchor, signNOOPCodegenAnchor, testRateLimits, signTestRateLimits;
  var init_public_api_fetcher = __esm({
    "node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.fetcher.mjs"() {
      init_base();
      getActivity = (input) => request({
        uri: "/public/v1/query/get_activity",
        method: "POST",
        body: input.body
      });
      signGetActivity = (input, options) => signedRequest({
        uri: "/public/v1/query/get_activity",
        body: input.body,
        options
      });
      getApiKey = (input) => request({
        uri: "/public/v1/query/get_api_key",
        method: "POST",
        body: input.body
      });
      signGetApiKey = (input, options) => signedRequest({
        uri: "/public/v1/query/get_api_key",
        body: input.body,
        options
      });
      getApiKeys = (input) => request({
        uri: "/public/v1/query/get_api_keys",
        method: "POST",
        body: input.body
      });
      signGetApiKeys = (input, options) => signedRequest({
        uri: "/public/v1/query/get_api_keys",
        body: input.body,
        options
      });
      getAttestationDocument = (input) => request({
        uri: "/public/v1/query/get_attestation",
        method: "POST",
        body: input.body
      });
      signGetAttestationDocument = (input, options) => signedRequest({
        uri: "/public/v1/query/get_attestation",
        body: input.body,
        options
      });
      getAuthenticator = (input) => request({
        uri: "/public/v1/query/get_authenticator",
        method: "POST",
        body: input.body
      });
      signGetAuthenticator = (input, options) => signedRequest({
        uri: "/public/v1/query/get_authenticator",
        body: input.body,
        options
      });
      getAuthenticators = (input) => request({
        uri: "/public/v1/query/get_authenticators",
        method: "POST",
        body: input.body
      });
      signGetAuthenticators = (input, options) => signedRequest({
        uri: "/public/v1/query/get_authenticators",
        body: input.body,
        options
      });
      getOauthProviders = (input) => request({
        uri: "/public/v1/query/get_oauth_providers",
        method: "POST",
        body: input.body
      });
      signGetOauthProviders = (input, options) => signedRequest({
        uri: "/public/v1/query/get_oauth_providers",
        body: input.body,
        options
      });
      getOrganization = (input) => request({
        uri: "/public/v1/query/get_organization",
        method: "POST",
        body: input.body
      });
      signGetOrganization = (input, options) => signedRequest({
        uri: "/public/v1/query/get_organization",
        body: input.body,
        options
      });
      getOrganizationConfigs = (input) => request({
        uri: "/public/v1/query/get_organization_configs",
        method: "POST",
        body: input.body
      });
      signGetOrganizationConfigs = (input, options) => signedRequest({
        uri: "/public/v1/query/get_organization_configs",
        body: input.body,
        options
      });
      getPolicy = (input) => request({
        uri: "/public/v1/query/get_policy",
        method: "POST",
        body: input.body
      });
      signGetPolicy = (input, options) => signedRequest({
        uri: "/public/v1/query/get_policy",
        body: input.body,
        options
      });
      getPrivateKey = (input) => request({
        uri: "/public/v1/query/get_private_key",
        method: "POST",
        body: input.body
      });
      signGetPrivateKey = (input, options) => signedRequest({
        uri: "/public/v1/query/get_private_key",
        body: input.body,
        options
      });
      getSmartContractInterface = (input) => request({
        uri: "/public/v1/query/get_smart_contract_interface",
        method: "POST",
        body: input.body
      });
      signGetSmartContractInterface = (input, options) => signedRequest({
        uri: "/public/v1/query/get_smart_contract_interface",
        body: input.body,
        options
      });
      getUser = (input) => request({
        uri: "/public/v1/query/get_user",
        method: "POST",
        body: input.body
      });
      signGetUser = (input, options) => signedRequest({
        uri: "/public/v1/query/get_user",
        body: input.body,
        options
      });
      getWallet = (input) => request({
        uri: "/public/v1/query/get_wallet",
        method: "POST",
        body: input.body
      });
      signGetWallet = (input, options) => signedRequest({
        uri: "/public/v1/query/get_wallet",
        body: input.body,
        options
      });
      getWalletAccount = (input) => request({
        uri: "/public/v1/query/get_wallet_account",
        method: "POST",
        body: input.body
      });
      signGetWalletAccount = (input, options) => signedRequest({
        uri: "/public/v1/query/get_wallet_account",
        body: input.body,
        options
      });
      getActivities = (input) => request({
        uri: "/public/v1/query/list_activities",
        method: "POST",
        body: input.body
      });
      signGetActivities = (input, options) => signedRequest({
        uri: "/public/v1/query/list_activities",
        body: input.body,
        options
      });
      getPolicies = (input) => request({
        uri: "/public/v1/query/list_policies",
        method: "POST",
        body: input.body
      });
      signGetPolicies = (input, options) => signedRequest({
        uri: "/public/v1/query/list_policies",
        body: input.body,
        options
      });
      listPrivateKeyTags = (input) => request({
        uri: "/public/v1/query/list_private_key_tags",
        method: "POST",
        body: input.body
      });
      signListPrivateKeyTags = (input, options) => signedRequest({
        uri: "/public/v1/query/list_private_key_tags",
        body: input.body,
        options
      });
      getPrivateKeys = (input) => request({
        uri: "/public/v1/query/list_private_keys",
        method: "POST",
        body: input.body
      });
      signGetPrivateKeys = (input, options) => signedRequest({
        uri: "/public/v1/query/list_private_keys",
        body: input.body,
        options
      });
      getSmartContractInterfaces = (input) => request({
        uri: "/public/v1/query/list_smart_contract_interfaces",
        method: "POST",
        body: input.body
      });
      signGetSmartContractInterfaces = (input, options) => signedRequest({
        uri: "/public/v1/query/list_smart_contract_interfaces",
        body: input.body,
        options
      });
      getSubOrgIds = (input) => request({
        uri: "/public/v1/query/list_suborgs",
        method: "POST",
        body: input.body
      });
      signGetSubOrgIds = (input, options) => signedRequest({
        uri: "/public/v1/query/list_suborgs",
        body: input.body,
        options
      });
      listUserTags = (input) => request({
        uri: "/public/v1/query/list_user_tags",
        method: "POST",
        body: input.body
      });
      signListUserTags = (input, options) => signedRequest({
        uri: "/public/v1/query/list_user_tags",
        body: input.body,
        options
      });
      getUsers = (input) => request({
        uri: "/public/v1/query/list_users",
        method: "POST",
        body: input.body
      });
      signGetUsers = (input, options) => signedRequest({
        uri: "/public/v1/query/list_users",
        body: input.body,
        options
      });
      getVerifiedSubOrgIds = (input) => request({
        uri: "/public/v1/query/list_verified_suborgs",
        method: "POST",
        body: input.body
      });
      signGetVerifiedSubOrgIds = (input, options) => signedRequest({
        uri: "/public/v1/query/list_verified_suborgs",
        body: input.body,
        options
      });
      getWalletAccounts = (input) => request({
        uri: "/public/v1/query/list_wallet_accounts",
        method: "POST",
        body: input.body
      });
      signGetWalletAccounts = (input, options) => signedRequest({
        uri: "/public/v1/query/list_wallet_accounts",
        body: input.body,
        options
      });
      getWallets = (input) => request({
        uri: "/public/v1/query/list_wallets",
        method: "POST",
        body: input.body
      });
      signGetWallets = (input, options) => signedRequest({
        uri: "/public/v1/query/list_wallets",
        body: input.body,
        options
      });
      getWhoami = (input) => request({
        uri: "/public/v1/query/whoami",
        method: "POST",
        body: input.body
      });
      signGetWhoami = (input, options) => signedRequest({
        uri: "/public/v1/query/whoami",
        body: input.body,
        options
      });
      approveActivity = (input) => request({
        uri: "/public/v1/submit/approve_activity",
        method: "POST",
        body: input.body
      });
      signApproveActivity = (input, options) => signedRequest({
        uri: "/public/v1/submit/approve_activity",
        body: input.body,
        options
      });
      createApiKeys = (input) => request({
        uri: "/public/v1/submit/create_api_keys",
        method: "POST",
        body: input.body
      });
      signCreateApiKeys = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_api_keys",
        body: input.body,
        options
      });
      createApiOnlyUsers = (input) => request({
        uri: "/public/v1/submit/create_api_only_users",
        method: "POST",
        body: input.body
      });
      signCreateApiOnlyUsers = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_api_only_users",
        body: input.body,
        options
      });
      createAuthenticators = (input) => request({
        uri: "/public/v1/submit/create_authenticators",
        method: "POST",
        body: input.body
      });
      signCreateAuthenticators = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_authenticators",
        body: input.body,
        options
      });
      createInvitations = (input) => request({
        uri: "/public/v1/submit/create_invitations",
        method: "POST",
        body: input.body
      });
      signCreateInvitations = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_invitations",
        body: input.body,
        options
      });
      createOauthProviders = (input) => request({
        uri: "/public/v1/submit/create_oauth_providers",
        method: "POST",
        body: input.body
      });
      signCreateOauthProviders = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_oauth_providers",
        body: input.body,
        options
      });
      createPolicies = (input) => request({
        uri: "/public/v1/submit/create_policies",
        method: "POST",
        body: input.body
      });
      signCreatePolicies = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_policies",
        body: input.body,
        options
      });
      createPolicy = (input) => request({
        uri: "/public/v1/submit/create_policy",
        method: "POST",
        body: input.body
      });
      signCreatePolicy = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_policy",
        body: input.body,
        options
      });
      createPrivateKeyTag = (input) => request({
        uri: "/public/v1/submit/create_private_key_tag",
        method: "POST",
        body: input.body
      });
      signCreatePrivateKeyTag = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_private_key_tag",
        body: input.body,
        options
      });
      createPrivateKeys = (input) => request({
        uri: "/public/v1/submit/create_private_keys",
        method: "POST",
        body: input.body
      });
      signCreatePrivateKeys = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_private_keys",
        body: input.body,
        options
      });
      createReadOnlySession = (input) => request({
        uri: "/public/v1/submit/create_read_only_session",
        method: "POST",
        body: input.body
      });
      signCreateReadOnlySession = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_read_only_session",
        body: input.body,
        options
      });
      createReadWriteSession = (input) => request({
        uri: "/public/v1/submit/create_read_write_session",
        method: "POST",
        body: input.body
      });
      signCreateReadWriteSession = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_read_write_session",
        body: input.body,
        options
      });
      createSmartContractInterface = (input) => request({
        uri: "/public/v1/submit/create_smart_contract_interface",
        method: "POST",
        body: input.body
      });
      signCreateSmartContractInterface = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_smart_contract_interface",
        body: input.body,
        options
      });
      createSubOrganization = (input) => request({
        uri: "/public/v1/submit/create_sub_organization",
        method: "POST",
        body: input.body
      });
      signCreateSubOrganization = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_sub_organization",
        body: input.body,
        options
      });
      createUserTag = (input) => request({
        uri: "/public/v1/submit/create_user_tag",
        method: "POST",
        body: input.body
      });
      signCreateUserTag = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_user_tag",
        body: input.body,
        options
      });
      createUsers = (input) => request({
        uri: "/public/v1/submit/create_users",
        method: "POST",
        body: input.body
      });
      signCreateUsers = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_users",
        body: input.body,
        options
      });
      createWallet = (input) => request({
        uri: "/public/v1/submit/create_wallet",
        method: "POST",
        body: input.body
      });
      signCreateWallet = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_wallet",
        body: input.body,
        options
      });
      createWalletAccounts = (input) => request({
        uri: "/public/v1/submit/create_wallet_accounts",
        method: "POST",
        body: input.body
      });
      signCreateWalletAccounts = (input, options) => signedRequest({
        uri: "/public/v1/submit/create_wallet_accounts",
        body: input.body,
        options
      });
      deleteApiKeys = (input) => request({
        uri: "/public/v1/submit/delete_api_keys",
        method: "POST",
        body: input.body
      });
      signDeleteApiKeys = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_api_keys",
        body: input.body,
        options
      });
      deleteAuthenticators = (input) => request({
        uri: "/public/v1/submit/delete_authenticators",
        method: "POST",
        body: input.body
      });
      signDeleteAuthenticators = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_authenticators",
        body: input.body,
        options
      });
      deleteInvitation = (input) => request({
        uri: "/public/v1/submit/delete_invitation",
        method: "POST",
        body: input.body
      });
      signDeleteInvitation = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_invitation",
        body: input.body,
        options
      });
      deleteOauthProviders = (input) => request({
        uri: "/public/v1/submit/delete_oauth_providers",
        method: "POST",
        body: input.body
      });
      signDeleteOauthProviders = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_oauth_providers",
        body: input.body,
        options
      });
      deletePolicy = (input) => request({
        uri: "/public/v1/submit/delete_policy",
        method: "POST",
        body: input.body
      });
      signDeletePolicy = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_policy",
        body: input.body,
        options
      });
      deletePrivateKeyTags = (input) => request({
        uri: "/public/v1/submit/delete_private_key_tags",
        method: "POST",
        body: input.body
      });
      signDeletePrivateKeyTags = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_private_key_tags",
        body: input.body,
        options
      });
      deletePrivateKeys = (input) => request({
        uri: "/public/v1/submit/delete_private_keys",
        method: "POST",
        body: input.body
      });
      signDeletePrivateKeys = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_private_keys",
        body: input.body,
        options
      });
      deleteSmartContractInterface = (input) => request({
        uri: "/public/v1/submit/delete_smart_contract_interface",
        method: "POST",
        body: input.body
      });
      signDeleteSmartContractInterface = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_smart_contract_interface",
        body: input.body,
        options
      });
      deleteSubOrganization = (input) => request({
        uri: "/public/v1/submit/delete_sub_organization",
        method: "POST",
        body: input.body
      });
      signDeleteSubOrganization = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_sub_organization",
        body: input.body,
        options
      });
      deleteUserTags = (input) => request({
        uri: "/public/v1/submit/delete_user_tags",
        method: "POST",
        body: input.body
      });
      signDeleteUserTags = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_user_tags",
        body: input.body,
        options
      });
      deleteUsers = (input) => request({
        uri: "/public/v1/submit/delete_users",
        method: "POST",
        body: input.body
      });
      signDeleteUsers = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_users",
        body: input.body,
        options
      });
      deleteWallets = (input) => request({
        uri: "/public/v1/submit/delete_wallets",
        method: "POST",
        body: input.body
      });
      signDeleteWallets = (input, options) => signedRequest({
        uri: "/public/v1/submit/delete_wallets",
        body: input.body,
        options
      });
      emailAuth = (input) => request({
        uri: "/public/v1/submit/email_auth",
        method: "POST",
        body: input.body
      });
      signEmailAuth = (input, options) => signedRequest({
        uri: "/public/v1/submit/email_auth",
        body: input.body,
        options
      });
      exportPrivateKey = (input) => request({
        uri: "/public/v1/submit/export_private_key",
        method: "POST",
        body: input.body
      });
      signExportPrivateKey = (input, options) => signedRequest({
        uri: "/public/v1/submit/export_private_key",
        body: input.body,
        options
      });
      exportWallet = (input) => request({
        uri: "/public/v1/submit/export_wallet",
        method: "POST",
        body: input.body
      });
      signExportWallet = (input, options) => signedRequest({
        uri: "/public/v1/submit/export_wallet",
        body: input.body,
        options
      });
      exportWalletAccount = (input) => request({
        uri: "/public/v1/submit/export_wallet_account",
        method: "POST",
        body: input.body
      });
      signExportWalletAccount = (input, options) => signedRequest({
        uri: "/public/v1/submit/export_wallet_account",
        body: input.body,
        options
      });
      importPrivateKey = (input) => request({
        uri: "/public/v1/submit/import_private_key",
        method: "POST",
        body: input.body
      });
      signImportPrivateKey = (input, options) => signedRequest({
        uri: "/public/v1/submit/import_private_key",
        body: input.body,
        options
      });
      importWallet = (input) => request({
        uri: "/public/v1/submit/import_wallet",
        method: "POST",
        body: input.body
      });
      signImportWallet = (input, options) => signedRequest({
        uri: "/public/v1/submit/import_wallet",
        body: input.body,
        options
      });
      initFiatOnRamp = (input) => request({
        uri: "/public/v1/submit/init_fiat_on_ramp",
        method: "POST",
        body: input.body
      });
      signInitFiatOnRamp = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_fiat_on_ramp",
        body: input.body,
        options
      });
      initImportPrivateKey = (input) => request({
        uri: "/public/v1/submit/init_import_private_key",
        method: "POST",
        body: input.body
      });
      signInitImportPrivateKey = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_import_private_key",
        body: input.body,
        options
      });
      initImportWallet = (input) => request({
        uri: "/public/v1/submit/init_import_wallet",
        method: "POST",
        body: input.body
      });
      signInitImportWallet = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_import_wallet",
        body: input.body,
        options
      });
      initOtp = (input) => request({
        uri: "/public/v1/submit/init_otp",
        method: "POST",
        body: input.body
      });
      signInitOtp = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_otp",
        body: input.body,
        options
      });
      initOtpAuth = (input) => request({
        uri: "/public/v1/submit/init_otp_auth",
        method: "POST",
        body: input.body
      });
      signInitOtpAuth = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_otp_auth",
        body: input.body,
        options
      });
      initUserEmailRecovery = (input) => request({
        uri: "/public/v1/submit/init_user_email_recovery",
        method: "POST",
        body: input.body
      });
      signInitUserEmailRecovery = (input, options) => signedRequest({
        uri: "/public/v1/submit/init_user_email_recovery",
        body: input.body,
        options
      });
      oauth = (input) => request({
        uri: "/public/v1/submit/oauth",
        method: "POST",
        body: input.body
      });
      signOauth = (input, options) => signedRequest({
        uri: "/public/v1/submit/oauth",
        body: input.body,
        options
      });
      oauthLogin = (input) => request({
        uri: "/public/v1/submit/oauth_login",
        method: "POST",
        body: input.body
      });
      signOauthLogin = (input, options) => signedRequest({
        uri: "/public/v1/submit/oauth_login",
        body: input.body,
        options
      });
      otpAuth = (input) => request({
        uri: "/public/v1/submit/otp_auth",
        method: "POST",
        body: input.body
      });
      signOtpAuth = (input, options) => signedRequest({
        uri: "/public/v1/submit/otp_auth",
        body: input.body,
        options
      });
      otpLogin = (input) => request({
        uri: "/public/v1/submit/otp_login",
        method: "POST",
        body: input.body
      });
      signOtpLogin = (input, options) => signedRequest({
        uri: "/public/v1/submit/otp_login",
        body: input.body,
        options
      });
      recoverUser = (input) => request({
        uri: "/public/v1/submit/recover_user",
        method: "POST",
        body: input.body
      });
      signRecoverUser = (input, options) => signedRequest({
        uri: "/public/v1/submit/recover_user",
        body: input.body,
        options
      });
      rejectActivity = (input) => request({
        uri: "/public/v1/submit/reject_activity",
        method: "POST",
        body: input.body
      });
      signRejectActivity = (input, options) => signedRequest({
        uri: "/public/v1/submit/reject_activity",
        body: input.body,
        options
      });
      removeOrganizationFeature = (input) => request({
        uri: "/public/v1/submit/remove_organization_feature",
        method: "POST",
        body: input.body
      });
      signRemoveOrganizationFeature = (input, options) => signedRequest({
        uri: "/public/v1/submit/remove_organization_feature",
        body: input.body,
        options
      });
      setOrganizationFeature = (input) => request({
        uri: "/public/v1/submit/set_organization_feature",
        method: "POST",
        body: input.body
      });
      signSetOrganizationFeature = (input, options) => signedRequest({
        uri: "/public/v1/submit/set_organization_feature",
        body: input.body,
        options
      });
      signRawPayload = (input) => request({
        uri: "/public/v1/submit/sign_raw_payload",
        method: "POST",
        body: input.body
      });
      signSignRawPayload = (input, options) => signedRequest({
        uri: "/public/v1/submit/sign_raw_payload",
        body: input.body,
        options
      });
      signRawPayloads = (input) => request({
        uri: "/public/v1/submit/sign_raw_payloads",
        method: "POST",
        body: input.body
      });
      signSignRawPayloads = (input, options) => signedRequest({
        uri: "/public/v1/submit/sign_raw_payloads",
        body: input.body,
        options
      });
      signTransaction = (input) => request({
        uri: "/public/v1/submit/sign_transaction",
        method: "POST",
        body: input.body
      });
      signSignTransaction = (input, options) => signedRequest({
        uri: "/public/v1/submit/sign_transaction",
        body: input.body,
        options
      });
      stampLogin = (input) => request({
        uri: "/public/v1/submit/stamp_login",
        method: "POST",
        body: input.body
      });
      signStampLogin = (input, options) => signedRequest({
        uri: "/public/v1/submit/stamp_login",
        body: input.body,
        options
      });
      updatePolicy = (input) => request({
        uri: "/public/v1/submit/update_policy",
        method: "POST",
        body: input.body
      });
      signUpdatePolicy = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_policy",
        body: input.body,
        options
      });
      updatePrivateKeyTag = (input) => request({
        uri: "/public/v1/submit/update_private_key_tag",
        method: "POST",
        body: input.body
      });
      signUpdatePrivateKeyTag = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_private_key_tag",
        body: input.body,
        options
      });
      updateRootQuorum = (input) => request({
        uri: "/public/v1/submit/update_root_quorum",
        method: "POST",
        body: input.body
      });
      signUpdateRootQuorum = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_root_quorum",
        body: input.body,
        options
      });
      updateUser = (input) => request({
        uri: "/public/v1/submit/update_user",
        method: "POST",
        body: input.body
      });
      signUpdateUser = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_user",
        body: input.body,
        options
      });
      updateUserEmail = (input) => request({
        uri: "/public/v1/submit/update_user_email",
        method: "POST",
        body: input.body
      });
      signUpdateUserEmail = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_user_email",
        body: input.body,
        options
      });
      updateUserName = (input) => request({
        uri: "/public/v1/submit/update_user_name",
        method: "POST",
        body: input.body
      });
      signUpdateUserName = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_user_name",
        body: input.body,
        options
      });
      updateUserPhoneNumber = (input) => request({
        uri: "/public/v1/submit/update_user_phone_number",
        method: "POST",
        body: input.body
      });
      signUpdateUserPhoneNumber = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_user_phone_number",
        body: input.body,
        options
      });
      updateUserTag = (input) => request({
        uri: "/public/v1/submit/update_user_tag",
        method: "POST",
        body: input.body
      });
      signUpdateUserTag = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_user_tag",
        body: input.body,
        options
      });
      updateWallet = (input) => request({
        uri: "/public/v1/submit/update_wallet",
        method: "POST",
        body: input.body
      });
      signUpdateWallet = (input, options) => signedRequest({
        uri: "/public/v1/submit/update_wallet",
        body: input.body,
        options
      });
      verifyOtp = (input) => request({
        uri: "/public/v1/submit/verify_otp",
        method: "POST",
        body: input.body
      });
      signVerifyOtp = (input, options) => signedRequest({
        uri: "/public/v1/submit/verify_otp",
        body: input.body,
        options
      });
      nOOPCodegenAnchor = () => request({
        uri: "/tkhq/api/v1/noop-codegen-anchor",
        method: "POST"
      });
      signNOOPCodegenAnchor = () => signedRequest({
        uri: "/tkhq/api/v1/noop-codegen-anchor"
      });
      testRateLimits = (input) => request({
        uri: "/tkhq/api/v1/test_rate_limits",
        method: "POST",
        body: input.body
      });
      signTestRateLimits = (input, options) => signedRequest({
        uri: "/tkhq/api/v1/test_rate_limits",
        body: input.body,
        options
      });
    }
  });

  // node_modules/@turnkey/http/dist/version.mjs
  var VERSION;
  var init_version = __esm({
    "node_modules/@turnkey/http/dist/version.mjs"() {
      VERSION = "@turnkey/http@3.5.1";
    }
  });

  // node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs
  var TurnkeyClient;
  var init_public_api_client = __esm({
    "node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs"() {
      init_base();
      init_version();
      init_universal();
      TurnkeyClient = class {
        constructor(config2, stamper) {
          this.name = "TurnkeyClient";
          this.getActivity = async (input) => {
            return this.request("/public/v1/query/get_activity", input);
          };
          this.stampGetActivity = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getApiKey = async (input) => {
            return this.request("/public/v1/query/get_api_key", input);
          };
          this.stampGetApiKey = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getApiKeys = async (input) => {
            return this.request("/public/v1/query/get_api_keys", input);
          };
          this.stampGetApiKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAttestationDocument = async (input) => {
            return this.request("/public/v1/query/get_attestation", input);
          };
          this.stampGetAttestationDocument = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_attestation";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAuthenticator = async (input) => {
            return this.request("/public/v1/query/get_authenticator", input);
          };
          this.stampGetAuthenticator = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticator";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAuthenticators = async (input) => {
            return this.request("/public/v1/query/get_authenticators", input);
          };
          this.stampGetAuthenticators = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOauthProviders = async (input) => {
            return this.request("/public/v1/query/get_oauth_providers", input);
          };
          this.stampGetOauthProviders = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOrganization = async (input) => {
            return this.request("/public/v1/query/get_organization", input);
          };
          this.stampGetOrganization = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOrganizationConfigs = async (input) => {
            return this.request("/public/v1/query/get_organization_configs", input);
          };
          this.stampGetOrganizationConfigs = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization_configs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPolicy = async (input) => {
            return this.request("/public/v1/query/get_policy", input);
          };
          this.stampGetPolicy = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPrivateKey = async (input) => {
            return this.request("/public/v1/query/get_private_key", input);
          };
          this.stampGetPrivateKey = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSmartContractInterface = async (input) => {
            return this.request("/public/v1/query/get_smart_contract_interface", input);
          };
          this.stampGetSmartContractInterface = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getUser = async (input) => {
            return this.request("/public/v1/query/get_user", input);
          };
          this.stampGetUser = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWallet = async (input) => {
            return this.request("/public/v1/query/get_wallet", input);
          };
          this.stampGetWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWalletAccount = async (input) => {
            return this.request("/public/v1/query/get_wallet_account", input);
          };
          this.stampGetWalletAccount = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet_account";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getActivities = async (input) => {
            return this.request("/public/v1/query/list_activities", input);
          };
          this.stampGetActivities = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_activities";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPolicies = async (input) => {
            return this.request("/public/v1/query/list_policies", input);
          };
          this.stampGetPolicies = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_policies";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.listPrivateKeyTags = async (input) => {
            return this.request("/public/v1/query/list_private_key_tags", input);
          };
          this.stampListPrivateKeyTags = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_key_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPrivateKeys = async (input) => {
            return this.request("/public/v1/query/list_private_keys", input);
          };
          this.stampGetPrivateKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSmartContractInterfaces = async (input) => {
            return this.request("/public/v1/query/list_smart_contract_interfaces", input);
          };
          this.stampGetSmartContractInterfaces = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_smart_contract_interfaces";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSubOrgIds = async (input) => {
            return this.request("/public/v1/query/list_suborgs", input);
          };
          this.stampGetSubOrgIds = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_suborgs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.listUserTags = async (input) => {
            return this.request("/public/v1/query/list_user_tags", input);
          };
          this.stampListUserTags = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_user_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getUsers = async (input) => {
            return this.request("/public/v1/query/list_users", input);
          };
          this.stampGetUsers = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getVerifiedSubOrgIds = async (input) => {
            return this.request("/public/v1/query/list_verified_suborgs", input);
          };
          this.stampGetVerifiedSubOrgIds = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_verified_suborgs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWalletAccounts = async (input) => {
            return this.request("/public/v1/query/list_wallet_accounts", input);
          };
          this.stampGetWalletAccounts = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallet_accounts";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWallets = async (input) => {
            return this.request("/public/v1/query/list_wallets", input);
          };
          this.stampGetWallets = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallets";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWhoami = async (input) => {
            return this.request("/public/v1/query/whoami", input);
          };
          this.stampGetWhoami = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/query/whoami";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.approveActivity = async (input) => {
            return this.request("/public/v1/submit/approve_activity", input);
          };
          this.stampApproveActivity = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/approve_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createApiKeys = async (input) => {
            return this.request("/public/v1/submit/create_api_keys", input);
          };
          this.stampCreateApiKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createApiOnlyUsers = async (input) => {
            return this.request("/public/v1/submit/create_api_only_users", input);
          };
          this.stampCreateApiOnlyUsers = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_only_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createAuthenticators = async (input) => {
            return this.request("/public/v1/submit/create_authenticators", input);
          };
          this.stampCreateAuthenticators = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createInvitations = async (input) => {
            return this.request("/public/v1/submit/create_invitations", input);
          };
          this.stampCreateInvitations = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_invitations";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createOauthProviders = async (input) => {
            return this.request("/public/v1/submit/create_oauth_providers", input);
          };
          this.stampCreateOauthProviders = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPolicies = async (input) => {
            return this.request("/public/v1/submit/create_policies", input);
          };
          this.stampCreatePolicies = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policies";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPolicy = async (input) => {
            return this.request("/public/v1/submit/create_policy", input);
          };
          this.stampCreatePolicy = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPrivateKeyTag = async (input) => {
            return this.request("/public/v1/submit/create_private_key_tag", input);
          };
          this.stampCreatePrivateKeyTag = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_key_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPrivateKeys = async (input) => {
            return this.request("/public/v1/submit/create_private_keys", input);
          };
          this.stampCreatePrivateKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createReadOnlySession = async (input) => {
            return this.request("/public/v1/submit/create_read_only_session", input);
          };
          this.stampCreateReadOnlySession = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_only_session";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createReadWriteSession = async (input) => {
            return this.request("/public/v1/submit/create_read_write_session", input);
          };
          this.stampCreateReadWriteSession = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_write_session";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createSmartContractInterface = async (input) => {
            return this.request("/public/v1/submit/create_smart_contract_interface", input);
          };
          this.stampCreateSmartContractInterface = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createSubOrganization = async (input) => {
            return this.request("/public/v1/submit/create_sub_organization", input);
          };
          this.stampCreateSubOrganization = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_sub_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createUserTag = async (input) => {
            return this.request("/public/v1/submit/create_user_tag", input);
          };
          this.stampCreateUserTag = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_user_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createUsers = async (input) => {
            return this.request("/public/v1/submit/create_users", input);
          };
          this.stampCreateUsers = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createWallet = async (input) => {
            return this.request("/public/v1/submit/create_wallet", input);
          };
          this.stampCreateWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createWalletAccounts = async (input) => {
            return this.request("/public/v1/submit/create_wallet_accounts", input);
          };
          this.stampCreateWalletAccounts = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet_accounts";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteApiKeys = async (input) => {
            return this.request("/public/v1/submit/delete_api_keys", input);
          };
          this.stampDeleteApiKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteAuthenticators = async (input) => {
            return this.request("/public/v1/submit/delete_authenticators", input);
          };
          this.stampDeleteAuthenticators = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteInvitation = async (input) => {
            return this.request("/public/v1/submit/delete_invitation", input);
          };
          this.stampDeleteInvitation = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_invitation";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteOauthProviders = async (input) => {
            return this.request("/public/v1/submit/delete_oauth_providers", input);
          };
          this.stampDeleteOauthProviders = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePolicy = async (input) => {
            return this.request("/public/v1/submit/delete_policy", input);
          };
          this.stampDeletePolicy = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePrivateKeyTags = async (input) => {
            return this.request("/public/v1/submit/delete_private_key_tags", input);
          };
          this.stampDeletePrivateKeyTags = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_key_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePrivateKeys = async (input) => {
            return this.request("/public/v1/submit/delete_private_keys", input);
          };
          this.stampDeletePrivateKeys = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteSmartContractInterface = async (input) => {
            return this.request("/public/v1/submit/delete_smart_contract_interface", input);
          };
          this.stampDeleteSmartContractInterface = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteSubOrganization = async (input) => {
            return this.request("/public/v1/submit/delete_sub_organization", input);
          };
          this.stampDeleteSubOrganization = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_sub_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteUserTags = async (input) => {
            return this.request("/public/v1/submit/delete_user_tags", input);
          };
          this.stampDeleteUserTags = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_user_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteUsers = async (input) => {
            return this.request("/public/v1/submit/delete_users", input);
          };
          this.stampDeleteUsers = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteWallets = async (input) => {
            return this.request("/public/v1/submit/delete_wallets", input);
          };
          this.stampDeleteWallets = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_wallets";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.emailAuth = async (input) => {
            return this.request("/public/v1/submit/email_auth", input);
          };
          this.stampEmailAuth = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/email_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportPrivateKey = async (input) => {
            return this.request("/public/v1/submit/export_private_key", input);
          };
          this.stampExportPrivateKey = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/export_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportWallet = async (input) => {
            return this.request("/public/v1/submit/export_wallet", input);
          };
          this.stampExportWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportWalletAccount = async (input) => {
            return this.request("/public/v1/submit/export_wallet_account", input);
          };
          this.stampExportWalletAccount = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet_account";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.importPrivateKey = async (input) => {
            return this.request("/public/v1/submit/import_private_key", input);
          };
          this.stampImportPrivateKey = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/import_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.importWallet = async (input) => {
            return this.request("/public/v1/submit/import_wallet", input);
          };
          this.stampImportWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/import_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initFiatOnRamp = async (input) => {
            return this.request("/public/v1/submit/init_fiat_on_ramp", input);
          };
          this.stampInitFiatOnRamp = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_fiat_on_ramp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initImportPrivateKey = async (input) => {
            return this.request("/public/v1/submit/init_import_private_key", input);
          };
          this.stampInitImportPrivateKey = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initImportWallet = async (input) => {
            return this.request("/public/v1/submit/init_import_wallet", input);
          };
          this.stampInitImportWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initOtp = async (input) => {
            return this.request("/public/v1/submit/init_otp", input);
          };
          this.stampInitOtp = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initOtpAuth = async (input) => {
            return this.request("/public/v1/submit/init_otp_auth", input);
          };
          this.stampInitOtpAuth = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initUserEmailRecovery = async (input) => {
            return this.request("/public/v1/submit/init_user_email_recovery", input);
          };
          this.stampInitUserEmailRecovery = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/init_user_email_recovery";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.oauth = async (input) => {
            return this.request("/public/v1/submit/oauth", input);
          };
          this.stampOauth = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.oauthLogin = async (input) => {
            return this.request("/public/v1/submit/oauth_login", input);
          };
          this.stampOauthLogin = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.otpAuth = async (input) => {
            return this.request("/public/v1/submit/otp_auth", input);
          };
          this.stampOtpAuth = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.otpLogin = async (input) => {
            return this.request("/public/v1/submit/otp_login", input);
          };
          this.stampOtpLogin = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.recoverUser = async (input) => {
            return this.request("/public/v1/submit/recover_user", input);
          };
          this.stampRecoverUser = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/recover_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.rejectActivity = async (input) => {
            return this.request("/public/v1/submit/reject_activity", input);
          };
          this.stampRejectActivity = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/reject_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.removeOrganizationFeature = async (input) => {
            return this.request("/public/v1/submit/remove_organization_feature", input);
          };
          this.stampRemoveOrganizationFeature = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/remove_organization_feature";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.setOrganizationFeature = async (input) => {
            return this.request("/public/v1/submit/set_organization_feature", input);
          };
          this.stampSetOrganizationFeature = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/set_organization_feature";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signRawPayload = async (input) => {
            return this.request("/public/v1/submit/sign_raw_payload", input);
          };
          this.stampSignRawPayload = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payload";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signRawPayloads = async (input) => {
            return this.request("/public/v1/submit/sign_raw_payloads", input);
          };
          this.stampSignRawPayloads = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payloads";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signTransaction = async (input) => {
            return this.request("/public/v1/submit/sign_transaction", input);
          };
          this.stampSignTransaction = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_transaction";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.stampLogin = async (input) => {
            return this.request("/public/v1/submit/stamp_login", input);
          };
          this.stampStampLogin = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/stamp_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updatePolicy = async (input) => {
            return this.request("/public/v1/submit/update_policy", input);
          };
          this.stampUpdatePolicy = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updatePrivateKeyTag = async (input) => {
            return this.request("/public/v1/submit/update_private_key_tag", input);
          };
          this.stampUpdatePrivateKeyTag = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_private_key_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateRootQuorum = async (input) => {
            return this.request("/public/v1/submit/update_root_quorum", input);
          };
          this.stampUpdateRootQuorum = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_root_quorum";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUser = async (input) => {
            return this.request("/public/v1/submit/update_user", input);
          };
          this.stampUpdateUser = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserEmail = async (input) => {
            return this.request("/public/v1/submit/update_user_email", input);
          };
          this.stampUpdateUserEmail = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_email";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserName = async (input) => {
            return this.request("/public/v1/submit/update_user_name", input);
          };
          this.stampUpdateUserName = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_name";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserPhoneNumber = async (input) => {
            return this.request("/public/v1/submit/update_user_phone_number", input);
          };
          this.stampUpdateUserPhoneNumber = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_phone_number";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserTag = async (input) => {
            return this.request("/public/v1/submit/update_user_tag", input);
          };
          this.stampUpdateUserTag = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateWallet = async (input) => {
            return this.request("/public/v1/submit/update_wallet", input);
          };
          this.stampUpdateWallet = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/update_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.verifyOtp = async (input) => {
            return this.request("/public/v1/submit/verify_otp", input);
          };
          this.stampVerifyOtp = async (input) => {
            const fullUrl = this.config.baseUrl + "/public/v1/submit/verify_otp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.testRateLimits = async (input) => {
            return this.request("/tkhq/api/v1/test_rate_limits", input);
          };
          this.stampTestRateLimits = async (input) => {
            const fullUrl = this.config.baseUrl + "/tkhq/api/v1/test_rate_limits";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          if (!config2.baseUrl) {
            throw new Error(`Missing base URL. Please verify env vars.`);
          }
          this.config = config2;
          this.stamper = stamper;
        }
        async request(url, body) {
          const fullUrl = this.config.baseUrl + url;
          const stringifiedBody = JSON.stringify(body);
          const stamp = await this.stamper.stamp(stringifiedBody);
          const response = await fetch2(fullUrl, {
            method: "POST",
            headers: {
              [stamp.stampHeaderName]: stamp.stampHeaderValue,
              "X-Client-Version": VERSION
            },
            body: stringifiedBody,
            redirect: "follow"
          });
          if (!response.ok) {
            let res;
            try {
              res = await response.json();
            } catch (_) {
              throw new Error(`${response.status} ${response.statusText}`);
            }
            throw new TurnkeyRequestError(res);
          }
          const data = await response.json();
          return data;
        }
      };
    }
  });

  // node_modules/@turnkey/http/dist/shared.mjs
  function assertActivityCompleted(activity) {
    const { id: activityId, status: activityStatus } = activity;
    if (activityStatus === "ACTIVITY_STATUS_CONSENSUS_NEEDED") {
      throw new TurnkeyActivityConsensusNeededError({
        message: "Activity requires consensus",
        activityId,
        activityStatus
      });
    }
    if (activityStatus !== "ACTIVITY_STATUS_COMPLETED") {
      throw new TurnkeyActivityError({
        message: `Expected COMPLETED status, got ${activityStatus}`,
        activityId,
        activityStatus
      });
    }
    return true;
  }
  function assertNonNull(input) {
    if (input == null) {
      throw new Error(`Got unexpected ${JSON.stringify(input)}`);
    }
    return input;
  }
  function getSignatureFromActivity(activity) {
    if (![
      "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD",
      "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    ].includes(activity.type)) {
      throw new InvalidArgumentError({
        message: `Cannot get signature from activity type: ${activity.type}`,
        activityId: activity.id,
        activityStatus: activity.status
      });
    }
    assertActivityCompleted(activity);
    const signature = activity.result?.signRawPayloadResult;
    return assertNonNull(signature);
  }
  function getSignaturesFromActivity(activity) {
    if (!["ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"].includes(activity.type)) {
      throw new InvalidArgumentError({
        message: `Cannot get signature from activity type: ${activity.type}`,
        activityId: activity.id,
        activityStatus: activity.status
      });
    }
    assertActivityCompleted(activity);
    const { signatures } = activity.result?.signRawPayloadsResult;
    return assertNonNull(signatures);
  }
  function getSignedTransactionFromActivity(activity) {
    if (![
      "ACTIVITY_TYPE_SIGN_TRANSACTION",
      "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    ].includes(activity.type)) {
      throw new InvalidArgumentError({
        message: `Cannot get signed transaction from activity type: ${activity.type}`,
        activityId: activity.id,
        activityStatus: activity.status
      });
    }
    assertActivityCompleted(activity);
    const { signedTransaction } = activity.result?.signTransactionResult;
    return assertNonNull(`0x${signedTransaction}`);
  }
  var TurnkeyActivityError, TurnkeyActivityConsensusNeededError, InvalidArgumentError, TERMINAL_ACTIVITY_STATUSES;
  var init_shared = __esm({
    "node_modules/@turnkey/http/dist/shared.mjs"() {
      TurnkeyActivityError = class extends Error {
        constructor(input) {
          const { message, cause, activityId, activityStatus, activityType } = input;
          super(message);
          this.name = "TurnkeyActivityError";
          this.activityId = activityId ?? void 0;
          this.activityStatus = activityStatus ?? void 0;
          this.activityType = activityType ?? void 0;
          this.cause = cause ?? void 0;
        }
      };
      TurnkeyActivityConsensusNeededError = class extends Error {
        constructor(input) {
          const { message, cause, activityId, activityStatus, activityType } = input;
          super(message);
          this.name = "TurnkeyActivityConsensusNeededError";
          this.activityId = activityId ?? void 0;
          this.activityStatus = activityStatus ?? void 0;
          this.activityType = activityType ?? void 0;
          this.cause = cause ?? void 0;
        }
      };
      InvalidArgumentError = class extends Error {
        constructor(input) {
          const { message, cause, activityId, activityStatus, activityType } = input;
          super(message);
          this.name = "InvalidArgumentError";
          this.activityId = activityId ?? void 0;
          this.activityStatus = activityStatus ?? void 0;
          this.activityType = activityType ?? void 0;
          this.cause = cause ?? void 0;
        }
      };
      TERMINAL_ACTIVITY_STATUSES = [
        "ACTIVITY_STATUS_COMPLETED",
        "ACTIVITY_STATUS_FAILED",
        "ACTIVITY_STATUS_REJECTED"
      ];
    }
  });

  // node_modules/@turnkey/http/dist/async.mjs
  function withAsyncPolling(params) {
    const { request: request2, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS } = params;
    return async (input) => {
      const initialResponse = await request2(input);
      let activity = initialResponse.activity;
      while (true) {
        switch (activity.status) {
          case "ACTIVITY_STATUS_COMPLETED": {
            return activity;
          }
          case "ACTIVITY_STATUS_CREATED": {
            break;
          }
          case "ACTIVITY_STATUS_PENDING": {
            break;
          }
          case "ACTIVITY_STATUS_CONSENSUS_NEEDED": {
            throw new TurnkeyActivityError({
              message: `Consensus needed for activity ${activity.id}`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          case "ACTIVITY_STATUS_FAILED": {
            throw new TurnkeyActivityError({
              message: `Activity ${activity.id} failed`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          case "ACTIVITY_STATUS_REJECTED": {
            throw new TurnkeyActivityError({
              message: `Activity ${activity.id} was rejected`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          default: {
            assertNever(activity.status);
          }
        }
        await sleep(refreshIntervalMs);
        const pollingResponse = await getActivity({
          body: {
            activityId: activity.id,
            organizationId: activity.organizationId
          }
        });
        activity = pollingResponse.activity;
      }
    };
  }
  function createActivityPoller(params) {
    const { client, requestFn, refreshIntervalMs = DEFAULT_REFRESH_INTERVAL_MS } = params;
    return async (input) => {
      const initialResponse = await requestFn(input);
      let activity = initialResponse.activity;
      while (true) {
        switch (activity.status) {
          case "ACTIVITY_STATUS_COMPLETED": {
            return activity;
          }
          case "ACTIVITY_STATUS_CREATED": {
            break;
          }
          case "ACTIVITY_STATUS_PENDING": {
            break;
          }
          case "ACTIVITY_STATUS_CONSENSUS_NEEDED": {
            throw new TurnkeyActivityError({
              message: `Consensus needed for activity ${activity.id}`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          case "ACTIVITY_STATUS_FAILED": {
            throw new TurnkeyActivityError({
              message: `Activity ${activity.id} failed`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          case "ACTIVITY_STATUS_REJECTED": {
            throw new TurnkeyActivityError({
              message: `Activity ${activity.id} was rejected`,
              activityId: activity.id,
              activityStatus: activity.status,
              activityType: activity.type
            });
          }
          default: {
            assertNever(activity.status);
          }
        }
        await sleep(refreshIntervalMs);
        const pollingResponse = await client.getActivity({
          activityId: activity.id,
          organizationId: activity.organizationId
        });
        activity = pollingResponse.activity;
      }
    };
  }
  function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
  }
  function assertNever(input, message) {
    throw new Error(`Unexpected case: ${JSON.stringify(input)}`);
  }
  var DEFAULT_REFRESH_INTERVAL_MS;
  var init_async = __esm({
    "node_modules/@turnkey/http/dist/async.mjs"() {
      init_public_api_fetcher();
      init_shared();
      DEFAULT_REFRESH_INTERVAL_MS = 500;
    }
  });

  // node_modules/@turnkey/http/dist/index.mjs
  var dist_exports = {};
  __export(dist_exports, {
    InvalidArgumentError: () => InvalidArgumentError,
    TERMINAL_ACTIVITY_STATUSES: () => TERMINAL_ACTIVITY_STATUSES,
    TurnkeyActivityConsensusNeededError: () => TurnkeyActivityConsensusNeededError,
    TurnkeyActivityError: () => TurnkeyActivityError,
    TurnkeyApi: () => public_api_fetcher_exports,
    TurnkeyClient: () => TurnkeyClient,
    TurnkeyRequestError: () => TurnkeyRequestError,
    VERSION: () => VERSION,
    assertActivityCompleted: () => assertActivityCompleted,
    assertNonNull: () => assertNonNull,
    browserInit: () => browserInit,
    createActivityPoller: () => createActivityPoller,
    getSignatureFromActivity: () => getSignatureFromActivity,
    getSignaturesFromActivity: () => getSignaturesFromActivity,
    getSignedTransactionFromActivity: () => getSignedTransactionFromActivity,
    getWebAuthnAttestation: () => getWebAuthnAttestation,
    init: () => init,
    isHttpClient: () => isHttpClient,
    sealAndStampRequestBody: () => sealAndStampRequestBody,
    withAsyncPolling: () => withAsyncPolling
  });
  var init_dist3 = __esm({
    "node_modules/@turnkey/http/dist/index.mjs"() {
      init_public_api_fetcher();
      init_public_api_client();
      init_config();
      init_base();
      init_shared();
      init_webauthn();
      init_async();
      init_version();
    }
  });

  // node_modules/@turnkey/iframe-stamper/dist/index.mjs
  var dist_exports2 = {};
  __export(dist_exports2, {
    IframeEventType: () => IframeEventType,
    IframeStamper: () => IframeStamper,
    KeyFormat: () => KeyFormat
  });
  function generateUUID() {
    return crypto.randomUUID();
  }
  var stampHeaderName2, IframeEventType, KeyFormat, IframeStamper;
  var init_dist4 = __esm({
    "node_modules/@turnkey/iframe-stamper/dist/index.mjs"() {
      stampHeaderName2 = "X-Stamp";
      (function(IframeEventType2) {
        IframeEventType2["PublicKeyReady"] = "PUBLIC_KEY_READY";
        IframeEventType2["InjectCredentialBundle"] = "INJECT_CREDENTIAL_BUNDLE";
        IframeEventType2["InjectKeyExportBundle"] = "INJECT_KEY_EXPORT_BUNDLE";
        IframeEventType2["InjectWalletExportBundle"] = "INJECT_WALLET_EXPORT_BUNDLE";
        IframeEventType2["InjectImportBundle"] = "INJECT_IMPORT_BUNDLE";
        IframeEventType2["ExtractWalletEncryptedBundle"] = "EXTRACT_WALLET_ENCRYPTED_BUNDLE";
        IframeEventType2["ExtractKeyEncryptedBundle"] = "EXTRACT_KEY_ENCRYPTED_BUNDLE";
        IframeEventType2["ApplySettings"] = "APPLY_SETTINGS";
        IframeEventType2["BundleInjected"] = "BUNDLE_INJECTED";
        IframeEventType2["EncryptedBundleExtracted"] = "ENCRYPTED_BUNDLE_EXTRACTED";
        IframeEventType2["SettingsApplied"] = "SETTINGS_APPLIED";
        IframeEventType2["StampRequest"] = "STAMP_REQUEST";
        IframeEventType2["Stamp"] = "STAMP";
        IframeEventType2["TurnkeyInitMessageChannel"] = "TURNKEY_INIT_MESSAGE_CHANNEL";
        IframeEventType2["GetEmbeddedPublicKey"] = "GET_EMBEDDED_PUBLIC_KEY";
        IframeEventType2["ClearEmbeddedKey"] = "RESET_EMBEDDED_KEY";
        IframeEventType2["InitEmbeddedKey"] = "INIT_EMBEDDED_KEY";
        IframeEventType2["Error"] = "ERROR";
      })(IframeEventType || (IframeEventType = {}));
      (function(KeyFormat2) {
        KeyFormat2["Hexadecimal"] = "HEXADECIMAL";
        KeyFormat2["Solana"] = "SOLANA";
      })(KeyFormat || (KeyFormat = {}));
      IframeStamper = class {
        /**
         * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.
         * Call `.init()` to insert the iframe element in the DOM.
         */
        constructor(config2) {
          if (typeof window === "undefined") {
            throw new Error("Cannot initialize iframe in non-browser environment");
          }
          if (typeof MessageChannel === "undefined") {
            throw new Error("Cannot initialize iframe without MessageChannel support");
          }
          if (!config2.iframeContainer) {
            throw new Error("Iframe container cannot be found");
          }
          this.container = config2.iframeContainer;
          if (this.container.querySelector(`#${config2.iframeElementId}`)) {
            throw new Error(`Iframe element with ID ${config2.iframeElementId} already exists`);
          }
          let iframe = window.document.createElement("iframe");
          iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
          iframe.id = config2.iframeElementId;
          iframe.src = config2.iframeUrl;
          this.iframe = iframe;
          const iframeUrl = new URL(config2.iframeUrl);
          this.iframeOrigin = iframeUrl.origin;
          this.iframePublicKey = null;
          this.messageChannel = new MessageChannel();
          this.pendingRequests = /* @__PURE__ */ new Map();
        }
        onMessageHandler(event) {
          const { type, value, requestId } = event.data || {};
          if (!requestId) {
            if (type === IframeEventType.PublicKeyReady) {
              this.iframePublicKey = value;
              return;
            }
            return;
          }
          const pendingRequest = this.pendingRequests.get(requestId);
          if (!pendingRequest) {
            console.warn(`Received response for unknown request: ${requestId}`);
            return;
          }
          this.pendingRequests.delete(requestId);
          if (type === IframeEventType.Error) {
            pendingRequest.reject(new Error(value));
            return;
          }
          switch (type) {
            case IframeEventType.Stamp:
              pendingRequest.resolve({
                stampHeaderName: stampHeaderName2,
                stampHeaderValue: value
              });
              break;
            default:
              pendingRequest.resolve(value);
          }
        }
        /**
         * Inserts the iframe on the page and returns a promise resolving to the iframe's public key
         * @param dangerouslyOverrideIframeKeyTtl Optional TTL override for the iframe's embedded key (default 48 hours). Only use this if you are intentional about the security implications.
         */
        async init(dangerouslyOverrideIframeKeyTtl) {
          return new Promise((resolve, reject) => {
            this.container.appendChild(this.iframe);
            this.iframe.addEventListener("load", () => {
              if (!this.iframe.contentWindow?.postMessage) {
                reject(new Error("contentWindow or contentWindow.postMessage does not exist"));
                return;
              }
              this.iframe.contentWindow.postMessage({
                type: IframeEventType.TurnkeyInitMessageChannel,
                dangerouslyOverrideIframeKeyTtl
              }, this.iframeOrigin, [this.messageChannel.port2]);
            });
            this.messageChannel.port1.onmessage = (event) => {
              if (event.data?.type === IframeEventType.PublicKeyReady) {
                this.iframePublicKey = event.data.value;
                resolve(event.data.value);
              }
              this.onMessageHandler(event);
            };
          });
        }
        /**
         * Removes the iframe from the DOM
         */
        clear() {
          this.messageChannel?.port1?.close();
          this.messageChannel?.port2?.close();
          this.iframe.remove();
          this.pendingRequests.clear();
        }
        /**
         * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
         */
        publicKey() {
          return this.iframePublicKey;
        }
        /**
         * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
         * This differs from the above in that it reaches out to the live iframe to see if an embedded key exists.
         */
        async getEmbeddedPublicKey() {
          const publicKey = await this.createRequest(IframeEventType.GetEmbeddedPublicKey);
          this.iframePublicKey = publicKey;
          return publicKey;
        }
        /**
         * Clears the embedded key within an iframe.
         */
        async clearEmbeddedKey() {
          await this.createRequest(IframeEventType.ClearEmbeddedKey);
          this.iframePublicKey = "";
          return null;
        }
        /**
         * Creates a new embedded key within an iframe. If an embedded key already exists, this will return it.
         * This is primarily to be used in conjunction with `clearEmbeddedKey()`: after an embedded key is cleared,
         * this can be used to create a new one.
         * @return {string | null} the newly created embedded public key.
         */
        async initEmbeddedKey() {
          const publicKey = await this.createRequest(IframeEventType.InitEmbeddedKey);
          this.iframePublicKey = publicKey;
          return publicKey;
        }
        /**
         * Generic function to abstract away request creation
         * @param type
         * @param payload
         * @returns expected shape <T>
         */
        createRequest(type, payload = {}) {
          return new Promise((resolve, reject) => {
            const requestId = generateUUID();
            this.pendingRequests.set(requestId, {
              resolve,
              reject,
              requestId
            });
            this.messageChannel.port1.postMessage({
              type,
              requestId,
              ...payload
            });
          });
        }
        /**
         * Function to inject a new credential into the iframe
         * The bundle should be encrypted to the iframe's initial public key
         * Encryption should be performed with HPKE (RFC 9180).
         * This is used during recovery and auth flows.
         */
        async injectCredentialBundle(bundle) {
          return this.createRequest(IframeEventType.InjectCredentialBundle, {
            value: bundle
          });
        }
        /**
         * Function to inject an export bundle into the iframe
         * The bundle should be encrypted to the iframe's initial public key
         * Encryption should be performed with HPKE (RFC 9180).
         * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
         * This is used during the private key export flow.
         */
        async injectKeyExportBundle(bundle, organizationId, keyFormat) {
          return this.createRequest(IframeEventType.InjectKeyExportBundle, {
            value: bundle,
            keyFormat,
            organizationId
          });
        }
        /**
         * Function to inject an export bundle into the iframe
         * The bundle should be encrypted to the iframe's initial public key
         * Encryption should be performed with HPKE (RFC 9180).
         * This is used during the wallet export flow.
         */
        async injectWalletExportBundle(bundle, organizationId) {
          return this.createRequest(IframeEventType.InjectWalletExportBundle, {
            value: bundle,
            organizationId
          });
        }
        /**
         * Function to inject an import bundle into the iframe
         * This is used to initiate either the wallet import flow or the private key import flow.
         */
        async injectImportBundle(bundle, organizationId, userId) {
          return this.createRequest(IframeEventType.InjectImportBundle, {
            value: bundle,
            organizationId,
            userId
          });
        }
        /**
         * Function to extract an encrypted bundle from the iframe
         * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
         * Encryption should be performed with HPKE (RFC 9180).
         * This is used during the wallet import flow.
         */
        async extractWalletEncryptedBundle() {
          return this.createRequest(IframeEventType.ExtractWalletEncryptedBundle);
        }
        /**
         * Function to extract an encrypted bundle from the iframe
         * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
         * Encryption should be performed with HPKE (RFC 9180).
         * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
         * This is used during the private key import flow.
         */
        async extractKeyEncryptedBundle(keyFormat) {
          return this.createRequest(IframeEventType.ExtractKeyEncryptedBundle, { keyFormat });
        }
        /**
         * Function to apply settings on allowed parameters in the iframe
         * This is used to style the HTML element used for plaintext in wallet and private key import.
         */
        async applySettings(settings) {
          return this.createRequest(IframeEventType.ApplySettings, {
            value: JSON.stringify(settings)
          });
        }
        /**
         * Function to sign a payload with the underlying iframe
         */
        async stamp(payload) {
          if (this.iframePublicKey === null) {
            throw new Error("null iframe public key. Have you called/awaited .init()?");
          }
          return this.createRequest(IframeEventType.StampRequest, {
            value: payload
          });
        }
      };
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs
  function bufferToBase64url2(buffer2) {
    const byteView = new Uint8Array(buffer2);
    let str = "";
    for (const charCode of byteView) {
      str += String.fromCharCode(charCode);
    }
    const base64String = btoa(str);
    const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return base64urlString;
  }
  var init_base64url2 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs"() {
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs
  function convert2(conversionFn, schema, input) {
    if (schema === copyValue2) {
      return input;
    }
    if (schema === convertValue2) {
      return conversionFn(input);
    }
    if (schema instanceof Array) {
      return input.map((v) => convert2(conversionFn, schema[0], v));
    }
    if (schema instanceof Object) {
      const output = {};
      for (const [key, schemaField] of Object.entries(schema)) {
        if (schemaField.derive) {
          const v = schemaField.derive(input);
          if (v !== void 0) {
            input[key] = v;
          }
        }
        if (!(key in input)) {
          if (schemaField.required) {
            throw new Error(`Missing key: ${key}`);
          }
          continue;
        }
        if (input[key] == null) {
          output[key] = null;
          continue;
        }
        output[key] = convert2(conversionFn, schemaField.schema, input[key]);
      }
      return output;
    }
  }
  function derived2(schema, derive) {
    return {
      required: true,
      schema,
      derive
    };
  }
  function required2(schema) {
    return {
      required: true,
      schema
    };
  }
  function optional2(schema) {
    return {
      required: false,
      schema
    };
  }
  var copyValue2, convertValue2;
  var init_convert2 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs"() {
      copyValue2 = "copy";
      convertValue2 = "convert";
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs
  var simplifiedClientExtensionResultsSchema2, publicKeyCredentialWithAssertion2;
  var init_schema2 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs"() {
      init_convert2();
      simplifiedClientExtensionResultsSchema2 = {
        appid: optional2(copyValue2),
        appidExclude: optional2(copyValue2),
        credProps: optional2(copyValue2)
      };
      publicKeyCredentialWithAssertion2 = {
        type: required2(copyValue2),
        id: required2(copyValue2),
        rawId: required2(convertValue2),
        authenticatorAttachment: optional2(copyValue2),
        response: required2({
          clientDataJSON: required2(convertValue2),
          authenticatorData: required2(convertValue2),
          signature: required2(convertValue2),
          userHandle: required2(convertValue2)
        }),
        clientExtensionResults: derived2(simplifiedClientExtensionResultsSchema2, (pkc) => pkc.getClientExtensionResults())
      };
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs
  function getResponseToJSON2(credential) {
    return convert2(bufferToBase64url2, publicKeyCredentialWithAssertion2, credential);
  }
  var init_api2 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs"() {
      init_base64url2();
      init_convert2();
      init_schema2();
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs
  async function get2(options) {
    const response = await navigator.credentials.get(options);
    response.toJSON = () => getResponseToJSON2(response);
    return response;
  }
  var init_webauthn_json2 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs"() {
      init_api2();
    }
  });

  // node_modules/@turnkey/webauthn-stamper/dist/index.mjs
  function getChallengeFromPayload2(payload) {
    const hexString = createHash().update(payload).digest("hex");
    return new TextEncoder().encode(hexString);
  }
  var stampHeaderName3, defaultTimeout2, defaultUserVerification2, WebauthnStamper;
  var init_dist5 = __esm({
    "node_modules/@turnkey/webauthn-stamper/dist/index.mjs"() {
      init_webauthn_json2();
      init_sha256_uint8array();
      stampHeaderName3 = "X-Stamp-Webauthn";
      defaultTimeout2 = 5 * 60 * 1e3;
      defaultUserVerification2 = "preferred";
      WebauthnStamper = class {
        constructor(config2) {
          this.rpId = config2.rpId;
          this.timeout = config2.timeout || defaultTimeout2;
          this.userVerification = config2.userVerification || defaultUserVerification2;
          this.allowCredentials = config2.allowCredentials || [];
        }
        async stamp(payload) {
          const challenge2 = getChallengeFromPayload2(payload);
          const signingOptions = {
            publicKey: {
              rpId: this.rpId,
              challenge: challenge2,
              allowCredentials: this.allowCredentials,
              timeout: this.timeout,
              userVerification: this.userVerification
            }
          };
          const clientGetResult = await get2(signingOptions);
          const assertion = clientGetResult.toJSON();
          const stamp = {
            authenticatorData: assertion.response.authenticatorData,
            clientDataJson: assertion.response.clientDataJSON,
            credentialId: assertion.id,
            signature: assertion.response.signature
          };
          return {
            stampHeaderName: stampHeaderName3,
            stampHeaderValue: JSON.stringify(stamp)
          };
        }
      };
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/constants.mjs
  var SIGNATURE_SCHEME_TK_API_SECP256K1_EIP191, SIGNATURE_SCHEME_TK_API_ED25519, STAMP_HEADER_NAME;
  var init_constants = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/constants.mjs"() {
      SIGNATURE_SCHEME_TK_API_SECP256K1_EIP191 = "SIGNATURE_SCHEME_TK_API_SECP256K1_EIP191";
      SIGNATURE_SCHEME_TK_API_ED25519 = "SIGNATURE_SCHEME_TK_API_ED25519";
      STAMP_HEADER_NAME = "X-Stamp";
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/errors.mjs
  var WalletStamperError;
  var init_errors = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/errors.mjs"() {
      WalletStamperError = class extends Error {
        constructor(message, originalError = null) {
          super(`${message}${originalError ? ` - error: ${originalError.message}` : ""}`);
          this.originalError = originalError;
          this.name = "WalletStamperError";
        }
      };
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/types.mjs
  var WalletType;
  var init_types = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/types.mjs"() {
      (function(WalletType2) {
        WalletType2["Ethereum"] = "ethereum";
        WalletType2["Solana"] = "solana";
      })(WalletType || (WalletType = {}));
    }
  });

  // node_modules/abitype/dist/esm/version.js
  var version;
  var init_version2 = __esm({
    "node_modules/abitype/dist/esm/version.js"() {
      version = "1.0.8";
    }
  });

  // node_modules/abitype/dist/esm/errors.js
  var BaseError;
  var init_errors2 = __esm({
    "node_modules/abitype/dist/esm/errors.js"() {
      init_version2();
      BaseError = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath9 = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          const message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath9 ? [`Docs: https://abitype.dev${docsPath9}`] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: abitype@${version}`
          ].join("\n");
          super(message);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiTypeError"
          });
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath9;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/regex.js
  function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
  }
  var bytesRegex, integerRegex, isTupleRegex;
  var init_regex = __esm({
    "node_modules/abitype/dist/esm/regex.js"() {
      bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
      isTupleRegex = /^\(.+?\).*?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
  function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
      type = "(";
      const length = abiParameter.components.length;
      for (let i = 0; i < length; i++) {
        const component = abiParameter.components[i];
        type += formatAbiParameter(component);
        if (i < length - 1)
          type += ", ";
      }
      const result = execTyped(tupleRegex, abiParameter.type);
      type += `)${result?.array ?? ""}`;
      return formatAbiParameter({
        ...abiParameter,
        type
      });
    }
    if ("indexed" in abiParameter && abiParameter.indexed)
      type = `${type} indexed`;
    if (abiParameter.name)
      return `${type} ${abiParameter.name}`;
    return type;
  }
  var tupleRegex;
  var init_formatAbiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
      init_regex();
      tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
  function formatAbiParameters(abiParameters) {
    let params = "";
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      params += formatAbiParameter(abiParameter);
      if (i !== length - 1)
        params += ", ";
    }
    return params;
  }
  var init_formatAbiParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
      init_formatAbiParameter();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
  function formatAbiItem(abiItem) {
    if (abiItem.type === "function")
      return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
    if (abiItem.type === "event")
      return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    if (abiItem.type === "error")
      return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    if (abiItem.type === "constructor")
      return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    if (abiItem.type === "fallback")
      return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    return "receive() external payable";
  }
  var init_formatAbiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
      init_formatAbiParameters();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
  function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
  }
  function execErrorSignature(signature) {
    return execTyped(errorSignatureRegex, signature);
  }
  function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
  }
  function execEventSignature(signature) {
    return execTyped(eventSignatureRegex, signature);
  }
  function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
  }
  function execFunctionSignature(signature) {
    return execTyped(functionSignatureRegex, signature);
  }
  function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
  }
  function execStructSignature(signature) {
    return execTyped(structSignatureRegex, signature);
  }
  function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
  }
  function execConstructorSignature(signature) {
    return execTyped(constructorSignatureRegex, signature);
  }
  function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
  }
  function execFallbackSignature(signature) {
    return execTyped(fallbackSignatureRegex, signature);
  }
  function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
  }
  var errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, modifiers, eventModifiers, functionModifiers;
  var init_signatures = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"() {
      init_regex();
      errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
      structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
      constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
      fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
      receiveSignatureRegex = /^receive\(\) external payable$/;
      modifiers = /* @__PURE__ */ new Set([
        "memory",
        "indexed",
        "storage",
        "calldata"
      ]);
      eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
      functionModifiers = /* @__PURE__ */ new Set([
        "calldata",
        "memory",
        "storage"
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
  var InvalidAbiItemError, UnknownTypeError, UnknownSolidityTypeError;
  var init_abiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"() {
      init_errors2();
      InvalidAbiItemError = class extends BaseError {
        constructor({ signature }) {
          super("Failed to parse ABI item.", {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: "/api/human#parseabiitem-1"
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiItemError"
          });
        }
      };
      UnknownTypeError = class extends BaseError {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [
              `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownTypeError"
          });
        }
      };
      UnknownSolidityTypeError = class extends BaseError {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [`Type "${type}" is not a valid ABI type.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownSolidityTypeError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
  var InvalidAbiParameterError, InvalidAbiParametersError, InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
  var init_abiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"() {
      init_errors2();
      InvalidAbiParameterError = class extends BaseError {
        constructor({ param }) {
          super("Failed to parse ABI parameter.", {
            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
            docsPath: "/api/human#parseabiparameter-1"
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiParameterError"
          });
        }
      };
      InvalidAbiParametersError = class extends BaseError {
        constructor({ params }) {
          super("Failed to parse ABI parameters.", {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: "/api/human#parseabiparameters-1"
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiParametersError"
          });
        }
      };
      InvalidParameterError = class extends BaseError {
        constructor({ param }) {
          super("Invalid ABI parameter.", {
            details: param
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParameterError"
          });
        }
      };
      SolidityProtectedKeywordError = class extends BaseError {
        constructor({ param, name }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SolidityProtectedKeywordError"
          });
        }
      };
      InvalidModifierError = class extends BaseError {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidModifierError"
          });
        }
      };
      InvalidFunctionModifierError = class extends BaseError {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
              `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidFunctionModifierError"
          });
        }
      };
      InvalidAbiTypeParameterError = class extends BaseError {
        constructor({ abiParameter }) {
          super("Invalid ABI parameter.", {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiTypeParameterError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/signature.js
  var InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;
  var init_signature = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/signature.js"() {
      init_errors2();
      InvalidSignatureError = class extends BaseError {
        constructor({ signature, type }) {
          super(`Invalid ${type} signature.`, {
            details: signature
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSignatureError"
          });
        }
      };
      UnknownSignatureError = class extends BaseError {
        constructor({ signature }) {
          super("Unknown signature.", {
            details: signature
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownSignatureError"
          });
        }
      };
      InvalidStructSignatureError = class extends BaseError {
        constructor({ signature }) {
          super("Invalid struct signature.", {
            details: signature,
            metaMessages: ["No properties exist."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStructSignatureError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/struct.js
  var CircularReferenceError;
  var init_struct = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/struct.js"() {
      init_errors2();
      CircularReferenceError = class extends BaseError {
        constructor({ type }) {
          super("Circular reference detected.", {
            metaMessages: [`Struct "${type}" is a circular reference.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CircularReferenceError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
  var InvalidParenthesisError;
  var init_splitParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"() {
      init_errors2();
      InvalidParenthesisError = class extends BaseError {
        constructor({ current, depth }) {
          super("Unbalanced parentheses.", {
            metaMessages: [
              `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
            ],
            details: `Depth "${depth}"`
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParenthesisError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/cache.js
  function getParameterCacheKey(param, type, structs) {
    let structKey = "";
    if (structs)
      for (const struct of Object.entries(structs)) {
        if (!struct)
          continue;
        let propertyKey = "";
        for (const property of struct[1]) {
          propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
        }
        structKey += `(${struct[0]}{${propertyKey}})`;
      }
    if (type)
      return `${type}:${param}${structKey}`;
    return param;
  }
  var parameterCache;
  var init_cache = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/cache.js"() {
      parameterCache = /* @__PURE__ */ new Map([
        // Unnamed
        ["address", { type: "address" }],
        ["bool", { type: "bool" }],
        ["bytes", { type: "bytes" }],
        ["bytes32", { type: "bytes32" }],
        ["int", { type: "int256" }],
        ["int256", { type: "int256" }],
        ["string", { type: "string" }],
        ["uint", { type: "uint256" }],
        ["uint8", { type: "uint8" }],
        ["uint16", { type: "uint16" }],
        ["uint24", { type: "uint24" }],
        ["uint32", { type: "uint32" }],
        ["uint64", { type: "uint64" }],
        ["uint96", { type: "uint96" }],
        ["uint112", { type: "uint112" }],
        ["uint160", { type: "uint160" }],
        ["uint192", { type: "uint192" }],
        ["uint256", { type: "uint256" }],
        // Named
        ["address owner", { type: "address", name: "owner" }],
        ["address to", { type: "address", name: "to" }],
        ["bool approved", { type: "bool", name: "approved" }],
        ["bytes _data", { type: "bytes", name: "_data" }],
        ["bytes data", { type: "bytes", name: "data" }],
        ["bytes signature", { type: "bytes", name: "signature" }],
        ["bytes32 hash", { type: "bytes32", name: "hash" }],
        ["bytes32 r", { type: "bytes32", name: "r" }],
        ["bytes32 root", { type: "bytes32", name: "root" }],
        ["bytes32 s", { type: "bytes32", name: "s" }],
        ["string name", { type: "string", name: "name" }],
        ["string symbol", { type: "string", name: "symbol" }],
        ["string tokenURI", { type: "string", name: "tokenURI" }],
        ["uint tokenId", { type: "uint256", name: "tokenId" }],
        ["uint8 v", { type: "uint8", name: "v" }],
        ["uint256 balance", { type: "uint256", name: "balance" }],
        ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
        ["uint256 value", { type: "uint256", name: "value" }],
        // Indexed
        [
          "event:address indexed from",
          { type: "address", name: "from", indexed: true }
        ],
        ["event:address indexed to", { type: "address", name: "to", indexed: true }],
        [
          "event:uint indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ],
        [
          "event:uint256 indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ]
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/utils.js
  function parseSignature(signature, structs = {}) {
    if (isFunctionSignature(signature))
      return parseFunctionSignature(signature, structs);
    if (isEventSignature(signature))
      return parseEventSignature(signature, structs);
    if (isErrorSignature(signature))
      return parseErrorSignature(signature, structs);
    if (isConstructorSignature(signature))
      return parseConstructorSignature(signature, structs);
    if (isFallbackSignature(signature))
      return parseFallbackSignature(signature);
    if (isReceiveSignature(signature))
      return {
        type: "receive",
        stateMutability: "payable"
      };
    throw new UnknownSignatureError({ signature });
  }
  function parseFunctionSignature(signature, structs = {}) {
    const match = execFunctionSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "function" });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i = 0; i < inputLength; i++) {
      inputs.push(parseAbiParameter(inputParams[i], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
    const outputs = [];
    if (match.returns) {
      const outputParams = splitParameters(match.returns);
      const outputLength = outputParams.length;
      for (let i = 0; i < outputLength; i++) {
        outputs.push(parseAbiParameter(outputParams[i], {
          modifiers: functionModifiers,
          structs,
          type: "function"
        }));
      }
    }
    return {
      name: match.name,
      type: "function",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs,
      outputs
    };
  }
  function parseEventSignature(signature, structs = {}) {
    const match = execEventSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "event" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], {
        modifiers: eventModifiers,
        structs,
        type: "event"
      }));
    return { name: match.name, type: "event", inputs: abiParameters };
  }
  function parseErrorSignature(signature, structs = {}) {
    const match = execErrorSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "error" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
    return { name: match.name, type: "error", inputs: abiParameters };
  }
  function parseConstructorSignature(signature, structs = {}) {
    const match = execConstructorSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "constructor" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs: abiParameters
    };
  }
  function parseFallbackSignature(signature) {
    const match = execFallbackSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "fallback" });
    return {
      type: "fallback",
      stateMutability: match.stateMutability ?? "nonpayable"
    };
  }
  function parseAbiParameter(param, options) {
    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = isTupleRegex.test(param);
    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
      throw new SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0; i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(options?.type === "struct") && !isSolidityType(type))
        throw new UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
      if (!options?.modifiers?.has?.(match.modifier))
        throw new InvalidModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new InvalidFunctionModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
    }
    const abiParameter = {
      type: `${type}${match.array ?? ""}`,
      ...name,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  }
  function splitParameters(params, result = [], current = "", depth = 0) {
    const length = params.trim().length;
    for (let i = 0; i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    if (current === "")
      return result;
    if (depth !== 0)
      throw new InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  function isSolidityType(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
  }
  function isSolidityKeyword(name) {
    return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
  }
  function isValidDataLocation(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  }
  var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
  var init_utils4 = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/utils.js"() {
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_signature();
      init_splitParameters();
      init_cache();
      init_signatures();
      abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      dynamicIntegerRegex = /^u?int$/;
      protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/structs.js
  function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new InvalidSignatureError({ signature, type: "struct" });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0; k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new InvalidStructSignatureError({ signature });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
      const [name, parameters] = entries[i];
      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  }
  function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
        if (!match?.type)
          throw new InvalidAbiTypeParameterError({ abiParameter });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new CircularReferenceError({ type });
          components.push({
            ...abiParameter,
            type: `tuple${array ?? ""}`,
            components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new UnknownTypeError({ type });
        }
      }
    }
    return components;
  }
  var typeWithoutTupleRegex;
  var init_structs = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/structs.js"() {
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_signature();
      init_struct();
      init_signatures();
      init_utils4();
      typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbi.js
  function parseAbi(signatures) {
    const structs = parseStructs(signatures);
    const abi2 = [];
    const length = signatures.length;
    for (let i = 0; i < length; i++) {
      const signature = signatures[i];
      if (isStructSignature(signature))
        continue;
      abi2.push(parseSignature(signature, structs));
    }
    return abi2;
  }
  var init_parseAbi = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbi.js"() {
      init_signatures();
      init_structs();
      init_utils4();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
  function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === "string")
      abiItem = parseSignature(signature);
    else {
      const structs = parseStructs(signature);
      const length = signature.length;
      for (let i = 0; i < length; i++) {
        const signature_ = signature[i];
        if (isStructSignature(signature_))
          continue;
        abiItem = parseSignature(signature_, structs);
        break;
      }
    }
    if (!abiItem)
      throw new InvalidAbiItemError({ signature });
    return abiItem;
  }
  var init_parseAbiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"() {
      init_abiItem();
      init_signatures();
      init_structs();
      init_utils4();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js
  function parseAbiParameter2(param) {
    let abiParameter;
    if (typeof param === "string")
      abiParameter = parseAbiParameter(param, {
        modifiers
      });
    else {
      const structs = parseStructs(param);
      const length = param.length;
      for (let i = 0; i < length; i++) {
        const signature = param[i];
        if (isStructSignature(signature))
          continue;
        abiParameter = parseAbiParameter(signature, { modifiers, structs });
        break;
      }
    }
    if (!abiParameter)
      throw new InvalidAbiParameterError({ param });
    return abiParameter;
  }
  var init_parseAbiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js"() {
      init_abiParameter();
      init_signatures();
      init_structs();
      init_utils4();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
  function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = splitParameters(params);
      const length = parameters.length;
      for (let i = 0; i < length; i++) {
        abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));
      }
    } else {
      const structs = parseStructs(params);
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const signature = params[i];
        if (isStructSignature(signature))
          continue;
        const parameters = splitParameters(signature);
        const length2 = parameters.length;
        for (let k = 0; k < length2; k++) {
          abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new InvalidAbiParametersError({ params });
    return abiParameters;
  }
  var init_parseAbiParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"() {
      init_abiParameter();
      init_signatures();
      init_structs();
      init_utils4();
      init_utils4();
    }
  });

  // node_modules/abitype/dist/esm/exports/index.js
  var init_exports = __esm({
    "node_modules/abitype/dist/esm/exports/index.js"() {
      init_formatAbiItem();
      init_parseAbi();
      init_parseAbiItem();
      init_parseAbiParameter();
      init_parseAbiParameters();
      init_abiItem();
      init_abiParameter();
      init_signature();
      init_splitParameters();
      init_struct();
    }
  });

  // node_modules/viem/_esm/utils/getAction.js
  function getAction(client, actionFn, name) {
    const action_implicit = client[actionFn.name];
    if (typeof action_implicit === "function")
      return action_implicit;
    const action_explicit = client[name];
    if (typeof action_explicit === "function")
      return action_explicit;
    return (params) => actionFn(client, params);
  }
  var init_getAction = __esm({
    "node_modules/viem/_esm/utils/getAction.js"() {
    }
  });

  // node_modules/viem/_esm/utils/abi/formatAbiItem.js
  function formatAbiItem2(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  var init_formatAbiItem2 = __esm({
    "node_modules/viem/_esm/utils/abi/formatAbiItem.js"() {
      init_abi();
    }
  });

  // node_modules/viem/_esm/utils/data/isHex.js
  function isHex(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  var init_isHex = __esm({
    "node_modules/viem/_esm/utils/data/isHex.js"() {
    }
  });

  // node_modules/viem/_esm/utils/data/size.js
  function size(value) {
    if (isHex(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  var init_size = __esm({
    "node_modules/viem/_esm/utils/data/size.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/_esm/errors/version.js
  var version2;
  var init_version3 = __esm({
    "node_modules/viem/_esm/errors/version.js"() {
      version2 = "2.33.1";
    }
  });

  // node_modules/viem/_esm/errors/base.js
  function setErrorConfig(config2) {
    errorConfig = config2;
  }
  function walk(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
      return walk(err.cause, fn);
    return fn ? null : err;
  }
  var errorConfig, BaseError2;
  var init_base2 = __esm({
    "node_modules/viem/_esm/errors/base.js"() {
      init_version3();
      errorConfig = {
        getDocsUrl: ({ docsBaseUrl, docsPath: docsPath9 = "", docsSlug }) => docsPath9 ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath9}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
        version: `viem@${version2}`
      };
      BaseError2 = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          const details = (() => {
            if (args.cause instanceof _BaseError)
              return args.cause.details;
            if (args.cause?.message)
              return args.cause.message;
            return args.details;
          })();
          const docsPath9 = (() => {
            if (args.cause instanceof _BaseError)
              return args.cause.docsPath || args.docsPath;
            return args.docsPath;
          })();
          const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath: docsPath9 });
          const message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsUrl ? [`Docs: ${docsUrl}`] : [],
            ...details ? [`Details: ${details}`] : [],
            ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
          ].join("\n");
          super(message, args.cause ? { cause: args.cause } : void 0);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BaseError"
          });
          this.details = details;
          this.docsPath = docsPath9;
          this.metaMessages = args.metaMessages;
          this.name = args.name ?? this.name;
          this.shortMessage = shortMessage;
          this.version = version2;
        }
        walk(fn) {
          return walk(this, fn);
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/abi.js
  var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeInvalidError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorInputsNotFoundError, AbiErrorNotFoundError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiFunctionSignatureNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError, UnsupportedPackedAbiType;
  var init_abi = __esm({
    "node_modules/viem/_esm/errors/abi.js"() {
      init_formatAbiItem2();
      init_size();
      init_base2();
      AbiConstructorNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath9 }) {
          super([
            "A constructor was not found on the ABI.",
            "Make sure you are using the correct ABI and that the constructor exists on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiConstructorNotFoundError"
          });
        }
      };
      AbiConstructorParamsNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath9 }) {
          super([
            "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
            "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiConstructorParamsNotFoundError"
          });
        }
      };
      AbiDecodingDataSizeInvalidError = class extends BaseError2 {
        constructor({ data, size: size5 }) {
          super([
            `Data size of ${size5} bytes is invalid.`,
            "Size must be in increments of 32 bytes (size % 32 === 0)."
          ].join("\n"), {
            metaMessages: [`Data: ${data} (${size5} bytes)`],
            name: "AbiDecodingDataSizeInvalidError"
          });
        }
      };
      AbiDecodingDataSizeTooSmallError = class extends BaseError2 {
        constructor({ data, params, size: size5 }) {
          super([`Data size of ${size5} bytes is too small for given parameters.`].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size5} bytes)`
            ],
            name: "AbiDecodingDataSizeTooSmallError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
          this.params = params;
          this.size = size5;
        }
      };
      AbiDecodingZeroDataError = class extends BaseError2 {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: "AbiDecodingZeroDataError"
          });
        }
      };
      AbiEncodingArrayLengthMismatchError = class extends BaseError2 {
        constructor({ expectedLength, givenLength, type }) {
          super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
          ].join("\n"), { name: "AbiEncodingArrayLengthMismatchError" });
        }
      };
      AbiEncodingBytesSizeMismatchError = class extends BaseError2 {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
        }
      };
      AbiEncodingLengthMismatchError = class extends BaseError2 {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"), { name: "AbiEncodingLengthMismatchError" });
        }
      };
      AbiErrorInputsNotFoundError = class extends BaseError2 {
        constructor(errorName, { docsPath: docsPath9 }) {
          super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            "Cannot encode error result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the inputs exist on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiErrorInputsNotFoundError"
          });
        }
      };
      AbiErrorNotFoundError = class extends BaseError2 {
        constructor(errorName, { docsPath: docsPath9 } = {}) {
          super([
            `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiErrorNotFoundError"
          });
        }
      };
      AbiErrorSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath9 }) {
          super([
            `Encoded error signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiErrorSignatureNotFoundError"
          });
          Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.signature = signature;
        }
      };
      AbiEventSignatureEmptyTopicsError = class extends BaseError2 {
        constructor({ docsPath: docsPath9 }) {
          super("Cannot extract event signature from empty topics.", {
            docsPath: docsPath9,
            name: "AbiEventSignatureEmptyTopicsError"
          });
        }
      };
      AbiEventSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath9 }) {
          super([
            `Encoded event signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiEventSignatureNotFoundError"
          });
        }
      };
      AbiEventNotFoundError = class extends BaseError2 {
        constructor(eventName, { docsPath: docsPath9 } = {}) {
          super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiEventNotFoundError"
          });
        }
      };
      AbiFunctionNotFoundError = class extends BaseError2 {
        constructor(functionName, { docsPath: docsPath9 } = {}) {
          super([
            `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiFunctionNotFoundError"
          });
        }
      };
      AbiFunctionOutputsNotFoundError = class extends BaseError2 {
        constructor(functionName, { docsPath: docsPath9 }) {
          super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            "Cannot decode function result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiFunctionOutputsNotFoundError"
          });
        }
      };
      AbiFunctionSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath9 }) {
          super([
            `Encoded function signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath9,
            name: "AbiFunctionSignatureNotFoundError"
          });
        }
      };
      AbiItemAmbiguityError = class extends BaseError2 {
        constructor(x, y) {
          super("Found ambiguous types in overloaded ABI items.", {
            metaMessages: [
              `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
              `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
              "",
              "These types encode differently and cannot be distinguished at runtime.",
              "Remove one of the ambiguous items in the ABI."
            ],
            name: "AbiItemAmbiguityError"
          });
        }
      };
      BytesSizeMismatchError = class extends BaseError2 {
        constructor({ expectedSize, givenSize }) {
          super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
            name: "BytesSizeMismatchError"
          });
        }
      };
      DecodeLogDataMismatch = class extends BaseError2 {
        constructor({ abiItem, data, params, size: size5 }) {
          super([
            `Data size of ${size5} bytes is too small for non-indexed event parameters.`
          ].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size5} bytes)`
            ],
            name: "DecodeLogDataMismatch"
          });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
          this.data = data;
          this.params = params;
          this.size = size5;
        }
      };
      DecodeLogTopicsMismatch = class extends BaseError2 {
        constructor({ abiItem, param }) {
          super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
          ].join("\n"), { name: "DecodeLogTopicsMismatch" });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
        }
      };
      InvalidAbiEncodingTypeError = class extends BaseError2 {
        constructor(type, { docsPath: docsPath9 }) {
          super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath9, name: "InvalidAbiEncodingType" });
        }
      };
      InvalidAbiDecodingTypeError = class extends BaseError2 {
        constructor(type, { docsPath: docsPath9 }) {
          super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath9, name: "InvalidAbiDecodingType" });
        }
      };
      InvalidArrayError = class extends BaseError2 {
        constructor(value) {
          super([`Value "${value}" is not a valid array.`].join("\n"), {
            name: "InvalidArrayError"
          });
        }
      };
      InvalidDefinitionTypeError = class extends BaseError2 {
        constructor(type) {
          super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
          ].join("\n"), { name: "InvalidDefinitionTypeError" });
        }
      };
      UnsupportedPackedAbiType = class extends BaseError2 {
        constructor(type) {
          super(`Type "${type}" is not supported for packed encoding.`, {
            name: "UnsupportedPackedAbiType"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/log.js
  var FilterTypeNotSupportedError;
  var init_log = __esm({
    "node_modules/viem/_esm/errors/log.js"() {
      init_base2();
      FilterTypeNotSupportedError = class extends BaseError2 {
        constructor(type) {
          super(`Filter type "${type}" is not supported.`, {
            name: "FilterTypeNotSupportedError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/data.js
  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
  var init_data = __esm({
    "node_modules/viem/_esm/errors/data.js"() {
      init_base2();
      SliceOffsetOutOfBoundsError = class extends BaseError2 {
        constructor({ offset, position, size: size5 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size5}).`, { name: "SliceOffsetOutOfBoundsError" });
        }
      };
      SizeExceedsPaddingSizeError = class extends BaseError2 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size5}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
        }
      };
      InvalidBytesLengthError = class extends BaseError2 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size5} ${type} long.`, { name: "InvalidBytesLengthError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/pad.js
  function pad(hexOrBytes, { dir, size: size5 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex(hexOrBytes, { dir, size: size5 });
    return padBytes(hexOrBytes, { dir, size: size5 });
  }
  function padHex(hex_, { dir, size: size5 = 32 } = {}) {
    if (size5 === null)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size5 * 2)
      throw new SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size5,
        type: "hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size5 * 2, "0")}`;
  }
  function padBytes(bytes, { dir, size: size5 = 32 } = {}) {
    if (size5 === null)
      return bytes;
    if (bytes.length > size5)
      throw new SizeExceedsPaddingSizeError({
        size: bytes.length,
        targetSize: size5,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size5);
    for (let i = 0; i < size5; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size5 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
  }
  var init_pad = __esm({
    "node_modules/viem/_esm/utils/data/pad.js"() {
      init_data();
    }
  });

  // node_modules/viem/_esm/errors/encoding.js
  var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, InvalidHexValueError, SizeOverflowError;
  var init_encoding = __esm({
    "node_modules/viem/_esm/errors/encoding.js"() {
      init_base2();
      IntegerOutOfRangeError = class extends BaseError2 {
        constructor({ max, min, signed, size: size5, value }) {
          super(`Number "${value}" is not in safe ${size5 ? `${size5 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
        }
      };
      InvalidBytesBooleanError = class extends BaseError2 {
        constructor(bytes) {
          super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: "InvalidBytesBooleanError"
          });
        }
      };
      InvalidHexBooleanError = class extends BaseError2 {
        constructor(hex) {
          super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
        }
      };
      InvalidHexValueError = class extends BaseError2 {
        constructor(value) {
          super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, { name: "InvalidHexValueError" });
        }
      };
      SizeOverflowError = class extends BaseError2 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/trim.js
  function trim(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
      if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data.length === 1 && dir === "right")
        data = `${data}0`;
      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
  }
  var init_trim = __esm({
    "node_modules/viem/_esm/utils/data/trim.js"() {
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromHex.js
  function assertSize(hexOrBytes, { size: size5 }) {
    if (size(hexOrBytes) > size5)
      throw new SizeOverflowError({
        givenSize: size(hexOrBytes),
        maxSize: size5
      });
  }
  function fromHex2(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return hexToNumber2(hex, opts);
    if (to === "bigint")
      return hexToBigInt(hex, opts);
    if (to === "string")
      return hexToString(hex, opts);
    if (to === "boolean")
      return hexToBool(hex, opts);
    return hexToBytes3(hex, opts);
  }
  function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
      assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
      return value;
    const size5 = (hex.length - 2) / 2;
    const max = (1n << BigInt(size5) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size5 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = trim(hex);
    }
    if (trim(hex) === "0x00")
      return false;
    if (trim(hex) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex);
  }
  function hexToNumber2(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
  }
  function hexToString(hex, opts = {}) {
    let bytes = hexToBytes3(hex);
    if (opts.size) {
      assertSize(bytes, { size: opts.size });
      bytes = trim(bytes, { dir: "right" });
    }
    return new TextDecoder().decode(bytes);
  }
  var init_fromHex = __esm({
    "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
      init_encoding();
      init_size();
      init_trim();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toHex.js
  function toHex2(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex(value, opts);
    if (typeof value === "string") {
      return stringToHex(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex(value, opts);
    return bytesToHex3(value, opts);
  }
  function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { size: opts.size });
    }
    return hex;
  }
  function bytesToHex3(value, opts = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++) {
      string += hexes3[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { dir: "right", size: opts.size });
    }
    return hex;
  }
  function numberToHex(value_, opts = {}) {
    const { signed, size: size5 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size5) {
      if (signed)
        maxValue = (1n << BigInt(size5) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size5) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size5,
        value: `${value_}${suffix}`
      });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size5)
      return pad(hex, { size: size5 });
    return hex;
  }
  function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex3(value, opts);
  }
  var hexes3, encoder;
  var init_toHex = __esm({
    "node_modules/viem/_esm/utils/encoding/toHex.js"() {
      init_encoding();
      init_pad();
      init_fromHex();
      hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
      encoder = /* @__PURE__ */ new TextEncoder();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toBytes.js
  function toBytes2(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes(value, opts);
    if (typeof value === "boolean")
      return boolToBytes(value, opts);
    if (isHex(value))
      return hexToBytes3(value, opts);
    return stringToBytes(value, opts);
  }
  function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === "number") {
      assertSize(bytes, { size: opts.size });
      return pad(bytes, { size: opts.size });
    }
    return bytes;
  }
  function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
      return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
      return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
      return char - (charCodeMap.a - 10);
    return void 0;
  }
  function hexToBytes3(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = pad(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index2 = 0, j = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
  }
  function numberToBytes(value, opts) {
    const hex = numberToHex(value, opts);
    return hexToBytes3(hex);
  }
  function stringToBytes(value, opts = {}) {
    const bytes = encoder2.encode(value);
    if (typeof opts.size === "number") {
      assertSize(bytes, { size: opts.size });
      return pad(bytes, { dir: "right", size: opts.size });
    }
    return bytes;
  }
  var encoder2, charCodeMap;
  var init_toBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
      init_base2();
      init_isHex();
      init_pad();
      init_fromHex();
      init_toHex();
      encoder2 = /* @__PURE__ */ new TextEncoder();
      charCodeMap = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };
    }
  });

  // node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    clean(B);
  }
  var _0n5, _1n5, _2n3, _7n, _256n, _0x71n, SHA3_PI, SHA3_ROTL, _SHA3_IOTA, IOTAS, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, keccak_256;
  var init_sha3 = __esm({
    "node_modules/@noble/hashes/esm/sha3.js"() {
      init_u64();
      init_utils2();
      _0n5 = BigInt(0);
      _1n5 = BigInt(1);
      _2n3 = BigInt(2);
      _7n = BigInt(7);
      _256n = BigInt(256);
      _0x71n = BigInt(113);
      SHA3_PI = [];
      SHA3_ROTL = [];
      _SHA3_IOTA = [];
      for (let round = 0, R = _1n5, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n5;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n5 ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n3)
            t ^= _1n5 << (_1n5 << /* @__PURE__ */ BigInt(j)) - _1n5;
        }
        _SHA3_IOTA.push(t);
      }
      IOTAS = split(_SHA3_IOTA, true);
      SHA3_IOTA_H = IOTAS[0];
      SHA3_IOTA_L = IOTAS[1];
      rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
      rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
      Keccak = class _Keccak extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          this.enableXOF = false;
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          anumber(outputLen);
          if (!(0 < blockLen && blockLen < 200))
            throw new Error("only keccak-f1600 function is supported");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          swap32IfBE(this.state32);
          keccakP(this.state32, this.rounds);
          swap32IfBE(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          aexists(this);
          data = toBytes(data);
          abytes(data);
          const { blockLen, state } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          aexists(this, false);
          abytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          anumber(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          aoutput(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          clean(this.state);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
      keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
    }
  });

  // node_modules/viem/_esm/utils/hash/keccak256.js
  function keccak256(value, to_) {
    const to = to_ || "hex";
    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes2(value) : value);
    if (to === "bytes")
      return bytes;
    return toHex2(bytes);
  }
  var init_keccak256 = __esm({
    "node_modules/viem/_esm/utils/hash/keccak256.js"() {
      init_sha3();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/hash/hashSignature.js
  function hashSignature(sig) {
    return hash(sig);
  }
  var hash;
  var init_hashSignature = __esm({
    "node_modules/viem/_esm/utils/hash/hashSignature.js"() {
      init_toBytes();
      init_keccak256();
      hash = (value) => keccak256(toBytes2(value));
    }
  });

  // node_modules/viem/_esm/utils/hash/normalizeSignature.js
  function normalizeSignature(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new BaseError2("Unable to normalize signature.");
    return result;
  }
  var init_normalizeSignature = __esm({
    "node_modules/viem/_esm/utils/hash/normalizeSignature.js"() {
      init_base2();
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignature.js
  var toSignature;
  var init_toSignature = __esm({
    "node_modules/viem/_esm/utils/hash/toSignature.js"() {
      init_exports();
      init_normalizeSignature();
      toSignature = (def) => {
        const def_ = (() => {
          if (typeof def === "string")
            return def;
          return formatAbiItem(def);
        })();
        return normalizeSignature(def_);
      };
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignatureHash.js
  function toSignatureHash(fn) {
    return hashSignature(toSignature(fn));
  }
  var init_toSignatureHash = __esm({
    "node_modules/viem/_esm/utils/hash/toSignatureHash.js"() {
      init_hashSignature();
      init_toSignature();
    }
  });

  // node_modules/viem/_esm/utils/hash/toEventSelector.js
  var toEventSelector;
  var init_toEventSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toEventSelector.js"() {
      init_toSignatureHash();
      toEventSelector = toSignatureHash;
    }
  });

  // node_modules/viem/_esm/errors/address.js
  var InvalidAddressError;
  var init_address = __esm({
    "node_modules/viem/_esm/errors/address.js"() {
      init_base2();
      InvalidAddressError = class extends BaseError2 {
        constructor({ address }) {
          super(`Address "${address}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart."
            ],
            name: "InvalidAddressError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/lru.js
  var LruMap;
  var init_lru = __esm({
    "node_modules/viem/_esm/utils/lru.js"() {
      LruMap = class extends Map {
        constructor(size5) {
          super();
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.maxSize = size5;
        }
        get(key) {
          const value = super.get(key);
          if (super.has(key) && value !== void 0) {
            this.delete(key);
            super.set(key, value);
          }
          return value;
        }
        set(key, value) {
          super.set(key, value);
          if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
              this.delete(firstKey);
          }
          return this;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/address/getAddress.js
  function checksumAddress(address_, chainId) {
    if (checksumAddressCache.has(`${address_}.${chainId}`))
      return checksumAddressCache.get(`${address_}.${chainId}`);
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i = 0; i < 40; i += 2) {
      if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
        address[i] = address[i].toUpperCase();
      }
      if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
        address[i + 1] = address[i + 1].toUpperCase();
      }
    }
    const result = `0x${address.join("")}`;
    checksumAddressCache.set(`${address_}.${chainId}`, result);
    return result;
  }
  function getAddress(address, chainId) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    return checksumAddress(address, chainId);
  }
  var checksumAddressCache;
  var init_getAddress = __esm({
    "node_modules/viem/_esm/utils/address/getAddress.js"() {
      init_address();
      init_toBytes();
      init_keccak256();
      init_lru();
      init_isAddress();
      checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/address/isAddress.js
  function isAddress(address, options) {
    const { strict = true } = options ?? {};
    const cacheKey2 = `${address}.${strict}`;
    if (isAddressCache.has(cacheKey2))
      return isAddressCache.get(cacheKey2);
    const result = (() => {
      if (!addressRegex.test(address))
        return false;
      if (address.toLowerCase() === address)
        return true;
      if (strict)
        return checksumAddress(address) === address;
      return true;
    })();
    isAddressCache.set(cacheKey2, result);
    return result;
  }
  var addressRegex, isAddressCache;
  var init_isAddress = __esm({
    "node_modules/viem/_esm/utils/address/isAddress.js"() {
      init_lru();
      init_getAddress();
      addressRegex = /^0x[a-fA-F0-9]{40}$/;
      isAddressCache = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/data/concat.js
  function concat(values) {
    if (typeof values[0] === "string")
      return concatHex(values);
    return concatBytes3(values);
  }
  function concatBytes3(values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  var init_concat = __esm({
    "node_modules/viem/_esm/utils/data/concat.js"() {
    }
  });

  // node_modules/viem/_esm/utils/data/slice.js
  function slice(value, start, end, { strict } = {}) {
    if (isHex(value, { strict: false }))
      return sliceHex(value, start, end, {
        strict
      });
    return sliceBytes(value, start, end, {
      strict
    });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  var init_slice = __esm({
    "node_modules/viem/_esm/utils/data/slice.js"() {
      init_data();
      init_isHex();
      init_size();
    }
  });

  // node_modules/viem/_esm/utils/regex.js
  var arrayRegex, bytesRegex2, integerRegex2;
  var init_regex2 = __esm({
    "node_modules/viem/_esm/utils/regex.js"() {
      arrayRegex = /^(.*)\[([0-9]*)\]$/;
      bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
  function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams({
      params,
      values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function prepareParams({ params, values }) {
    const preparedParams = [];
    for (let i = 0; i < params.length; i++) {
      preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
  }
  function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed = param.type.startsWith("int");
      const [, , size5 = "256"] = integerRegex2.exec(param.type) ?? [];
      return encodeNumber(value, {
        signed,
        size: Number(size5)
      });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat([...staticParams, ...dynamicParams]);
  }
  function encodeAddress(value) {
    if (!isAddress(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  }
  function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0; i < value.length; i++) {
      const preparedParam = prepareParam({ param, value: value[i] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encodeParams(preparedParams);
      if (dynamic) {
        const length2 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = size(value);
    if (!paramSize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padHex(value_, {
          dir: "right",
          size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
      return {
        dynamic: true,
        encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
      };
    }
    if (bytesSize !== Number.parseInt(paramSize))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: Number.parseInt(paramSize),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  }
  function encodeBool(value) {
    if (typeof value !== "boolean")
      throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  }
  function encodeNumber(value, { signed, size: size5 = 256 }) {
    if (typeof size5 === "number") {
      const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;
      const min = signed ? -max - 1n : 0n;
      if (value > max || value < min)
        throw new IntegerOutOfRangeError({
          max: max.toString(),
          min: min.toString(),
          signed,
          size: size5 / 8,
          value: value.toString()
        });
    }
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString(value) {
    const hexValue = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
      parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat([
        padHex(numberToHex(size(hexValue), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0; i < param.components.length; i++) {
      const param_ = param.components[i];
      const index2 = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index2]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  var init_encodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"() {
      init_abi();
      init_address();
      init_base2();
      init_encoding();
      init_isAddress();
      init_concat();
      init_pad();
      init_size();
      init_slice();
      init_toHex();
      init_regex2();
    }
  });

  // node_modules/viem/_esm/utils/hash/toFunctionSelector.js
  var toFunctionSelector;
  var init_toFunctionSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toFunctionSelector.js"() {
      init_slice();
      init_toSignatureHash();
      toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
    }
  });

  // node_modules/viem/_esm/utils/abi/getAbiItem.js
  function getAbiItem(parameters) {
    const { abi: abi2, args = [], name } = parameters;
    const isSelector = isHex(name, { strict: false });
    const abiItems = abi2.filter((abiItem) => {
      if (isSelector) {
        if (abiItem.type === "function")
          return toFunctionSelector(abiItem) === name;
        if (abiItem.type === "event")
          return toEventSelector(abiItem) === name;
        return false;
      }
      return "name" in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
      return void 0;
    if (abiItems.length === 1)
      return abiItems[0];
    let matchedAbiItem = void 0;
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      if (abiItem.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new AbiItemAmbiguityError({
              abiItem,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem;
      }
    }
    if (matchedAbiItem)
      return matchedAbiItem;
    return abiItems[0];
  }
  function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return isAddress(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return isAddress(args[parameterIndex], { strict: false });
        if (types.includes("address") && types.includes("bytes"))
          return isAddress(args[parameterIndex], { strict: false });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  var init_getAbiItem = __esm({
    "node_modules/viem/_esm/utils/abi/getAbiItem.js"() {
      init_abi();
      init_isHex();
      init_isAddress();
      init_toEventSelector();
      init_toFunctionSelector();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeEventTopics.js
  function encodeEventTopics(parameters) {
    const { abi: abi2, eventName, args } = parameters;
    let abiItem = abi2[0];
    if (eventName) {
      const item = getAbiItem({ abi: abi2, name: eventName });
      if (!item)
        throw new AbiEventNotFoundError(eventName, { docsPath });
      abiItem = item;
    }
    if (abiItem.type !== "event")
      throw new AbiEventNotFoundError(void 0, { docsPath });
    const definition = formatAbiItem2(abiItem);
    const signature = toEventSelector(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
      const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
      if (args_.length > 0) {
        topics = indexedInputs?.map((param, i) => {
          if (Array.isArray(args_[i]))
            return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
          return typeof args_[i] !== "undefined" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;
        }) ?? [];
      }
    }
    return [signature, ...topics];
  }
  function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return keccak256(toBytes2(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new FilterTypeNotSupportedError(param.type);
    return encodeAbiParameters([param], [value]);
  }
  var docsPath;
  var init_encodeEventTopics = __esm({
    "node_modules/viem/_esm/utils/abi/encodeEventTopics.js"() {
      init_abi();
      init_log();
      init_toBytes();
      init_keccak256();
      init_toEventSelector();
      init_encodeAbiParameters();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath = "/docs/contract/encodeEventTopics";
    }
  });

  // node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
  function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback")
      client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
        if (status === "success" && method === method_)
          requestMap[id] = transport.request;
      });
    return (id) => requestMap[id] || client.request;
  }
  var init_createFilterRequestScope = __esm({
    "node_modules/viem/_esm/utils/filters/createFilterRequestScope.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/createContractEventFilter.js
  async function createContractEventFilter(client, parameters) {
    const { address, abi: abi2, args, eventName, fromBlock, strict, toBlock } = parameters;
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    const topics = eventName ? encodeEventTopics({
      abi: abi2,
      args,
      eventName
    }) : void 0;
    const id = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          topics
        }
      ]
    });
    return {
      abi: abi2,
      args,
      eventName,
      id,
      request: getRequest(id),
      strict: Boolean(strict),
      type: "event"
    };
  }
  var init_createContractEventFilter = __esm({
    "node_modules/viem/_esm/actions/public/createContractEventFilter.js"() {
      init_encodeEventTopics();
      init_toHex();
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/accounts/utils/parseAccount.js
  function parseAccount(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  var init_parseAccount = __esm({
    "node_modules/viem/_esm/accounts/utils/parseAccount.js"() {
    }
  });

  // node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
  function prepareEncodeFunctionData(parameters) {
    const { abi: abi2, args, functionName } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({
        abi: abi2,
        args,
        name: functionName
      });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath2 });
    return {
      abi: [abiItem],
      functionName: toFunctionSelector(formatAbiItem2(abiItem))
    };
  }
  var docsPath2;
  var init_prepareEncodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js"() {
      init_abi();
      init_toFunctionSelector();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath2 = "/docs/contract/encodeFunctionData";
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeFunctionData.js
  function encodeFunctionData(parameters) {
    const { args } = parameters;
    const { abi: abi2, functionName } = (() => {
      if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
        return parameters;
      return prepareEncodeFunctionData(parameters);
    })();
    const abiItem = abi2[0];
    const signature = functionName;
    const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
    return concatHex([signature, data ?? "0x"]);
  }
  var init_encodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/encodeFunctionData.js"() {
      init_concat();
      init_encodeAbiParameters();
      init_prepareEncodeFunctionData();
    }
  });

  // node_modules/viem/_esm/constants/solidity.js
  var panicReasons, solidityError, solidityPanic;
  var init_solidity = __esm({
    "node_modules/viem/_esm/constants/solidity.js"() {
      panicReasons = {
        1: "An `assert` condition failed.",
        17: "Arithmetic operation resulted in underflow or overflow.",
        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
        33: "Attempted to convert to an invalid type.",
        34: "Attempted to access a storage byte array that is incorrectly encoded.",
        49: "Performed `.pop()` on an empty array",
        50: "Array index is out of bounds.",
        65: "Allocated too much memory or created an array which is too large.",
        81: "Attempted to call a zero-initialized variable of internal function type."
      };
      solidityError = {
        inputs: [
          {
            name: "message",
            type: "string"
          }
        ],
        name: "Error",
        type: "error"
      };
      solidityPanic = {
        inputs: [
          {
            name: "reason",
            type: "uint256"
          }
        ],
        name: "Panic",
        type: "error"
      };
    }
  });

  // node_modules/viem/_esm/errors/cursor.js
  var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
  var init_cursor = __esm({
    "node_modules/viem/_esm/errors/cursor.js"() {
      init_base2();
      NegativeOffsetError = class extends BaseError2 {
        constructor({ offset }) {
          super(`Offset \`${offset}\` cannot be negative.`, {
            name: "NegativeOffsetError"
          });
        }
      };
      PositionOutOfBoundsError = class extends BaseError2 {
        constructor({ length, position }) {
          super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
        }
      };
      RecursiveReadLimitExceededError = class extends BaseError2 {
        constructor({ count, limit }) {
          super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/cursor.js
  function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    cursor.positionReadCount = /* @__PURE__ */ new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
  }
  var staticCursor;
  var init_cursor2 = __esm({
    "node_modules/viem/_esm/utils/cursor.js"() {
      init_cursor();
      staticCursor = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: /* @__PURE__ */ new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: Number.POSITIVE_INFINITY,
        assertReadLimit() {
          if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new RecursiveReadLimitExceededError({
              count: this.recursiveReadCount + 1,
              limit: this.recursiveReadLimit
            });
        },
        assertPosition(position) {
          if (position < 0 || position > this.bytes.length - 1)
            throw new PositionOutOfBoundsError({
              length: this.bytes.length,
              position
            });
        },
        decrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position - offset;
          this.assertPosition(position);
          this.position = position;
        },
        getReadCount(position) {
          return this.positionReadCount.get(position || this.position) || 0;
        },
        incrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position + offset;
          this.assertPosition(position);
          this.position = position;
        },
        inspectByte(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectBytes(length, position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + length - 1);
          return this.bytes.subarray(position, position + length);
        },
        inspectUint8(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectUint16(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 1);
          return this.dataView.getUint16(position);
        },
        inspectUint24(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 2);
          return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
        },
        inspectUint32(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 3);
          return this.dataView.getUint32(position);
        },
        pushByte(byte) {
          this.assertPosition(this.position);
          this.bytes[this.position] = byte;
          this.position++;
        },
        pushBytes(bytes) {
          this.assertPosition(this.position + bytes.length - 1);
          this.bytes.set(bytes, this.position);
          this.position += bytes.length;
        },
        pushUint8(value) {
          this.assertPosition(this.position);
          this.bytes[this.position] = value;
          this.position++;
        },
        pushUint16(value) {
          this.assertPosition(this.position + 1);
          this.dataView.setUint16(this.position, value);
          this.position += 2;
        },
        pushUint24(value) {
          this.assertPosition(this.position + 2);
          this.dataView.setUint16(this.position, value >> 8);
          this.dataView.setUint8(this.position + 2, value & ~4294967040);
          this.position += 3;
        },
        pushUint32(value) {
          this.assertPosition(this.position + 3);
          this.dataView.setUint32(this.position, value);
          this.position += 4;
        },
        readByte() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectByte();
          this.position++;
          return value;
        },
        readBytes(length, size5) {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectBytes(length);
          this.position += size5 ?? length;
          return value;
        },
        readUint8() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint8();
          this.position += 1;
          return value;
        },
        readUint16() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint16();
          this.position += 2;
          return value;
        },
        readUint24() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint24();
          this.position += 3;
          return value;
        },
        readUint32() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint32();
          this.position += 4;
          return value;
        },
        get remaining() {
          return this.bytes.length - this.position;
        },
        setPosition(position) {
          const oldPosition = this.position;
          this.assertPosition(position);
          this.position = position;
          return () => this.position = oldPosition;
        },
        _touch() {
          if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
            return;
          const count = this.getReadCount();
          this.positionReadCount.set(this.position, count + 1);
          if (count > 0)
            this.recursiveReadCount++;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromBytes.js
  function fromBytes(bytes, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return bytesToNumber(bytes, opts);
    if (to === "bigint")
      return bytesToBigInt(bytes, opts);
    if (to === "boolean")
      return bytesToBool(bytes, opts);
    if (to === "string")
      return bytesToString(bytes, opts);
    return bytesToHex3(bytes, opts);
  }
  function bytesToBigInt(bytes, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes, { size: opts.size });
    const hex = bytesToHex3(bytes, opts);
    return hexToBigInt(hex, opts);
  }
  function bytesToBool(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes, { size: opts.size });
      bytes = trim(bytes);
    }
    if (bytes.length > 1 || bytes[0] > 1)
      throw new InvalidBytesBooleanError(bytes);
    return Boolean(bytes[0]);
  }
  function bytesToNumber(bytes, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes, { size: opts.size });
    const hex = bytesToHex3(bytes, opts);
    return hexToNumber2(hex, opts);
  }
  function bytesToString(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes, { size: opts.size });
      bytes = trim(bytes, { dir: "right" });
    }
    return new TextDecoder().decode(bytes);
  }
  var init_fromBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/fromBytes.js"() {
      init_encoding();
      init_trim();
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
  function decodeAbiParameters(params, data) {
    const bytes = typeof data === "string" ? hexToBytes3(data) : data;
    const cursor = createCursor(bytes);
    if (size(bytes) === 0 && params.length > 0)
      throw new AbiDecodingZeroDataError();
    if (size(data) && size(data) < 32)
      throw new AbiDecodingDataSizeTooSmallError({
        data: typeof data === "string" ? data : bytesToHex3(data),
        params,
        size: size(data)
      });
    let consumed = 0;
    const values = [];
    for (let i = 0; i < params.length; ++i) {
      const param = params[i];
      cursor.setPosition(consumed);
      const [data2, consumed_] = decodeParameter(cursor, param, {
        staticPosition: 0
      });
      consumed += consumed_;
      values.push(data2);
    }
    return values;
  }
  function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === "tuple")
      return decodeTuple(cursor, param, { staticPosition });
    if (param.type === "address")
      return decodeAddress(cursor);
    if (param.type === "bool")
      return decodeBool(cursor);
    if (param.type.startsWith("bytes"))
      return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith("uint") || param.type.startsWith("int"))
      return decodeNumber(cursor, param);
    if (param.type === "string")
      return decodeString(cursor, { staticPosition });
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [checksumAddress(bytesToHex3(sliceBytes(value, -20))), 32];
  }
  function decodeArray(cursor, param, { length, staticPosition }) {
    if (!length) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const startOfData = start + sizeOfLength;
      cursor.setPosition(start);
      const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
      const dynamicChild = hasDynamicChild(param);
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0; i < length2; ++i) {
        cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
        const [data, consumed_] = decodeParameter(cursor, param, {
          staticPosition: startOfData
        });
        consumed2 += consumed_;
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const value2 = [];
      for (let i = 0; i < length; ++i) {
        cursor.setPosition(start + i * 32);
        const [data] = decodeParameter(cursor, param, {
          staticPosition: start
        });
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: staticPosition + consumed
      });
      consumed += consumed_;
      value.push(data);
    }
    return [value, consumed];
  }
  function decodeBool(cursor) {
    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
  }
  function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size5] = param.type.split("bytes");
    if (!size5) {
      const offset = bytesToNumber(cursor.readBytes(32));
      cursor.setPosition(staticPosition + offset);
      const length = bytesToNumber(cursor.readBytes(32));
      if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ["0x", 32];
      }
      const data = cursor.readBytes(length);
      cursor.setPosition(staticPosition + 32);
      return [bytesToHex3(data), 32];
    }
    const value = bytesToHex3(cursor.readBytes(Number.parseInt(size5), 32));
    return [value, 32];
  }
  function decodeNumber(cursor, param) {
    const signed = param.type.startsWith("int");
    const size5 = Number.parseInt(param.type.split("int")[1] || "256");
    const value = cursor.readBytes(32);
    return [
      size5 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
      32
    ];
  }
  function decodeTuple(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        cursor.setPosition(start + consumed);
        const [data, consumed_] = decodeParameter(cursor, component, {
          staticPosition: start
        });
        consumed += consumed_;
        value[hasUnnamedChild ? i : component?.name] = data;
      }
      cursor.setPosition(staticPosition + 32);
      return [value, 32];
    }
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition
      });
      value[hasUnnamedChild ? i : component?.name] = data;
      consumed += consumed_;
    }
    return [value, consumed];
  }
  function decodeString(cursor, { staticPosition }) {
    const offset = bytesToNumber(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["", 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = bytesToString(trim(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  var sizeOfLength, sizeOfOffset;
  var init_decodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/decodeAbiParameters.js"() {
      init_abi();
      init_getAddress();
      init_cursor2();
      init_size();
      init_slice();
      init_trim();
      init_fromBytes();
      init_toBytes();
      init_toHex();
      init_encodeAbiParameters();
      sizeOfLength = 32;
      sizeOfOffset = 32;
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeErrorResult.js
  function decodeErrorResult(parameters) {
    const { abi: abi2, data } = parameters;
    const signature = slice(data, 0, 4);
    if (signature === "0x")
      throw new AbiDecodingZeroDataError();
    const abi_ = [...abi2 || [], solidityError, solidityPanic];
    const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem2(x)));
    if (!abiItem)
      throw new AbiErrorSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeErrorResult"
      });
    return {
      abiItem,
      args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
      errorName: abiItem.name
    };
  }
  var init_decodeErrorResult = __esm({
    "node_modules/viem/_esm/utils/abi/decodeErrorResult.js"() {
      init_solidity();
      init_abi();
      init_slice();
      init_toFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem2();
    }
  });

  // node_modules/viem/_esm/utils/stringify.js
  var stringify;
  var init_stringify = __esm({
    "node_modules/viem/_esm/utils/stringify.js"() {
      stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value2) : value2;
      }, space);
    }
  });

  // node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
  function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem))
      return;
    if (!("inputs" in abiItem))
      return;
    if (!abiItem.inputs)
      return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
  }
  var init_formatAbiItemWithArgs = __esm({
    "node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js"() {
      init_stringify();
    }
  });

  // node_modules/viem/_esm/constants/unit.js
  var etherUnits, gweiUnits, weiUnits;
  var init_unit = __esm({
    "node_modules/viem/_esm/constants/unit.js"() {
      etherUnits = {
        gwei: 9,
        wei: 18
      };
      gweiUnits = {
        ether: -9,
        wei: 9
      };
      weiUnits = {
        ether: -18,
        gwei: -9
      };
    }
  });

  // node_modules/viem/_esm/utils/unit/formatUnits.js
  function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  var init_formatUnits = __esm({
    "node_modules/viem/_esm/utils/unit/formatUnits.js"() {
    }
  });

  // node_modules/viem/_esm/utils/unit/formatEther.js
  function formatEther(wei, unit = "wei") {
    return formatUnits(wei, etherUnits[unit]);
  }
  var init_formatEther = __esm({
    "node_modules/viem/_esm/utils/unit/formatEther.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/_esm/utils/unit/formatGwei.js
  function formatGwei(wei, unit = "wei") {
    return formatUnits(wei, gweiUnits[unit]);
  }
  var init_formatGwei = __esm({
    "node_modules/viem/_esm/utils/unit/formatGwei.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/_esm/errors/stateOverride.js
  function prettyStateMapping(stateMapping) {
    return stateMapping.reduce((pretty, { slot, value }) => {
      return `${pretty}        ${slot}: ${value}
`;
    }, "");
  }
  function prettyStateOverride(stateOverride) {
    return stateOverride.reduce((pretty, { address, ...state }) => {
      let val = `${pretty}    ${address}:
`;
      if (state.nonce)
        val += `      nonce: ${state.nonce}
`;
      if (state.balance)
        val += `      balance: ${state.balance}
`;
      if (state.code)
        val += `      code: ${state.code}
`;
      if (state.state) {
        val += "      state:\n";
        val += prettyStateMapping(state.state);
      }
      if (state.stateDiff) {
        val += "      stateDiff:\n";
        val += prettyStateMapping(state.stateDiff);
      }
      return val;
    }, "  State Override:\n").slice(0, -1);
  }
  var AccountStateConflictError, StateAssignmentConflictError;
  var init_stateOverride = __esm({
    "node_modules/viem/_esm/errors/stateOverride.js"() {
      init_base2();
      AccountStateConflictError = class extends BaseError2 {
        constructor({ address }) {
          super(`State for account "${address}" is set multiple times.`, {
            name: "AccountStateConflictError"
          });
        }
      };
      StateAssignmentConflictError = class extends BaseError2 {
        constructor() {
          super("state and stateDiff are set on the same account.", {
            name: "StateAssignmentConflictError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/transaction.js
  function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value]) => {
      if (value === void 0 || value === false)
        return null;
      return [key, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidSerializedTransactionTypeError, InvalidSerializedTransactionError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
  var init_transaction = __esm({
    "node_modules/viem/_esm/errors/transaction.js"() {
      init_formatEther();
      init_formatGwei();
      init_base2();
      FeeConflictError = class extends BaseError2 {
        constructor() {
          super([
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
            "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
          ].join("\n"), { name: "FeeConflictError" });
        }
      };
      InvalidLegacyVError = class extends BaseError2 {
        constructor({ v }) {
          super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
            name: "InvalidLegacyVError"
          });
        }
      };
      InvalidSerializableTransactionError = class extends BaseError2 {
        constructor({ transaction }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              prettyPrint(transaction),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
              "- an EIP-7702 Transaction with `authorizationList`, or",
              "- a Legacy Transaction with `gasPrice`"
            ],
            name: "InvalidSerializableTransactionError"
          });
        }
      };
      InvalidSerializedTransactionTypeError = class extends BaseError2 {
        constructor({ serializedType }) {
          super(`Serialized transaction type "${serializedType}" is invalid.`, {
            name: "InvalidSerializedTransactionType"
          });
          Object.defineProperty(this, "serializedType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.serializedType = serializedType;
        }
      };
      InvalidSerializedTransactionError = class extends BaseError2 {
        constructor({ attributes, serializedTransaction, type }) {
          const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
          super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
              `Serialized Transaction: "${serializedTransaction}"`,
              missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
            ].filter(Boolean),
            name: "InvalidSerializedTransactionError"
          });
          Object.defineProperty(this, "serializedTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.serializedTransaction = serializedTransaction;
          this.type = type;
        }
      };
      InvalidStorageKeySizeError = class extends BaseError2 {
        constructor({ storageKey }) {
          super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
        }
      };
      TransactionExecutionError = class extends BaseError2 {
        constructor(cause, { account, docsPath: docsPath9, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath9,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Request Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "TransactionExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
      TransactionNotFoundError = class extends BaseError2 {
        constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
          let identifier = "Transaction";
          if (blockTag && index2 !== void 0)
            identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
          if (blockHash && index2 !== void 0)
            identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
          if (blockNumber && index2 !== void 0)
            identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
          if (hash2)
            identifier = `Transaction with hash "${hash2}"`;
          super(`${identifier} could not be found.`, {
            name: "TransactionNotFoundError"
          });
        }
      };
      TransactionReceiptNotFoundError = class extends BaseError2 {
        constructor({ hash: hash2 }) {
          super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`, {
            name: "TransactionReceiptNotFoundError"
          });
        }
      };
      WaitForTransactionReceiptTimeoutError = class extends BaseError2 {
        constructor({ hash: hash2 }) {
          super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/utils.js
  var getContractAddress, getUrl;
  var init_utils5 = __esm({
    "node_modules/viem/_esm/errors/utils.js"() {
      getContractAddress = (address) => address;
      getUrl = (url) => url;
    }
  });

  // node_modules/viem/_esm/errors/contract.js
  var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;
  var init_contract = __esm({
    "node_modules/viem/_esm/errors/contract.js"() {
      init_parseAccount();
      init_solidity();
      init_decodeErrorResult();
      init_formatAbiItem2();
      init_formatAbiItemWithArgs();
      init_getAbiItem();
      init_formatEther();
      init_formatGwei();
      init_abi();
      init_base2();
      init_stateOverride();
      init_transaction();
      init_utils5();
      CallExecutionError = class extends BaseError2 {
        constructor(cause, { account: account_, docsPath: docsPath9, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
          const account = account_ ? parseAccount(account_) : void 0;
          let prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          if (stateOverride) {
            prettyArgs += `
${prettyStateOverride(stateOverride)}`;
          }
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath9,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Raw Call Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "CallExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
      ContractFunctionExecutionError = class extends BaseError2 {
        constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath9, functionName, sender }) {
          const abiItem = getAbiItem({ abi: abi2, args, name: functionName });
          const formattedArgs = abiItem ? formatAbiItemWithArgs({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;
          const prettyArgs = prettyPrint({
            address: contractAddress && getContractAddress(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
            sender
          });
          super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath: docsPath9,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              prettyArgs && "Contract Call:",
              prettyArgs
            ].filter(Boolean),
            name: "ContractFunctionExecutionError"
          });
          Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abi = abi2;
          this.args = args;
          this.cause = cause;
          this.contractAddress = contractAddress;
          this.functionName = functionName;
          this.sender = sender;
        }
      };
      ContractFunctionRevertedError = class extends BaseError2 {
        constructor({ abi: abi2, data, functionName, message }) {
          let cause;
          let decodedData = void 0;
          let metaMessages;
          let reason;
          if (data && data !== "0x") {
            try {
              decodedData = decodeErrorResult({ abi: abi2, data });
              const { abiItem, errorName, args: errorArgs } = decodedData;
              if (errorName === "Error") {
                reason = errorArgs[0];
              } else if (errorName === "Panic") {
                const [firstArg] = errorArgs;
                reason = panicReasons[firstArg];
              } else {
                const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;
                const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
                  abiItem,
                  args: errorArgs,
                  includeFunctionName: false,
                  includeName: false
                }) : void 0;
                metaMessages = [
                  errorWithParams ? `Error: ${errorWithParams}` : "",
                  formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
                ];
              }
            } catch (err) {
              cause = err;
            }
          } else if (message)
            reason = message;
          let signature;
          if (cause instanceof AbiErrorSignatureNotFoundError) {
            signature = cause.signature;
            metaMessages = [
              `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
              "Make sure you are using the correct ABI and that the error exists on it.",
              `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
            ];
          }
          super(reason && reason !== "execution reverted" || signature ? [
            `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
            reason || signature
          ].join("\n") : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
            name: "ContractFunctionRevertedError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = decodedData;
          this.raw = data;
          this.reason = reason;
          this.signature = signature;
        }
      };
      ContractFunctionZeroDataError = class extends BaseError2 {
        constructor({ functionName }) {
          super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
              "This could be due to any of the following:",
              `  - The contract does not have the function "${functionName}",`,
              "  - The parameters passed to the contract function may be invalid, or",
              "  - The address is not a contract."
            ],
            name: "ContractFunctionZeroDataError"
          });
        }
      };
      CounterfactualDeploymentFailedError = class extends BaseError2 {
        constructor({ factory }) {
          super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
            metaMessages: [
              "Please ensure:",
              "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
              "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
            ],
            name: "CounterfactualDeploymentFailedError"
          });
        }
      };
      RawContractError = class extends BaseError2 {
        constructor({ data, message }) {
          super(message || "", { name: "RawContractError" });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/request.js
  var HttpRequestError, WebSocketRequestError, RpcRequestError, SocketClosedError, TimeoutError;
  var init_request = __esm({
    "node_modules/viem/_esm/errors/request.js"() {
      init_stringify();
      init_base2();
      init_utils5();
      HttpRequestError = class extends BaseError2 {
        constructor({ body, cause, details, headers, status, url }) {
          super("HTTP request failed.", {
            cause,
            details,
            metaMessages: [
              status && `Status: ${status}`,
              `URL: ${getUrl(url)}`,
              body && `Request body: ${stringify(body)}`
            ].filter(Boolean),
            name: "HttpRequestError"
          });
          Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.body = body;
          this.headers = headers;
          this.status = status;
          this.url = url;
        }
      };
      WebSocketRequestError = class extends BaseError2 {
        constructor({ body, cause, details, url }) {
          super("WebSocket request failed.", {
            cause,
            details,
            metaMessages: [
              `URL: ${getUrl(url)}`,
              body && `Request body: ${stringify(body)}`
            ].filter(Boolean),
            name: "WebSocketRequestError"
          });
        }
      };
      RpcRequestError = class extends BaseError2 {
        constructor({ body, error, url }) {
          super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
            name: "RpcRequestError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = error.code;
          this.data = error.data;
        }
      };
      SocketClosedError = class extends BaseError2 {
        constructor({ url } = {}) {
          super("The socket has been closed.", {
            metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean),
            name: "SocketClosedError"
          });
        }
      };
      TimeoutError = class extends BaseError2 {
        constructor({ body, url }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
            name: "TimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/rpc.js
  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnsupportedNonOptionalCapabilityError, UnsupportedChainIdError, DuplicateIdError, UnknownBundleIdError, BundleTooLargeError, AtomicReadyWalletRejectedUpgradeError, AtomicityNotSupportedError, UnknownRpcError;
  var init_rpc = __esm({
    "node_modules/viem/_esm/errors/rpc.js"() {
      init_base2();
      init_request();
      unknownErrorCode = -1;
      RpcError = class extends BaseError2 {
        constructor(cause, { code, docsPath: docsPath9, metaMessages, name, shortMessage }) {
          super(shortMessage, {
            cause,
            docsPath: docsPath9,
            metaMessages: metaMessages || cause?.metaMessages,
            name: name || "RpcError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = name || cause.name;
          this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
        }
      };
      ProviderRpcError = class extends RpcError {
        constructor(cause, options) {
          super(cause, options);
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = options.data;
        }
      };
      ParseRpcError = class _ParseRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ParseRpcError.code,
            name: "ParseRpcError",
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
          });
        }
      };
      Object.defineProperty(ParseRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32700
      });
      InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidRequestRpcError.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object."
          });
        }
      };
      Object.defineProperty(InvalidRequestRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32600
      });
      MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _MethodNotFoundRpcError.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
          });
        }
      };
      Object.defineProperty(MethodNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32601
      });
      InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidParamsRpcError.code,
            name: "InvalidParamsRpcError",
            shortMessage: [
              "Invalid parameters were provided to the RPC method.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
        }
      };
      Object.defineProperty(InvalidParamsRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32602
      });
      InternalRpcError = class _InternalRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InternalRpcError.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received."
          });
        }
      };
      Object.defineProperty(InternalRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32603
      });
      InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidInputRpcError.code,
            name: "InvalidInputRpcError",
            shortMessage: [
              "Missing or invalid parameters.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
        }
      };
      Object.defineProperty(InvalidInputRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32e3
      });
      ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceNotFoundRpcError.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
          });
        }
      };
      Object.defineProperty(ResourceNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32001
      });
      ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceUnavailableRpcError.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available."
          });
        }
      };
      Object.defineProperty(ResourceUnavailableRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32002
      });
      TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _TransactionRejectedRpcError.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed."
          });
        }
      };
      Object.defineProperty(TransactionRejectedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32003
      });
      MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _MethodNotSupportedRpcError.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
          });
        }
      };
      Object.defineProperty(MethodNotSupportedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32004
      });
      LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _LimitExceededRpcError.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit."
          });
        }
      };
      Object.defineProperty(LimitExceededRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32005
      });
      JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _JsonRpcVersionUnsupportedError.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported."
          });
        }
      };
      Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32006
      });
      UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UserRejectedRequestError.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request."
          });
        }
      };
      Object.defineProperty(UserRejectedRequestError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4001
      });
      UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnauthorizedProviderError.code,
            name: "UnauthorizedProviderError",
            shortMessage: "The requested method and/or account has not been authorized by the user."
          });
        }
      };
      Object.defineProperty(UnauthorizedProviderError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4100
      });
      UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _UnsupportedProviderMethodError.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
          });
        }
      };
      Object.defineProperty(UnsupportedProviderMethodError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4200
      });
      ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ProviderDisconnectedError.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains."
          });
        }
      };
      Object.defineProperty(ProviderDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4900
      });
      ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ChainDisconnectedError.code,
            name: "ChainDisconnectedError",
            shortMessage: "The Provider is not connected to the requested chain."
          });
        }
      };
      Object.defineProperty(ChainDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4901
      });
      SwitchChainError = class _SwitchChainError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _SwitchChainError.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain."
          });
        }
      };
      Object.defineProperty(SwitchChainError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4902
      });
      UnsupportedNonOptionalCapabilityError = class _UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnsupportedNonOptionalCapabilityError.code,
            name: "UnsupportedNonOptionalCapabilityError",
            shortMessage: "This Wallet does not support a capability that was not marked as optional."
          });
        }
      };
      Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5700
      });
      UnsupportedChainIdError = class _UnsupportedChainIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnsupportedChainIdError.code,
            name: "UnsupportedChainIdError",
            shortMessage: "This Wallet does not support the requested chain ID."
          });
        }
      };
      Object.defineProperty(UnsupportedChainIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5710
      });
      DuplicateIdError = class _DuplicateIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _DuplicateIdError.code,
            name: "DuplicateIdError",
            shortMessage: "There is already a bundle submitted with this ID."
          });
        }
      };
      Object.defineProperty(DuplicateIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5720
      });
      UnknownBundleIdError = class _UnknownBundleIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnknownBundleIdError.code,
            name: "UnknownBundleIdError",
            shortMessage: "This bundle id is unknown / has not been submitted"
          });
        }
      };
      Object.defineProperty(UnknownBundleIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5730
      });
      BundleTooLargeError = class _BundleTooLargeError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _BundleTooLargeError.code,
            name: "BundleTooLargeError",
            shortMessage: "The call bundle is too large for the Wallet to process."
          });
        }
      };
      Object.defineProperty(BundleTooLargeError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5740
      });
      AtomicReadyWalletRejectedUpgradeError = class _AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _AtomicReadyWalletRejectedUpgradeError.code,
            name: "AtomicReadyWalletRejectedUpgradeError",
            shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
          });
        }
      };
      Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5750
      });
      AtomicityNotSupportedError = class _AtomicityNotSupportedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _AtomicityNotSupportedError.code,
            name: "AtomicityNotSupportedError",
            shortMessage: "The wallet does not support atomic execution but the request requires it."
          });
        }
      };
      Object.defineProperty(AtomicityNotSupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5760
      });
      UnknownRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred."
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/errors/getContractError.js
  function getContractError(err, { abi: abi2, address, args, docsPath: docsPath9, functionName, sender }) {
    const error = err instanceof RawContractError ? err : err instanceof BaseError2 ? err.walk((err2) => "data" in err2) || err.walk() : {};
    const { code, data, details, message, shortMessage } = error;
    const cause = (() => {
      if (err instanceof AbiDecodingZeroDataError)
        return new ContractFunctionZeroDataError({ functionName });
      if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
        return new ContractFunctionRevertedError({
          abi: abi2,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: error instanceof RpcRequestError ? details : shortMessage ?? message
        });
      }
      return err;
    })();
    return new ContractFunctionExecutionError(cause, {
      abi: abi2,
      args,
      contractAddress: address,
      docsPath: docsPath9,
      functionName,
      sender
    });
  }
  var EXECUTION_REVERTED_ERROR_CODE;
  var init_getContractError = __esm({
    "node_modules/viem/_esm/utils/errors/getContractError.js"() {
      init_abi();
      init_base2();
      init_contract();
      init_request();
      init_rpc();
      EXECUTION_REVERTED_ERROR_CODE = 3;
    }
  });

  // node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
  function publicKeyToAddress(publicKey) {
    const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
    return checksumAddress(`0x${address}`);
  }
  var init_publicKeyToAddress = __esm({
    "node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js"() {
      init_getAddress();
      init_keccak256();
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/utils.js
  function abool2(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded2(num2) {
    const hex = num2.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber3(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n6 : BigInt("0x" + hex);
  }
  function bytesToNumberBE2(bytes) {
    return hexToNumber3(bytesToHex(bytes));
  }
  function bytesToNumberLE2(bytes) {
    abytes(bytes);
    return hexToNumber3(bytesToHex(Uint8Array.from(bytes).reverse()));
  }
  function numberToBytesBE2(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE2(n, len) {
    return numberToBytesBE2(n, len).reverse();
  }
  function ensureBytes2(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function inRange2(n, min, max) {
    return isPosBig2(n) && isPosBig2(min) && isPosBig2(max) && min <= n && n < max;
  }
  function aInRange2(title, n, min, max) {
    if (!inRange2(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen2(n) {
    let len;
    for (len = 0; n > _0n6; n >>= _1n6, len += 1)
      ;
    return len;
  }
  function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n2 = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n2(hashLen);
    let k = u8n2(hashLen);
    let i = 0;
    const reset2 = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n2(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset2();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset2();
      return res;
    };
    return genUntil;
  }
  function isHash(val) {
    return typeof val === "function" && Number.isSafeInteger(val.outputLen);
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  function memoized2(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
  var _0n6, _1n6, isPosBig2, bitMask2;
  var init_utils6 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/utils.js"() {
      init_utils2();
      init_utils2();
      _0n6 = /* @__PURE__ */ BigInt(0);
      _1n6 = /* @__PURE__ */ BigInt(1);
      isPosBig2 = (n) => typeof n === "bigint" && _0n6 <= n;
      bitMask2 = (n) => (_1n6 << BigInt(n)) - _1n6;
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js
  function mod2(a, b) {
    const result = a % b;
    return result >= _0n7 ? result : b + result;
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n7) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert2(number, modulo) {
    if (number === _0n7)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n7)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod2(number, modulo);
    let b = modulo;
    let x = _0n7, y = _1n7, u = _1n7, v = _0n7;
    while (a !== _0n7) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n7)
      throw new Error("invert: does not exist");
    return mod2(x, modulo);
  }
  function sqrt3mod4(Fp2, n) {
    const p1div4 = (Fp2.ORDER + _1n7) / _4n3;
    const root = Fp2.pow(n, p1div4);
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
    return root;
  }
  function sqrt5mod8(Fp2, n) {
    const p5div8 = (Fp2.ORDER - _5n2) / _8n2;
    const n2 = Fp2.mul(n, _2n4);
    const v = Fp2.pow(n2, p5div8);
    const nv = Fp2.mul(n, v);
    const i = Fp2.mul(Fp2.mul(nv, _2n4), v);
    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
    return root;
  }
  function tonelliShanks2(P) {
    if (P < BigInt(3))
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n7;
    let S = 0;
    while (Q % _2n4 === _0n7) {
      Q /= _2n4;
      S++;
    }
    let Z = _2n4;
    const _Fp = Field2(P);
    while (FpLegendre2(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n7) / _2n4;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.is0(n))
        return n;
      if (FpLegendre2(Fp2, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp2.mul(Fp2.ONE, cc);
      let t = Fp2.pow(n, Q);
      let R = Fp2.pow(n, Q1div2);
      while (!Fp2.eql(t, Fp2.ONE)) {
        if (Fp2.is0(t))
          return Fp2.ZERO;
        let i = 1;
        let t_tmp = Fp2.sqr(t);
        while (!Fp2.eql(t_tmp, Fp2.ONE)) {
          i++;
          t_tmp = Fp2.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n7 << BigInt(M - i - 1);
        const b = Fp2.pow(c, exponent);
        M = i;
        c = Fp2.sqr(b);
        t = Fp2.mul(t, c);
        R = Fp2.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt2(P) {
    if (P % _4n3 === _3n3)
      return sqrt3mod4;
    if (P % _8n2 === _5n2)
      return sqrt5mod8;
    return tonelliShanks2(P);
  }
  function validateField2(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS2.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    _validateObject(field, opts);
    return field;
  }
  function FpPow2(Fp2, num2, power) {
    if (power < _0n7)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n7)
      return Fp2.ONE;
    if (power === _1n7)
      return num2;
    let p = Fp2.ONE;
    let d = num2;
    while (power > _0n7) {
      if (power & _1n7)
        p = Fp2.mul(p, d);
      d = Fp2.sqr(d);
      power >>= _1n7;
    }
    return p;
  }
  function FpInvertBatch2(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num2);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num2);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre2(Fp2, n) {
    const p1mod2 = (Fp2.ORDER - _1n7) / _2n4;
    const powered = Fp2.pow(n, p1mod2);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function nLength2(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
    if (ORDER <= _0n7)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE3)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE3 = _opts.isLE;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE3,
      BITS,
      BYTES,
      MASK: bitMask2(BITS),
      ZERO: _0n7,
      ONE: _1n7,
      create: (num2) => mod2(num2, ORDER),
      isValid: (num2) => {
        if (typeof num2 !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num2);
        return _0n7 <= num2 && num2 < ORDER;
      },
      is0: (num2) => num2 === _0n7,
      // is valid and invertible
      isValidNot0: (num2) => !f.is0(num2) && f.isValid(num2),
      isOdd: (num2) => (num2 & _1n7) === _1n7,
      neg: (num2) => mod2(-num2, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num2) => mod2(num2 * num2, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num2, power) => FpPow2(f, num2, power),
      div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num2) => num2 * num2,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num2) => invert2(num2, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt2(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num2) => isLE3 ? numberToBytesLE2(num2, BYTES) : numberToBytesBE2(num2, BYTES),
      fromBytes: (bytes) => {
        if (bytes.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
        return isLE3 ? bytesToNumberLE2(bytes) : bytesToNumberBE2(bytes);
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch2(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength2(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength2(fieldOrder) {
    const length = getFieldBytesLength2(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField2(key, fieldOrder, isLE3 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength2(fieldOrder);
    const minLen = getMinHashLength2(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num2 = isLE3 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
    const reduced = mod2(num2, fieldOrder - _1n7) + _1n7;
    return isLE3 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
  }
  var _0n7, _1n7, _2n4, _3n3, _4n3, _5n2, _8n2, FIELD_FIELDS2;
  var init_modular2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_utils6();
      _0n7 = BigInt(0);
      _1n7 = BigInt(1);
      _2n4 = /* @__PURE__ */ BigInt(2);
      _3n3 = /* @__PURE__ */ BigInt(3);
      _4n3 = /* @__PURE__ */ BigInt(4);
      _5n2 = /* @__PURE__ */ BigInt(5);
      _8n2 = /* @__PURE__ */ BigInt(8);
      FIELD_FIELDS2 = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, property, points) {
    const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
    const toInv = FpInvertBatch2(c.Fp, points.map(getz));
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
  }
  function validateW2(W2, bits) {
    if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
  }
  function calcWOpts2(W2, scalarBits) {
    validateW2(W2, scalarBits);
    const windows = Math.ceil(scalarBits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    const maxNumber = 2 ** W2;
    const mask = bitMask2(W2);
    const shiftBy = BigInt(W2);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets2(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n8;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints2(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars2(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  function getW2(P) {
    return pointWindowSizes2.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n8)
      throw new Error("invalid wNAF");
  }
  function wNAF2(c, bits) {
    return {
      constTimeNegate: negateCt,
      hasPrecomputes(elm) {
        return getW2(elm) !== 1;
      },
      // non-const time multiplication ladder
      unsafeLadder(elm, n, p = c.ZERO) {
        let d = elm;
        while (n > _0n8) {
          if (n & _1n8)
            p = p.add(d);
          d = d.double();
          n >>= _1n8;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param elm Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W2) {
        const { windows, windowSize } = calcWOpts2(W2, bits);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W2, precomputes, n) {
        let p = c.ZERO;
        let f = c.BASE;
        const wo = calcWOpts2(W2, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      },
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W2, precomputes, n, acc = c.ZERO) {
        const wo = calcWOpts2(W2, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n8)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets2(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      },
      getPrecomputes(W2, P, transform) {
        let comp = pointPrecomputes2.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W2);
          if (W2 !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes2.set(P, comp);
          }
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W2 = getW2(P);
        return this.wNAF(W2, this.getPrecomputes(W2, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W2 = getW2(P);
        if (W2 === 1)
          return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W2, this.getPrecomputes(W2, P, transform), n, prev);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W2) {
        validateW2(W2, bits);
        pointWindowSizes2.set(P, W2);
        pointPrecomputes2.delete(P);
      }
    };
  }
  function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n8 || k2 > _0n8) {
      if (k1 & _1n8)
        p1 = p1.add(acc);
      if (k2 & _1n8)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n8;
      k2 >>= _1n8;
    }
    return { p1, p2 };
  }
  function pippenger2(c, fieldN, points, scalars) {
    validateMSMPoints2(points, c);
    validateMSMScalars2(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen2(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask2(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField(order, field) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField2(field);
      return field;
    } else {
      return Field2(order);
    }
  }
  function _createCurveFields(type, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n8))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp2 = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp2.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    return { Fp: Fp2, Fn };
  }
  var _0n8, _1n8, pointPrecomputes2, pointWindowSizes2;
  var init_curve2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_utils6();
      init_modular2();
      _0n8 = BigInt(0);
      _1n8 = BigInt(1);
      pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
      pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validateSigVerOpts2(opts) {
    if (opts.lowS !== void 0)
      abool2("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool2("prehash", opts.prehash);
  }
  function _legacyHelperEquat(Fp2, a, b) {
    function weierstrassEquation(x) {
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    return weierstrassEquation;
  }
  function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    function normPrivateKeyToScalar(key) {
      let num2;
      if (typeof key === "bigint") {
        num2 = key;
      } else {
        let bytes = ensureBytes2("private key", key);
        if (allowedPrivateKeyLengths) {
          if (!allowedPrivateKeyLengths.includes(bytes.length * 2))
            throw new Error("invalid private key");
          const padded = new Uint8Array(expected);
          padded.set(bytes, padded.length - bytes.length);
          bytes = padded;
        }
        try {
          num2 = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (wrapPrivateKey)
        num2 = Fn.create(num2);
      if (!Fn.isValidNot0(num2))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num2;
    }
    return normPrivateKeyToScalar;
  }
  function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp: Fp2, Fn } = _createCurveFields("weierstrass", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    _validateObject(curveOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = curveOpts;
    if (endo) {
      if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
      }
    }
    function assertCompressionIsSupported() {
      if (!Fp2.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes2(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp2.toBytes(x);
      abool2("isCompressed", isCompressed);
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp2.isOdd(y);
        return concatBytes(pprefix(hasEvenY), bx);
      } else {
        return concatBytes(Uint8Array.of(4), bx, Fp2.toBytes(y));
      }
    }
    function pointFromBytes(bytes) {
      abytes(bytes);
      const L = Fp2.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      const length = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (length === LC && (head === 2 || head === 3)) {
        const x = Fp2.fromBytes(tail);
        if (!Fp2.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp2.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (length === LU && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(L * 0, L * 1));
        const y = Fp2.fromBytes(tail.subarray(L * 1, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
      }
    }
    const toBytes4 = curveOpts.toBytes || pointToBytes2;
    const fromBytes3 = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp2, CURVE.a, CURVE.b);
    function isValidXY(x, y) {
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      return Fp2.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n4), _4n4);
    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
    if (Fp2.is0(Fp2.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp2.isValid(n) || banZero && Fp2.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized2((p, iz) => {
      const { px: x, py: y, pz: z } = p;
      if (Fp2.eql(z, Fp2.ONE))
        return { x, y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized2((p) => {
      if (p.is0()) {
        if (curveOpts.allowInfinityPoint && !Fp2.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point2(Fp2.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point2 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(px, py, pz) {
        this.px = acoord("x", px);
        this.py = acoord("y", py, true);
        this.pz = acoord("z", pz);
        Object.freeze(this);
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        if (Fp2.is0(x) && Fp2.is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        return normalizeZ(Point2, "pz", points);
      }
      static fromBytes(bytes) {
        abytes(bytes);
        return Point2.fromHex(bytes);
      }
      /** Converts hash string or Uint8Array to Point. */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes3(ensureBytes2("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      /** Multiplies generator point by privateKey. */
      static fromPrivateKey(privateKey) {
        const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      /** Multiscalar Multiplication */
      static msm(points, scalars) {
        return pippenger2(Point2, Fn, points, scalars);
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy)
          this.multiply(_3n4);
        return this;
      }
      /** "Private method", don't use it directly */
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp2.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp2.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n4);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n4);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = curveOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul3 = (n) => wnaf.wNAFCached(this, n, Point2.normalizeZ);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
          const { p: k1p, f: k1f } = mul3(k1);
          const { p: k2p, f: k2f } = mul3(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul3(scalar);
          point = p;
          fake = f;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = curveOpts;
        const p = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n9 || p.is0())
          return Point2.ZERO;
        if (sc === _1n9)
          return p;
        if (wnaf.hasPrecomputes(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
          const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.wNAFCachedUnsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = curveOpts;
        if (cofactor === _1n9)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = curveOpts;
        if (cofactor === _1n9)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(cofactor);
      }
      toBytes(isCompressed = true) {
        abool2("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes4(Point2, this, isCompressed);
      }
      /** @deprecated use `toBytes` */
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    Point2.Fp = Fp2;
    Point2.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = wNAF2(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point2;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function ecdsa(Point2, ecdsaOpts, curveOpts = {}) {
    _validateObject(ecdsaOpts, { hash: "function" }, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs)));
    const { Fp: Fp2, Fn } = Point2;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n9;
      return number > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num2) {
      if (!Fn.isValidNot0(num2))
        throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    class Signature {
      constructor(r, s, recovery) {
        aValidRS("r", r);
        aValidRS("s", s);
        this.r = r;
        this.s = s;
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const L = Fn.BYTES;
        const b = ensureBytes2("compactSignature", hex, L * 2);
        return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER2.toSig(ensureBytes2("DER", hex));
        return new Signature(r, s);
      }
      /**
       * @todo remove
       * @deprecated
       */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      // ProjPointType<bigint>
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp2.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n5 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp2.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp2.toBytes(radj);
        const R = Point2.fromHex(concatBytes(pprefix((rec & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toBytes(format) {
        if (format === "compact")
          return concatBytes(Fn.toBytes(this.r), Fn.toBytes(this.s));
        if (format === "der")
          return hexToBytes(DER2.hexFromSig(this));
        throw new Error("invalid format");
      }
      // DER-encoded
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex(this.toBytes("der"));
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex(this.toBytes("compact"));
      }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const n = CURVE_ORDER;
        return mapHashToField2(randomBytes_(getMinHashLength2(n)), n);
      },
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point2)
        return true;
      const arr = ensureBytes2("key", item);
      const length = arr.length;
      const L = Fp2.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
        return void 0;
      } else {
        return length === LC || length === LU;
      }
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false)
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    const bits2int = ecdsaOpts.bits2int || function(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num2 = bytesToNumberBE2(bytes);
      const delta = bytes.length * 8 - fnBits;
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes) {
      return Fn.create(bits2int(bytes));
    };
    const ORDER_MASK = bitMask2(fnBits);
    function int2octets(num2) {
      aInRange2("num < 2^" + fnBits, num2, _0n9, ORDER_MASK);
      return Fn.toBytes(num2);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2 } = ecdsaOpts;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes2("msgHash", msgHash);
      validateSigVerOpts2(opts);
      if (prehash)
        msgHash = ensureBytes2("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes_(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes2("extraEntropy", e));
      }
      const seed = concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n9)
          return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n9)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n9);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = createHmacDrbg2(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
      return drbg(seed, k2sig);
    }
    Point2.BASE.precompute(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes2("msgHash", msgHash);
      publicKey = ensureBytes2("publicKey", publicKey);
      validateSigVerOpts2(opts);
      const { lowS, prehash, format } = opts;
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format !== void 0 && !["compact", "der", "js"].includes(format))
        throw new Error('format must be "compact", "der" or "js"');
      const isHex2 = typeof sg === "string" || isBytes(sg);
      const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex2 && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = void 0;
      let P;
      try {
        if (isObj) {
          if (format === void 0 || format === "js") {
            _sig = new Signature(sg.r, sg.s);
          } else {
            throw new Error("invalid format");
          }
        }
        if (isHex2) {
          try {
            if (format !== "compact")
              _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER2.Err))
              throw derError;
          }
          if (!_sig && format !== "der")
            _sig = Signature.fromCompact(sg);
        }
        P = Point2.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig)
        return false;
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = ecdsaOpts.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    }
    return Object.freeze({
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign,
      verify,
      utils,
      Point: Point2,
      Signature
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp2 = c.Fp;
    const Fn = Field2(CURVE.n, c.nBitLength);
    const curveOpts = {
      Fp: Fp2,
      Fn,
      allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      wrapPrivateKey: c.wrapPrivateKey,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hash: c.hash,
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE, curveOpts, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy(c, ecdsa2) {
    return Object.assign({}, ecdsa2, {
      ProjectivePoint: ecdsa2.Point,
      CURVE: c
    });
  }
  function weierstrass2(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point2 = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point2, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }
  function SWUFpSqrtRatio(Fp2, Z) {
    const q = Fp2.ORDER;
    let l = _0n9;
    for (let o = q - _1n9; o % _2n5 === _0n9; o /= _2n5)
      l += _1n9;
    const c1 = l;
    const _2n_pow_c1_1 = _2n5 << c1 - _1n9 - _1n9;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n5;
    const c2 = (q - _1n9) / _2n_pow_c1;
    const c3 = (c2 - _1n9) / _2n5;
    const c4 = _2n_pow_c1 - _1n9;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp2.pow(Z, c2);
    const c7 = Fp2.pow(Z, (c2 + _1n9) / _2n5);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp2.pow(v, c4);
      let tv3 = Fp2.sqr(tv2);
      tv3 = Fp2.mul(tv3, v);
      let tv5 = Fp2.mul(u, tv3);
      tv5 = Fp2.pow(tv5, c3);
      tv5 = Fp2.mul(tv5, tv2);
      tv2 = Fp2.mul(tv5, v);
      tv3 = Fp2.mul(tv5, u);
      let tv4 = Fp2.mul(tv3, tv2);
      tv5 = Fp2.pow(tv4, c5);
      let isQR = Fp2.eql(tv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, c7);
      tv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, isQR);
      tv4 = Fp2.cmov(tv5, tv4, isQR);
      for (let i = c1; i > _1n9; i--) {
        let tv52 = i - _2n5;
        tv52 = _2n5 << tv52 - _1n9;
        let tvv5 = Fp2.pow(tv4, tv52);
        const e1 = Fp2.eql(tvv5, Fp2.ONE);
        tv2 = Fp2.mul(tv3, tv1);
        tv1 = Fp2.mul(tv1, tv1);
        tvv5 = Fp2.mul(tv4, tv1);
        tv3 = Fp2.cmov(tv2, tv3, e1);
        tv4 = Fp2.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp2.ORDER % _4n4 === _3n4) {
      const c12 = (Fp2.ORDER - _3n4) / _4n4;
      const c22 = Fp2.sqrt(Fp2.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp2.sqr(v);
        const tv2 = Fp2.mul(u, v);
        tv1 = Fp2.mul(tv1, tv2);
        let y1 = Fp2.pow(tv1, c12);
        y1 = Fp2.mul(y1, tv2);
        const y2 = Fp2.mul(y1, c22);
        const tv3 = Fp2.mul(Fp2.sqr(y1), v);
        const isQR = Fp2.eql(tv3, u);
        let y = Fp2.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp2, opts) {
    validateField2(Fp2);
    const { A, B, Z } = opts;
    if (!Fp2.isValid(A) || !Fp2.isValid(B) || !Fp2.isValid(Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp2, Z);
    if (!Fp2.isOdd)
      throw new Error("Field does not have .isOdd()");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp2.sqr(u);
      tv1 = Fp2.mul(tv1, Z);
      tv2 = Fp2.sqr(tv1);
      tv2 = Fp2.add(tv2, tv1);
      tv3 = Fp2.add(tv2, Fp2.ONE);
      tv3 = Fp2.mul(tv3, B);
      tv4 = Fp2.cmov(Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
      tv4 = Fp2.mul(tv4, A);
      tv2 = Fp2.sqr(tv3);
      tv6 = Fp2.sqr(tv4);
      tv5 = Fp2.mul(tv6, A);
      tv2 = Fp2.add(tv2, tv5);
      tv2 = Fp2.mul(tv2, tv3);
      tv6 = Fp2.mul(tv6, tv4);
      tv5 = Fp2.mul(tv6, B);
      tv2 = Fp2.add(tv2, tv5);
      x = Fp2.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp2.mul(tv1, u);
      y = Fp2.mul(y, value);
      x = Fp2.cmov(x, tv3, isValid);
      y = Fp2.cmov(y, value, isValid);
      const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
      y = Fp2.cmov(Fp2.neg(y), y, e1);
      const tv4_inv = FpInvertBatch2(Fp2, [tv4], true)[0];
      x = Fp2.mul(x, tv4_inv);
      return { x, y };
    };
  }
  var DERErr2, DER2, _0n9, _1n9, _2n5, _3n4, _4n4;
  var init_weierstrass2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_hmac();
      init_utils6();
      init_curve2();
      init_modular2();
      DERErr2 = class extends Error {
        constructor(m = "") {
          super(m);
        }
      };
      DER2 = {
        // asn.1 DER encoding utils
        Err: DERErr2,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: (tag, data) => {
            const { Err: E } = DER2;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length & 1)
              throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = numberToHexUnpadded2(dataLen);
            if (len.length / 2 & 128)
              throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
            const t = numberToHexUnpadded2(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
            const { Err: E } = DER2;
            let pos = 0;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag)
              throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128);
            let length = 0;
            if (!isLong)
              length = first;
            else {
              const lenLen = first & 127;
              if (!lenLen)
                throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4)
                throw new E("tlv.decode(long): byte length is too big");
              const lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen)
                throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0)
                throw new E("tlv.decode(long): zero leftmost byte");
              for (const b of lengthBytes)
                length = length << 8 | b;
              pos += lenLen;
              if (length < 128)
                throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
              throw new E("tlv.decode: wrong value length");
            return { v, l: data.subarray(pos + length) };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode(num2) {
            const { Err: E } = DER2;
            if (num2 < _0n9)
              throw new E("integer: negative integers are not allowed");
            let hex = numberToHexUnpadded2(num2);
            if (Number.parseInt(hex[0], 16) & 8)
              hex = "00" + hex;
            if (hex.length & 1)
              throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex;
          },
          decode(data) {
            const { Err: E } = DER2;
            if (data[0] & 128)
              throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128))
              throw new E("invalid signature integer: unnecessary leading zero");
            return bytesToNumberBE2(data);
          }
        },
        toSig(hex) {
          const { Err: E, _int: int, _tlv: tlv } = DER2;
          const data = ensureBytes2("signature", hex);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
          if (seqLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
          if (sLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
        },
        hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = DER2;
          const rs = tlv.encode(2, int.encode(sig.r));
          const ss = tlv.encode(2, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };
      _0n9 = BigInt(0);
      _1n9 = BigInt(1);
      _2n5 = BigInt(2);
      _3n4 = BigInt(3);
      _4n4 = BigInt(4);
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve2(curveDef, defHash) {
    const create2 = (hash2) => weierstrass2({ ...curveDef, hash: hash2 });
    return { ...create2(defHash), create: create2 };
  }
  var init_shortw_utils2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_weierstrass2();
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
  function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length)
      throw new Error("invalid I2OSP input: " + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
      arr[i] = a[i] ^ b[i];
    }
    return arr;
  }
  function anum(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    abytes(msg);
    abytes(DST);
    anum(lenInBytes);
    if (DST.length > 255)
      DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
      throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
      const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
      b[i] = H(concatBytes(...args));
    }
    const pseudo_random_bytes = concatBytes(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    abytes(msg);
    abytes(DST);
    anum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    _validateObject(options, {
      p: "bigint",
      m: "number",
      k: "number",
      hash: "function"
    });
    const { p, k, m, hash: hash2, expand: expand2, DST: _DST } = options;
    if (!isBytes(_DST) && typeof _DST !== "string")
      throw new Error("DST must be string or uint8array");
    if (!isHash(options.hash))
      throw new Error("expected valid hash");
    abytes(msg);
    anum(count);
    const DST = typeof _DST === "string" ? utf8ToBytes(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand2 === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
    } else if (expand2 === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
    } else if (expand2 === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
      const e = new Array(m);
      for (let j = 0; j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = mod2(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      const [xd_inv, yd_inv] = FpInvertBatch2(field, [xd, yd], true);
      x = field.mul(xn, xd_inv);
      y = field.mul(y, field.mul(yn, yd_inv));
      return { x, y };
    };
  }
  function createHasher2(Point2, mapToCurve, defaults) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    function map(num2) {
      return Point2.fromAffine(mapToCurve(num2));
    }
    function clear(initial) {
      const P = initial.clearCofactor();
      if (P.equals(Point2.ZERO))
        return Point2.ZERO;
      P.assertValidity();
      return P;
    }
    return {
      defaults,
      hashToCurve(msg, options) {
        const dst = defaults.DST ? defaults.DST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 2, opts);
        const u0 = map(u[0]);
        const u1 = map(u[1]);
        return clear(u0.add(u1));
      },
      encodeToCurve(msg, options) {
        const dst = defaults.encodeDST ? defaults.encodeDST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 1, opts);
        return clear(map(u[0]));
      },
      /** See {@link H2CHasher} */
      mapToCurve(scalars) {
        if (!Array.isArray(scalars))
          throw new Error("expected array of bigints");
        for (const i of scalars)
          if (typeof i !== "bigint")
            throw new Error("expected array of bigints");
        return clear(map(scalars));
      }
    };
  }
  var os2ip;
  var init_hash_to_curve = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
      init_utils6();
      init_modular2();
      os2ip = bytesToNumberBE2;
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_exports = {};
  __export(secp256k1_exports, {
    encodeToCurve: () => encodeToCurve,
    hashToCurve: () => hashToCurve,
    schnorr: () => schnorr,
    secp256k1: () => secp256k1,
    secp256k1_hasher: () => secp256k1_hasher
  });
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow22(b3, _3n6, P) * b3 % P;
    const b9 = pow22(b6, _3n6, P) * b3 % P;
    const b11 = pow22(b9, _2n6, P) * b2 % P;
    const b22 = pow22(b11, _11n, P) * b11 % P;
    const b44 = pow22(b22, _22n, P) * b22 % P;
    const b88 = pow22(b44, _44n, P) * b44 % P;
    const b176 = pow22(b88, _88n, P) * b88 % P;
    const b220 = pow22(b176, _44n, P) * b44 % P;
    const b223 = pow22(b220, _3n6, P) * b3 % P;
    const t1 = pow22(b223, _23n, P) * b22 % P;
    const t2 = pow22(t1, _6n, P) * b2 % P;
    const root = pow22(t2, _2n6, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return sha256(concatBytes(tagP, ...messages));
  }
  function schnorrGetExtPubKey(priv) {
    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point.fromPrivateKey(d_);
    const scalar = hasEven(p.y) ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p) };
  }
  function lift_x(x) {
    aInRange2("x", x, _1n10, secp256k1_CURVE.p);
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (!hasEven(y))
      y = modP(-y);
    const p = Point.fromAffine({ x, y });
    p.assertValidity();
    return p;
  }
  function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
    const m = ensureBytes2("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = ensureBytes2("auxRand", auxRand, 32);
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN(num(rand));
    if (k_ === _0n10)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const sig = ensureBytes2("signature", signature, 64);
    const m = ensureBytes2("message", message);
    const pub = ensureBytes2("publicKey", publicKey, 32);
    try {
      const P = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!inRange2(r, _1n10, secp256k1_CURVE.p))
        return false;
      const s = num(sig.subarray(32, 64));
      if (!inRange2(s, _1n10, secp256k1_CURVE.n))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
      const { x, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  var secp256k1_CURVE, _0n10, _1n10, _2n6, divNearest, Fpk1, secp256k1, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point, hasEven, num, schnorr, isoMap, mapSWU, secp256k1_hasher, hashToCurve, encodeToCurve;
  var init_secp256k1 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js"() {
      init_sha2();
      init_utils2();
      init_shortw_utils2();
      init_hash_to_curve();
      init_modular2();
      init_weierstrass2();
      init_utils6();
      secp256k1_CURVE = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
      };
      _0n10 = BigInt(0);
      _1n10 = BigInt(1);
      _2n6 = BigInt(2);
      divNearest = (a, b) => (a + b / _2n6) / b;
      Fpk1 = Field2(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
      secp256k1 = createCurve2({
        ...secp256k1_CURVE,
        Fp: Fpk1,
        lowS: true,
        // Allow only low-S signatures by default in sign() and verify()
        endo: {
          // Endomorphism, see above
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k) => {
            const n = secp256k1_CURVE.n;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n10 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = mod2(k - c1 * a1 - c2 * a2, n);
            let k2 = mod2(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
              k1 = n - k1;
            if (k2neg)
              k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k);
            }
            return { k1neg, k1, k2neg, k2 };
          }
        }
      }, sha256);
      TAGGED_HASH_PREFIXES = {};
      pointToBytes = (point) => point.toBytes(true).slice(1);
      numTo32b = (n) => numberToBytesBE2(n, 32);
      modP = (x) => mod2(x, secp256k1_CURVE.p);
      modN = (x) => mod2(x, secp256k1_CURVE.n);
      Point = /* @__PURE__ */ (() => secp256k1.Point)();
      hasEven = (y) => y % _2n6 === _0n10;
      num = bytesToNumberBE2;
      schnorr = /* @__PURE__ */ (() => ({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
          randomPrivateKey: secp256k1.utils.randomPrivateKey,
          lift_x,
          pointToBytes,
          numberToBytesBE: numberToBytesBE2,
          bytesToNumberBE: bytesToNumberBE2,
          taggedHash,
          mod: mod2
        }
      }))();
      isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
        // xNum
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ],
        // yNum
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ]
      ].map((i) => i.map((j) => BigInt(j)))))();
      mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fpk1.create(BigInt("-11"))
      }))();
      secp256k1_hasher = /* @__PURE__ */ (() => createHasher2(secp256k1.Point, (scalars) => {
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha256
      }))();
      hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();
      encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverPublicKey.js
  async function recoverPublicKey({ hash: hash2, signature }) {
    const hashHex = isHex(hash2) ? hash2 : toHex2(hash2);
    const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), secp256k1_exports));
    const signature_ = (() => {
      if (typeof signature === "object" && "r" in signature && "s" in signature) {
        const { r, s, v, yParity } = signature;
        const yParityOrV2 = Number(yParity ?? v);
        const recoveryBit2 = toRecoveryBit(yParityOrV2);
        return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
      }
      const signatureHex = isHex(signature) ? signature : toHex2(signature);
      if (size(signatureHex) !== 65)
        throw new Error("invalid signature length");
      const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
      const recoveryBit = toRecoveryBit(yParityOrV);
      return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
    return `0x${publicKey}`;
  }
  function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1)
      return yParityOrV;
    if (yParityOrV === 27)
      return 0;
    if (yParityOrV === 28)
      return 1;
    throw new Error("Invalid yParityOrV value");
  }
  var init_recoverPublicKey = __esm({
    "node_modules/viem/_esm/utils/signature/recoverPublicKey.js"() {
      init_isHex();
      init_size();
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverAddress.js
  async function recoverAddress({ hash: hash2, signature }) {
    return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));
  }
  var init_recoverAddress = __esm({
    "node_modules/viem/_esm/utils/signature/recoverAddress.js"() {
      init_publicKeyToAddress();
      init_recoverPublicKey();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toRlp.js
  function toRlp(bytes, to = "hex") {
    const encodable = getEncodable(bytes);
    const cursor = createCursor(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === "hex")
      return bytesToHex3(cursor.bytes);
    return cursor.bytes;
  }
  function bytesToRlp(bytes, to = "bytes") {
    return toRlp(bytes, to);
  }
  function hexToRlp(hex, to = "hex") {
    return toRlp(hex, to);
  }
  function getEncodable(bytes) {
    if (Array.isArray(bytes))
      return getEncodableList(bytes.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes);
  }
  function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
      if (bodyLength <= 55)
        return 1 + bodyLength;
      return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
      length,
      encode(cursor) {
        if (bodyLength <= 55) {
          cursor.pushByte(192 + bodyLength);
        } else {
          cursor.pushByte(192 + 55 + sizeOfBodyLength);
          if (sizeOfBodyLength === 1)
            cursor.pushUint8(bodyLength);
          else if (sizeOfBodyLength === 2)
            cursor.pushUint16(bodyLength);
          else if (sizeOfBodyLength === 3)
            cursor.pushUint24(bodyLength);
          else
            cursor.pushUint32(bodyLength);
        }
        for (const { encode: encode5 } of list) {
          encode5(cursor);
        }
      }
    };
  }
  function getEncodableBytes(bytesOrHex) {
    const bytes = typeof bytesOrHex === "string" ? hexToBytes3(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes.length);
    const length = (() => {
      if (bytes.length === 1 && bytes[0] < 128)
        return 1;
      if (bytes.length <= 55)
        return 1 + bytes.length;
      return 1 + sizeOfBytesLength + bytes.length;
    })();
    return {
      length,
      encode(cursor) {
        if (bytes.length === 1 && bytes[0] < 128) {
          cursor.pushBytes(bytes);
        } else if (bytes.length <= 55) {
          cursor.pushByte(128 + bytes.length);
          cursor.pushBytes(bytes);
        } else {
          cursor.pushByte(128 + 55 + sizeOfBytesLength);
          if (sizeOfBytesLength === 1)
            cursor.pushUint8(bytes.length);
          else if (sizeOfBytesLength === 2)
            cursor.pushUint16(bytes.length);
          else if (sizeOfBytesLength === 3)
            cursor.pushUint24(bytes.length);
          else
            cursor.pushUint32(bytes.length);
          cursor.pushBytes(bytes);
        }
      }
    };
  }
  function getSizeOfLength(length) {
    if (length < 2 ** 8)
      return 1;
    if (length < 2 ** 16)
      return 2;
    if (length < 2 ** 24)
      return 3;
    if (length < 2 ** 32)
      return 4;
    throw new BaseError2("Length is too large.");
  }
  var init_toRlp = __esm({
    "node_modules/viem/_esm/utils/encoding/toRlp.js"() {
      init_base2();
      init_cursor2();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/authorization/hashAuthorization.js
  function hashAuthorization(parameters) {
    const { chainId, nonce, to } = parameters;
    const address = parameters.contractAddress ?? parameters.address;
    const hash2 = keccak256(concatHex([
      "0x05",
      toRlp([
        chainId ? numberToHex(chainId) : "0x",
        address,
        nonce ? numberToHex(nonce) : "0x"
      ])
    ]));
    if (to === "bytes")
      return hexToBytes3(hash2);
    return hash2;
  }
  var init_hashAuthorization = __esm({
    "node_modules/viem/_esm/utils/authorization/hashAuthorization.js"() {
      init_concat();
      init_toBytes();
      init_toHex();
      init_toRlp();
      init_keccak256();
    }
  });

  // node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js
  async function recoverAuthorizationAddress(parameters) {
    const { authorization, signature } = parameters;
    return recoverAddress({
      hash: hashAuthorization(authorization),
      signature: signature ?? authorization
    });
  }
  var init_recoverAuthorizationAddress = __esm({
    "node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js"() {
      init_recoverAddress();
      init_hashAuthorization();
    }
  });

  // node_modules/viem/_esm/errors/estimateGas.js
  var EstimateGasExecutionError;
  var init_estimateGas = __esm({
    "node_modules/viem/_esm/errors/estimateGas.js"() {
      init_formatEther();
      init_formatGwei();
      init_base2();
      init_transaction();
      EstimateGasExecutionError = class extends BaseError2 {
        constructor(cause, { account, docsPath: docsPath9, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath9,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Estimate Gas Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "EstimateGasExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/node.js
  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
  var init_node = __esm({
    "node_modules/viem/_esm/errors/node.js"() {
      init_formatGwei();
      init_base2();
      ExecutionRevertedError = class extends BaseError2 {
        constructor({ cause, message } = {}) {
          const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
          super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause,
            name: "ExecutionRevertedError"
          });
        }
      };
      Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
      });
      FeeCapTooHighError = class extends BaseError2 {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause,
            name: "FeeCapTooHighError"
          });
        }
      };
      Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
      });
      FeeCapTooLowError = class extends BaseError2 {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause,
            name: "FeeCapTooLowError"
          });
        }
      };
      Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
      });
      NonceTooHighError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
        }
      };
      Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
      });
      NonceTooLowError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
          ].join("\n"), { cause, name: "NonceTooLowError" });
        }
      };
      Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported|already known/
      });
      NonceMaxValueError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
        }
      };
      Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
      });
      InsufficientFundsError = class extends BaseError2 {
        constructor({ cause } = {}) {
          super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
          ].join("\n"), {
            cause,
            metaMessages: [
              "This error could arise when the account does not have enough funds to:",
              " - pay for the total gas fee,",
              " - pay for the value to send.",
              " ",
              "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
              " - `gas` is the amount of gas needed for transaction to execute,",
              " - `gas fee` is the gas fee,",
              " - `value` is the amount of ether to send to the recipient."
            ],
            name: "InsufficientFundsError"
          });
        }
      };
      Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds|exceeds transaction sender account balance/
      });
      IntrinsicGasTooHighError = class extends BaseError2 {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause,
            name: "IntrinsicGasTooHighError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
      });
      IntrinsicGasTooLowError = class extends BaseError2 {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause,
            name: "IntrinsicGasTooLowError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
      });
      TransactionTypeNotSupportedError = class extends BaseError2 {
        constructor({ cause }) {
          super("The transaction type is not supported for this chain.", {
            cause,
            name: "TransactionTypeNotSupportedError"
          });
        }
      };
      Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
      });
      TipAboveFeeCapError = class extends BaseError2 {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
          super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
          ].join("\n"), {
            cause,
            name: "TipAboveFeeCapError"
          });
        }
      };
      Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
      });
      UnknownNodeError = class extends BaseError2 {
        constructor({ cause }) {
          super(`An error occurred while executing: ${cause?.shortMessage}`, {
            cause,
            name: "UnknownNodeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/errors/getNodeError.js
  function getNodeError(err, args) {
    const message = (err.details || "").toLowerCase();
    const executionRevertedError = err instanceof BaseError2 ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;
    if (executionRevertedError instanceof BaseError2)
      return new ExecutionRevertedError({
        cause: err,
        message: executionRevertedError.details
      });
    if (ExecutionRevertedError.nodeMessage.test(message))
      return new ExecutionRevertedError({
        cause: err,
        message: err.details
      });
    if (FeeCapTooHighError.nodeMessage.test(message))
      return new FeeCapTooHighError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (FeeCapTooLowError.nodeMessage.test(message))
      return new FeeCapTooLowError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (NonceTooHighError.nodeMessage.test(message))
      return new NonceTooHighError({ cause: err, nonce: args?.nonce });
    if (NonceTooLowError.nodeMessage.test(message))
      return new NonceTooLowError({ cause: err, nonce: args?.nonce });
    if (NonceMaxValueError.nodeMessage.test(message))
      return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
    if (InsufficientFundsError.nodeMessage.test(message))
      return new InsufficientFundsError({ cause: err });
    if (IntrinsicGasTooHighError.nodeMessage.test(message))
      return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    if (IntrinsicGasTooLowError.nodeMessage.test(message))
      return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    if (TransactionTypeNotSupportedError.nodeMessage.test(message))
      return new TransactionTypeNotSupportedError({ cause: err });
    if (TipAboveFeeCapError.nodeMessage.test(message))
      return new TipAboveFeeCapError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
      });
    return new UnknownNodeError({
      cause: err
    });
  }
  var init_getNodeError = __esm({
    "node_modules/viem/_esm/utils/errors/getNodeError.js"() {
      init_base2();
      init_node();
    }
  });

  // node_modules/viem/_esm/utils/errors/getEstimateGasError.js
  function getEstimateGasError(err, { docsPath: docsPath9, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new EstimateGasExecutionError(cause, {
      docsPath: docsPath9,
      ...args
    });
  }
  var init_getEstimateGasError = __esm({
    "node_modules/viem/_esm/utils/errors/getEstimateGasError.js"() {
      init_estimateGas();
      init_node();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/utils/formatters/extract.js
  function extract(value_, { format }) {
    if (!format)
      return {};
    const value = {};
    function extract_(formatted2) {
      const keys = Object.keys(formatted2);
      for (const key of keys) {
        if (key in value_)
          value[key] = value_[key];
        if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
          extract_(formatted2[key]);
      }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
  }
  var init_extract = __esm({
    "node_modules/viem/_esm/utils/formatters/extract.js"() {
    }
  });

  // node_modules/viem/_esm/utils/formatters/formatter.js
  function defineFormatter(type, format) {
    return ({ exclude, format: overrides }) => {
      return {
        exclude,
        format: (args) => {
          const formatted = format(args);
          if (exclude) {
            for (const key of exclude) {
              delete formatted[key];
            }
          }
          return {
            ...formatted,
            ...overrides(args)
          };
        },
        type
      };
    };
  }
  var init_formatter = __esm({
    "node_modules/viem/_esm/utils/formatters/formatter.js"() {
    }
  });

  // node_modules/viem/_esm/utils/formatters/transactionRequest.js
  function formatTransactionRequest(request2) {
    const rpcRequest = {};
    if (typeof request2.authorizationList !== "undefined")
      rpcRequest.authorizationList = formatAuthorizationList(request2.authorizationList);
    if (typeof request2.accessList !== "undefined")
      rpcRequest.accessList = request2.accessList;
    if (typeof request2.blobVersionedHashes !== "undefined")
      rpcRequest.blobVersionedHashes = request2.blobVersionedHashes;
    if (typeof request2.blobs !== "undefined") {
      if (typeof request2.blobs[0] !== "string")
        rpcRequest.blobs = request2.blobs.map((x) => bytesToHex3(x));
      else
        rpcRequest.blobs = request2.blobs;
    }
    if (typeof request2.data !== "undefined")
      rpcRequest.data = request2.data;
    if (typeof request2.from !== "undefined")
      rpcRequest.from = request2.from;
    if (typeof request2.gas !== "undefined")
      rpcRequest.gas = numberToHex(request2.gas);
    if (typeof request2.gasPrice !== "undefined")
      rpcRequest.gasPrice = numberToHex(request2.gasPrice);
    if (typeof request2.maxFeePerBlobGas !== "undefined")
      rpcRequest.maxFeePerBlobGas = numberToHex(request2.maxFeePerBlobGas);
    if (typeof request2.maxFeePerGas !== "undefined")
      rpcRequest.maxFeePerGas = numberToHex(request2.maxFeePerGas);
    if (typeof request2.maxPriorityFeePerGas !== "undefined")
      rpcRequest.maxPriorityFeePerGas = numberToHex(request2.maxPriorityFeePerGas);
    if (typeof request2.nonce !== "undefined")
      rpcRequest.nonce = numberToHex(request2.nonce);
    if (typeof request2.to !== "undefined")
      rpcRequest.to = request2.to;
    if (typeof request2.type !== "undefined")
      rpcRequest.type = rpcTransactionType[request2.type];
    if (typeof request2.value !== "undefined")
      rpcRequest.value = numberToHex(request2.value);
    return rpcRequest;
  }
  function formatAuthorizationList(authorizationList) {
    return authorizationList.map((authorization) => ({
      address: authorization.address,
      r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,
      s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,
      chainId: numberToHex(authorization.chainId),
      nonce: numberToHex(authorization.nonce),
      ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
      ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
    }));
  }
  var rpcTransactionType, defineTransactionRequest;
  var init_transactionRequest = __esm({
    "node_modules/viem/_esm/utils/formatters/transactionRequest.js"() {
      init_toHex();
      init_formatter();
      rpcTransactionType = {
        legacy: "0x0",
        eip2930: "0x1",
        eip1559: "0x2",
        eip4844: "0x3",
        eip7702: "0x4"
      };
      defineTransactionRequest = /* @__PURE__ */ defineFormatter("transactionRequest", formatTransactionRequest);
    }
  });

  // node_modules/viem/_esm/utils/stateOverride.js
  function serializeStateMapping(stateMapping) {
    if (!stateMapping || stateMapping.length === 0)
      return void 0;
    return stateMapping.reduce((acc, { slot, value }) => {
      if (slot.length !== 66)
        throw new InvalidBytesLengthError({
          size: slot.length,
          targetSize: 66,
          type: "hex"
        });
      if (value.length !== 66)
        throw new InvalidBytesLengthError({
          size: value.length,
          targetSize: 66,
          type: "hex"
        });
      acc[slot] = value;
      return acc;
    }, {});
  }
  function serializeAccountStateOverride(parameters) {
    const { balance, nonce, state, stateDiff, code } = parameters;
    const rpcAccountStateOverride = {};
    if (code !== void 0)
      rpcAccountStateOverride.code = code;
    if (balance !== void 0)
      rpcAccountStateOverride.balance = numberToHex(balance);
    if (nonce !== void 0)
      rpcAccountStateOverride.nonce = numberToHex(nonce);
    if (state !== void 0)
      rpcAccountStateOverride.state = serializeStateMapping(state);
    if (stateDiff !== void 0) {
      if (rpcAccountStateOverride.state)
        throw new StateAssignmentConflictError();
      rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
    }
    return rpcAccountStateOverride;
  }
  function serializeStateOverride(parameters) {
    if (!parameters)
      return void 0;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of parameters) {
      if (!isAddress(address, { strict: false }))
        throw new InvalidAddressError({ address });
      if (rpcStateOverride[address])
        throw new AccountStateConflictError({ address });
      rpcStateOverride[address] = serializeAccountStateOverride(accountState);
    }
    return rpcStateOverride;
  }
  var init_stateOverride2 = __esm({
    "node_modules/viem/_esm/utils/stateOverride.js"() {
      init_address();
      init_data();
      init_stateOverride();
      init_isAddress();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/constants/number.js
  var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
  var init_number = __esm({
    "node_modules/viem/_esm/constants/number.js"() {
      maxInt8 = 2n ** (8n - 1n) - 1n;
      maxInt16 = 2n ** (16n - 1n) - 1n;
      maxInt24 = 2n ** (24n - 1n) - 1n;
      maxInt32 = 2n ** (32n - 1n) - 1n;
      maxInt40 = 2n ** (40n - 1n) - 1n;
      maxInt48 = 2n ** (48n - 1n) - 1n;
      maxInt56 = 2n ** (56n - 1n) - 1n;
      maxInt64 = 2n ** (64n - 1n) - 1n;
      maxInt72 = 2n ** (72n - 1n) - 1n;
      maxInt80 = 2n ** (80n - 1n) - 1n;
      maxInt88 = 2n ** (88n - 1n) - 1n;
      maxInt96 = 2n ** (96n - 1n) - 1n;
      maxInt104 = 2n ** (104n - 1n) - 1n;
      maxInt112 = 2n ** (112n - 1n) - 1n;
      maxInt120 = 2n ** (120n - 1n) - 1n;
      maxInt128 = 2n ** (128n - 1n) - 1n;
      maxInt136 = 2n ** (136n - 1n) - 1n;
      maxInt144 = 2n ** (144n - 1n) - 1n;
      maxInt152 = 2n ** (152n - 1n) - 1n;
      maxInt160 = 2n ** (160n - 1n) - 1n;
      maxInt168 = 2n ** (168n - 1n) - 1n;
      maxInt176 = 2n ** (176n - 1n) - 1n;
      maxInt184 = 2n ** (184n - 1n) - 1n;
      maxInt192 = 2n ** (192n - 1n) - 1n;
      maxInt200 = 2n ** (200n - 1n) - 1n;
      maxInt208 = 2n ** (208n - 1n) - 1n;
      maxInt216 = 2n ** (216n - 1n) - 1n;
      maxInt224 = 2n ** (224n - 1n) - 1n;
      maxInt232 = 2n ** (232n - 1n) - 1n;
      maxInt240 = 2n ** (240n - 1n) - 1n;
      maxInt248 = 2n ** (248n - 1n) - 1n;
      maxInt256 = 2n ** (256n - 1n) - 1n;
      minInt8 = -(2n ** (8n - 1n));
      minInt16 = -(2n ** (16n - 1n));
      minInt24 = -(2n ** (24n - 1n));
      minInt32 = -(2n ** (32n - 1n));
      minInt40 = -(2n ** (40n - 1n));
      minInt48 = -(2n ** (48n - 1n));
      minInt56 = -(2n ** (56n - 1n));
      minInt64 = -(2n ** (64n - 1n));
      minInt72 = -(2n ** (72n - 1n));
      minInt80 = -(2n ** (80n - 1n));
      minInt88 = -(2n ** (88n - 1n));
      minInt96 = -(2n ** (96n - 1n));
      minInt104 = -(2n ** (104n - 1n));
      minInt112 = -(2n ** (112n - 1n));
      minInt120 = -(2n ** (120n - 1n));
      minInt128 = -(2n ** (128n - 1n));
      minInt136 = -(2n ** (136n - 1n));
      minInt144 = -(2n ** (144n - 1n));
      minInt152 = -(2n ** (152n - 1n));
      minInt160 = -(2n ** (160n - 1n));
      minInt168 = -(2n ** (168n - 1n));
      minInt176 = -(2n ** (176n - 1n));
      minInt184 = -(2n ** (184n - 1n));
      minInt192 = -(2n ** (192n - 1n));
      minInt200 = -(2n ** (200n - 1n));
      minInt208 = -(2n ** (208n - 1n));
      minInt216 = -(2n ** (216n - 1n));
      minInt224 = -(2n ** (224n - 1n));
      minInt232 = -(2n ** (232n - 1n));
      minInt240 = -(2n ** (240n - 1n));
      minInt248 = -(2n ** (248n - 1n));
      minInt256 = -(2n ** (256n - 1n));
      maxUint8 = 2n ** 8n - 1n;
      maxUint16 = 2n ** 16n - 1n;
      maxUint24 = 2n ** 24n - 1n;
      maxUint32 = 2n ** 32n - 1n;
      maxUint40 = 2n ** 40n - 1n;
      maxUint48 = 2n ** 48n - 1n;
      maxUint56 = 2n ** 56n - 1n;
      maxUint64 = 2n ** 64n - 1n;
      maxUint72 = 2n ** 72n - 1n;
      maxUint80 = 2n ** 80n - 1n;
      maxUint88 = 2n ** 88n - 1n;
      maxUint96 = 2n ** 96n - 1n;
      maxUint104 = 2n ** 104n - 1n;
      maxUint112 = 2n ** 112n - 1n;
      maxUint120 = 2n ** 120n - 1n;
      maxUint128 = 2n ** 128n - 1n;
      maxUint136 = 2n ** 136n - 1n;
      maxUint144 = 2n ** 144n - 1n;
      maxUint152 = 2n ** 152n - 1n;
      maxUint160 = 2n ** 160n - 1n;
      maxUint168 = 2n ** 168n - 1n;
      maxUint176 = 2n ** 176n - 1n;
      maxUint184 = 2n ** 184n - 1n;
      maxUint192 = 2n ** 192n - 1n;
      maxUint200 = 2n ** 200n - 1n;
      maxUint208 = 2n ** 208n - 1n;
      maxUint216 = 2n ** 216n - 1n;
      maxUint224 = 2n ** 224n - 1n;
      maxUint232 = 2n ** 232n - 1n;
      maxUint240 = 2n ** 240n - 1n;
      maxUint248 = 2n ** 248n - 1n;
      maxUint256 = 2n ** 256n - 1n;
    }
  });

  // node_modules/viem/_esm/utils/transaction/assertRequest.js
  function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (account && !isAddress(account.address))
      throw new InvalidAddressError({ address: account.address });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
      throw new FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  var init_assertRequest = __esm({
    "node_modules/viem/_esm/utils/transaction/assertRequest.js"() {
      init_parseAccount();
      init_number();
      init_address();
      init_node();
      init_transaction();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/errors/fee.js
  var BaseFeeScalarError, Eip1559FeesNotSupportedError, MaxFeePerGasTooLowError;
  var init_fee = __esm({
    "node_modules/viem/_esm/errors/fee.js"() {
      init_formatGwei();
      init_base2();
      BaseFeeScalarError = class extends BaseError2 {
        constructor() {
          super("`baseFeeMultiplier` must be greater than 1.", {
            name: "BaseFeeScalarError"
          });
        }
      };
      Eip1559FeesNotSupportedError = class extends BaseError2 {
        constructor() {
          super("Chain does not support EIP-1559 fees.", {
            name: "Eip1559FeesNotSupportedError"
          });
        }
      };
      MaxFeePerGasTooLowError = class extends BaseError2 {
        constructor({ maxPriorityFeePerGas }) {
          super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/block.js
  var BlockNotFoundError;
  var init_block = __esm({
    "node_modules/viem/_esm/errors/block.js"() {
      init_base2();
      BlockNotFoundError = class extends BaseError2 {
        constructor({ blockHash, blockNumber }) {
          let identifier = "Block";
          if (blockHash)
            identifier = `Block at hash "${blockHash}"`;
          if (blockNumber)
            identifier = `Block at number "${blockNumber}"`;
          super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/formatters/transaction.js
  function formatTransaction(transaction) {
    const transaction_ = {
      ...transaction,
      blockHash: transaction.blockHash ? transaction.blockHash : null,
      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
      chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
      gas: transaction.gas ? BigInt(transaction.gas) : void 0,
      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
      maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
      nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
      to: transaction.to ? transaction.to : null,
      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
      type: transaction.type ? transactionType[transaction.type] : void 0,
      typeHex: transaction.type ? transaction.type : void 0,
      value: transaction.value ? BigInt(transaction.value) : void 0,
      v: transaction.v ? BigInt(transaction.v) : void 0
    };
    if (transaction.authorizationList)
      transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
    transaction_.yParity = (() => {
      if (transaction.yParity)
        return Number(transaction.yParity);
      if (typeof transaction_.v === "bigint") {
        if (transaction_.v === 0n || transaction_.v === 27n)
          return 0;
        if (transaction_.v === 1n || transaction_.v === 28n)
          return 1;
        if (transaction_.v >= 35n)
          return transaction_.v % 2n === 0n ? 1 : 0;
      }
      return void 0;
    })();
    if (transaction_.type === "legacy") {
      delete transaction_.accessList;
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
      delete transaction_.yParity;
    }
    if (transaction_.type === "eip2930") {
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === "eip1559") {
      delete transaction_.maxFeePerBlobGas;
    }
    return transaction_;
  }
  function formatAuthorizationList2(authorizationList) {
    return authorizationList.map((authorization) => ({
      address: authorization.address,
      chainId: Number(authorization.chainId),
      nonce: Number(authorization.nonce),
      r: authorization.r,
      s: authorization.s,
      yParity: Number(authorization.yParity)
    }));
  }
  var transactionType, defineTransaction;
  var init_transaction2 = __esm({
    "node_modules/viem/_esm/utils/formatters/transaction.js"() {
      init_fromHex();
      init_formatter();
      transactionType = {
        "0x0": "legacy",
        "0x1": "eip2930",
        "0x2": "eip1559",
        "0x3": "eip4844",
        "0x4": "eip7702"
      };
      defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
    }
  });

  // node_modules/viem/_esm/utils/formatters/block.js
  function formatBlock(block) {
    const transactions = (block.transactions ?? []).map((transaction) => {
      if (typeof transaction === "string")
        return transaction;
      return formatTransaction(transaction);
    });
    return {
      ...block,
      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
      blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
      difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
      excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
      hash: block.hash ? block.hash : null,
      logsBloom: block.logsBloom ? block.logsBloom : null,
      nonce: block.nonce ? block.nonce : null,
      number: block.number ? BigInt(block.number) : null,
      size: block.size ? BigInt(block.size) : void 0,
      timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
      transactions,
      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
  }
  var defineBlock;
  var init_block2 = __esm({
    "node_modules/viem/_esm/utils/formatters/block.js"() {
      init_formatter();
      init_transaction2();
      defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);
    }
  });

  // node_modules/viem/_esm/actions/public/getBlock.js
  async function getBlock(client, { blockHash, blockNumber, blockTag = client.experimental_blockTag ?? "latest", includeTransactions: includeTransactions_ } = {}) {
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let block = null;
    if (blockHash) {
      block = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      }, { dedupe: true });
    } else {
      block = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!block)
      throw new BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || formatBlock;
    return format(block);
  }
  var init_getBlock = __esm({
    "node_modules/viem/_esm/actions/public/getBlock.js"() {
      init_block();
      init_toHex();
      init_block2();
    }
  });

  // node_modules/viem/_esm/actions/public/getGasPrice.js
  async function getGasPrice(client) {
    const gasPrice = await client.request({
      method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
  }
  var init_getGasPrice = __esm({
    "node_modules/viem/_esm/actions/public/getGasPrice.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
  async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas(client, args);
  }
  async function internal_estimateMaxPriorityFeePerGas(client, args) {
    const { block: block_, chain = client.chain, request: request2 } = args || {};
    try {
      const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
      if (typeof maxPriorityFeePerGas === "function") {
        const block = block_ || await getAction(client, getBlock, "getBlock")({});
        const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
          block,
          client,
          request: request2
        });
        if (maxPriorityFeePerGas_ === null)
          throw new Error();
        return maxPriorityFeePerGas_;
      }
      if (typeof maxPriorityFeePerGas !== "undefined")
        return maxPriorityFeePerGas;
      const maxPriorityFeePerGasHex = await client.request({
        method: "eth_maxPriorityFeePerGas"
      });
      return hexToBigInt(maxPriorityFeePerGasHex);
    } catch {
      const [block, gasPrice] = await Promise.all([
        block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
        getAction(client, getGasPrice, "getGasPrice")({})
      ]);
      if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
      const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
      if (maxPriorityFeePerGas < 0n)
        return 0n;
      return maxPriorityFeePerGas;
    }
  }
  var init_estimateMaxPriorityFeePerGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js"() {
      init_fee();
      init_fromHex();
      init_getAction();
      init_getBlock();
      init_getGasPrice();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
  async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas(client, args);
  }
  async function internal_estimateFeesPerGas(client, args) {
    const { block: block_, chain = client.chain, request: request2, type = "eip1559" } = args || {};
    const baseFeeMultiplier = await (async () => {
      if (typeof chain?.fees?.baseFeeMultiplier === "function")
        return chain.fees.baseFeeMultiplier({
          block: block_,
          client,
          request: request2
        });
      return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1)
      throw new BaseFeeScalarError();
    const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base2) => base2 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
    if (typeof chain?.fees?.estimateFeesPerGas === "function") {
      const fees = await chain.fees.estimateFeesPerGas({
        block: block_,
        client,
        multiply,
        request: request2,
        type
      });
      if (fees !== null)
        return fees;
    }
    if (type === "eip1559") {
      if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
      const maxPriorityFeePerGas = typeof request2?.maxPriorityFeePerGas === "bigint" ? request2.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
        block,
        chain,
        request: request2
      });
      const baseFeePerGas = multiply(block.baseFeePerGas);
      const maxFeePerGas = request2?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    }
    const gasPrice = request2?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
    return {
      gasPrice
    };
  }
  var init_estimateFeesPerGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateFeesPerGas.js"() {
      init_fee();
      init_getAction();
      init_estimateMaxPriorityFeePerGas();
      init_getBlock();
      init_getGasPrice();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionCount.js
  async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
      method: "eth_getTransactionCount",
      params: [
        address,
        typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
      ]
    }, {
      dedupe: Boolean(blockNumber)
    });
    return hexToNumber2(count);
  }
  var init_getTransactionCount = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionCount.js"() {
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/blobsToCommitments.js
  function blobsToCommitments(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes3(x)) : parameters.blobs;
    const commitments = [];
    for (const blob of blobs)
      commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
    return to === "bytes" ? commitments : commitments.map((x) => bytesToHex3(x));
  }
  var init_blobsToCommitments = __esm({
    "node_modules/viem/_esm/utils/blob/blobsToCommitments.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/blobsToProofs.js
  function blobsToProofs(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes3(x)) : parameters.blobs;
    const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes3(x)) : parameters.commitments;
    const proofs = [];
    for (let i = 0; i < blobs.length; i++) {
      const blob = blobs[i];
      const commitment = commitments[i];
      proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
    }
    return to === "bytes" ? proofs : proofs.map((x) => bytesToHex3(x));
  }
  var init_blobsToProofs = __esm({
    "node_modules/viem/_esm/utils/blob/blobsToProofs.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/@noble/hashes/esm/sha256.js
  var sha2562;
  var init_sha256 = __esm({
    "node_modules/@noble/hashes/esm/sha256.js"() {
      init_sha2();
      sha2562 = sha256;
    }
  });

  // node_modules/viem/_esm/utils/hash/sha256.js
  function sha2563(value, to_) {
    const to = to_ || "hex";
    const bytes = sha2562(isHex(value, { strict: false }) ? toBytes2(value) : value);
    if (to === "bytes")
      return bytes;
    return toHex2(bytes);
  }
  var init_sha2562 = __esm({
    "node_modules/viem/_esm/utils/hash/sha256.js"() {
      init_sha256();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
  function commitmentToVersionedHash(parameters) {
    const { commitment, version: version4 = 1 } = parameters;
    const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
    const versionedHash = sha2563(commitment, "bytes");
    versionedHash.set([version4], 0);
    return to === "bytes" ? versionedHash : bytesToHex3(versionedHash);
  }
  var init_commitmentToVersionedHash = __esm({
    "node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js"() {
      init_toHex();
      init_sha2562();
    }
  });

  // node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
  function commitmentsToVersionedHashes(parameters) {
    const { commitments, version: version4 } = parameters;
    const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
    const hashes = [];
    for (const commitment of commitments) {
      hashes.push(commitmentToVersionedHash({
        commitment,
        to,
        version: version4
      }));
    }
    return hashes;
  }
  var init_commitmentsToVersionedHashes = __esm({
    "node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js"() {
      init_commitmentToVersionedHash();
    }
  });

  // node_modules/viem/_esm/constants/blob.js
  var blobsPerTransaction, bytesPerFieldElement, fieldElementsPerBlob, bytesPerBlob, maxBytesPerTransaction;
  var init_blob = __esm({
    "node_modules/viem/_esm/constants/blob.js"() {
      blobsPerTransaction = 6;
      bytesPerFieldElement = 32;
      fieldElementsPerBlob = 4096;
      bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
      maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
      1 - // zero byte (0x00) appended to each field element.
      1 * fieldElementsPerBlob * blobsPerTransaction;
    }
  });

  // node_modules/viem/_esm/constants/kzg.js
  var versionedHashVersionKzg;
  var init_kzg = __esm({
    "node_modules/viem/_esm/constants/kzg.js"() {
      versionedHashVersionKzg = 1;
    }
  });

  // node_modules/viem/_esm/errors/blob.js
  var BlobSizeTooLargeError, EmptyBlobError, InvalidVersionedHashSizeError, InvalidVersionedHashVersionError;
  var init_blob2 = __esm({
    "node_modules/viem/_esm/errors/blob.js"() {
      init_kzg();
      init_base2();
      BlobSizeTooLargeError = class extends BaseError2 {
        constructor({ maxSize, size: size5 }) {
          super("Blob size is too large.", {
            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size5} bytes`],
            name: "BlobSizeTooLargeError"
          });
        }
      };
      EmptyBlobError = class extends BaseError2 {
        constructor() {
          super("Blob data must not be empty.", { name: "EmptyBlobError" });
        }
      };
      InvalidVersionedHashSizeError = class extends BaseError2 {
        constructor({ hash: hash2, size: size5 }) {
          super(`Versioned hash "${hash2}" size is invalid.`, {
            metaMessages: ["Expected: 32", `Received: ${size5}`],
            name: "InvalidVersionedHashSizeError"
          });
        }
      };
      InvalidVersionedHashVersionError = class extends BaseError2 {
        constructor({ hash: hash2, version: version4 }) {
          super(`Versioned hash "${hash2}" version is invalid.`, {
            metaMessages: [
              `Expected: ${versionedHashVersionKzg}`,
              `Received: ${version4}`
            ],
            name: "InvalidVersionedHashVersionError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/blob/toBlobs.js
  function toBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
    const data = typeof parameters.data === "string" ? hexToBytes3(parameters.data) : parameters.data;
    const size_ = size(data);
    if (!size_)
      throw new EmptyBlobError();
    if (size_ > maxBytesPerTransaction)
      throw new BlobSizeTooLargeError({
        maxSize: maxBytesPerTransaction,
        size: size_
      });
    const blobs = [];
    let active = true;
    let position = 0;
    while (active) {
      const blob = createCursor(new Uint8Array(bytesPerBlob));
      let size5 = 0;
      while (size5 < fieldElementsPerBlob) {
        const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
        blob.pushByte(0);
        blob.pushBytes(bytes);
        if (bytes.length < 31) {
          blob.pushByte(128);
          active = false;
          break;
        }
        size5++;
        position += 31;
      }
      blobs.push(blob);
    }
    return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex3(x.bytes));
  }
  var init_toBlobs = __esm({
    "node_modules/viem/_esm/utils/blob/toBlobs.js"() {
      init_blob();
      init_blob2();
      init_cursor2();
      init_size();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/toBlobSidecars.js
  function toBlobSidecars(parameters) {
    const { data, kzg, to } = parameters;
    const blobs = parameters.blobs ?? toBlobs({ data, to });
    const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
    const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
    const sidecars = [];
    for (let i = 0; i < blobs.length; i++)
      sidecars.push({
        blob: blobs[i],
        commitment: commitments[i],
        proof: proofs[i]
      });
    return sidecars;
  }
  var init_toBlobSidecars = __esm({
    "node_modules/viem/_esm/utils/blob/toBlobSidecars.js"() {
      init_blobsToCommitments();
      init_blobsToProofs();
      init_toBlobs();
    }
  });

  // node_modules/viem/_esm/utils/transaction/getTransactionType.js
  function getTransactionType(transaction) {
    if (transaction.type)
      return transaction.type;
    if (typeof transaction.authorizationList !== "undefined")
      return "eip7702";
    if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
      return "eip4844";
    if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
      return "eip1559";
    }
    if (typeof transaction.gasPrice !== "undefined") {
      if (typeof transaction.accessList !== "undefined")
        return "eip2930";
      return "legacy";
    }
    throw new InvalidSerializableTransactionError({ transaction });
  }
  var init_getTransactionType = __esm({
    "node_modules/viem/_esm/utils/transaction/getTransactionType.js"() {
      init_transaction();
    }
  });

  // node_modules/viem/_esm/actions/public/getChainId.js
  async function getChainId(client) {
    const chainIdHex = await client.request({
      method: "eth_chainId"
    }, { dedupe: true });
    return hexToNumber2(chainIdHex);
  }
  var init_getChainId = __esm({
    "node_modules/viem/_esm/actions/public/getChainId.js"() {
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
  async function prepareTransactionRequest(client, args) {
    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager: nonceManager2, parameters = defaultParameters, type } = args;
    const account = account_ ? parseAccount(account_) : account_;
    const request2 = { ...args, ...account ? { from: account?.address } : {} };
    let block;
    async function getBlock2() {
      if (block)
        return block;
      block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
      return block;
    }
    let chainId;
    async function getChainId2() {
      if (chainId)
        return chainId;
      if (chain)
        return chain.id;
      if (typeof args.chainId !== "undefined")
        return args.chainId;
      const chainId_ = await getAction(client, getChainId, "getChainId")({});
      chainId = chainId_;
      return chainId;
    }
    if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
      if (nonceManager2) {
        const chainId2 = await getChainId2();
        request2.nonce = await nonceManager2.consume({
          address: account.address,
          chainId: chainId2,
          client
        });
      } else {
        request2.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
          address: account.address,
          blockTag: "pending"
        });
      }
    }
    if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
      const commitments = blobsToCommitments({ blobs, kzg });
      if (parameters.includes("blobVersionedHashes")) {
        const versionedHashes = commitmentsToVersionedHashes({
          commitments,
          to: "hex"
        });
        request2.blobVersionedHashes = versionedHashes;
      }
      if (parameters.includes("sidecars")) {
        const proofs = blobsToProofs({ blobs, commitments, kzg });
        const sidecars = toBlobSidecars({
          blobs,
          commitments,
          proofs,
          to: "hex"
        });
        request2.sidecars = sidecars;
      }
    }
    if (parameters.includes("chainId"))
      request2.chainId = await getChainId2();
    if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
      try {
        request2.type = getTransactionType(request2);
      } catch {
        let isEip1559Network = eip1559NetworkCache.get(client.uid);
        if (typeof isEip1559Network === "undefined") {
          const block2 = await getBlock2();
          isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
          eip1559NetworkCache.set(client.uid, isEip1559Network);
        }
        request2.type = isEip1559Network ? "eip1559" : "legacy";
      }
    }
    if (parameters.includes("fees")) {
      if (request2.type !== "legacy" && request2.type !== "eip2930") {
        if (typeof request2.maxFeePerGas === "undefined" || typeof request2.maxPriorityFeePerGas === "undefined") {
          const block2 = await getBlock2();
          const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
            block: block2,
            chain,
            request: request2
          });
          if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
            throw new MaxFeePerGasTooLowError({
              maxPriorityFeePerGas
            });
          request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
          request2.maxFeePerGas = maxFeePerGas;
        }
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new Eip1559FeesNotSupportedError();
        if (typeof args.gasPrice === "undefined") {
          const block2 = await getBlock2();
          const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
            block: block2,
            chain,
            request: request2,
            type: "legacy"
          });
          request2.gasPrice = gasPrice_;
        }
      }
    }
    if (parameters.includes("gas") && typeof gas === "undefined")
      request2.gas = await getAction(client, estimateGas, "estimateGas")({
        ...request2,
        account: account ? { address: account.address, type: "json-rpc" } : account
      });
    assertRequest(request2);
    delete request2.parameters;
    return request2;
  }
  var defaultParameters, eip1559NetworkCache;
  var init_prepareTransactionRequest = __esm({
    "node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js"() {
      init_parseAccount();
      init_estimateFeesPerGas();
      init_estimateGas2();
      init_getBlock();
      init_getTransactionCount();
      init_fee();
      init_blobsToCommitments();
      init_blobsToProofs();
      init_commitmentsToVersionedHashes();
      init_toBlobSidecars();
      init_getAction();
      init_assertRequest();
      init_getTransactionType();
      init_getChainId();
      defaultParameters = [
        "blobVersionedHashes",
        "chainId",
        "fees",
        "gas",
        "nonce",
        "type"
      ];
      eip1559NetworkCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/actions/public/getBalance.js
  async function getBalance(client, { address, blockNumber, blockTag = client.experimental_blockTag ?? "latest" }) {
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const balance = await client.request({
      method: "eth_getBalance",
      params: [address, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  }
  var init_getBalance = __esm({
    "node_modules/viem/_esm/actions/public/getBalance.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateGas.js
  async function estimateGas(client, args) {
    const { account: account_ = client.account } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      let estimateGas_rpc = function(parameters) {
        const { block: block2, request: request3, rpcStateOverride: rpcStateOverride2 } = parameters;
        return client.request({
          method: "eth_estimateGas",
          params: rpcStateOverride2 ? [
            request3,
            block2 ?? client.experimental_blockTag ?? "latest",
            rpcStateOverride2
          ] : block2 ? [request3, block2] : [request3]
        });
      };
      const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
        ...args,
        parameters: (
          // Some RPC Providers do not compute versioned hashes from blobs. We will need
          // to compute them.
          account?.type === "local" ? void 0 : ["blobVersionedHashes"]
        )
      });
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const rpcStateOverride = serializeStateOverride(stateOverride);
      const to = await (async () => {
        if (rest.to)
          return rest.to;
        if (authorizationList && authorizationList.length > 0)
          return await recoverAuthorizationAddress({
            authorization: authorizationList[0]
          }).catch(() => {
            throw new BaseError2("`to` is required. Could not infer from `authorizationList`");
          });
        return void 0;
      })();
      assertRequest(args);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request2 = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        authorizationList,
        blobs,
        blobVersionedHashes,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      let estimate = BigInt(await estimateGas_rpc({ block, request: request2, rpcStateOverride }));
      if (authorizationList) {
        const value2 = await getBalance(client, { address: request2.from });
        const estimates = await Promise.all(authorizationList.map(async (authorization) => {
          const { address } = authorization;
          const estimate2 = await estimateGas_rpc({
            block,
            request: {
              authorizationList: void 0,
              data,
              from: account?.address,
              to: address,
              value: numberToHex(value2)
            },
            rpcStateOverride
          }).catch(() => 100000n);
          return 2n * BigInt(estimate2);
        }));
        estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
      }
      return estimate;
    } catch (err) {
      throw getEstimateGasError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  var init_estimateGas2 = __esm({
    "node_modules/viem/_esm/actions/public/estimateGas.js"() {
      init_parseAccount();
      init_base2();
      init_recoverAuthorizationAddress();
      init_toHex();
      init_getEstimateGasError();
      init_extract();
      init_transactionRequest();
      init_stateOverride2();
      init_assertRequest();
      init_prepareTransactionRequest();
      init_getBalance();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateContractGas.js
  async function estimateContractGas(client, parameters) {
    const { abi: abi2, address, args, functionName, dataSuffix, ...request2 } = parameters;
    const data = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      const gas = await getAction(client, estimateGas, "estimateGas")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request2
      });
      return gas;
    } catch (error) {
      const account = request2.account ? parseAccount(request2.account) : void 0;
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/estimateContractGas",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_estimateContractGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateContractGas.js"() {
      init_parseAccount();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_estimateGas2();
    }
  });

  // node_modules/viem/_esm/utils/address/isAddressEqual.js
  function isAddressEqual(a, b) {
    if (!isAddress(a, { strict: false }))
      throw new InvalidAddressError({ address: a });
    if (!isAddress(b, { strict: false }))
      throw new InvalidAddressError({ address: b });
    return a.toLowerCase() === b.toLowerCase();
  }
  var init_isAddressEqual = __esm({
    "node_modules/viem/_esm/utils/address/isAddressEqual.js"() {
      init_address();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeEventLog.js
  function decodeEventLog(parameters) {
    const { abi: abi2, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
      throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
    const abiItem = abi2.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
      throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
    const args = isUnnamed ? [] : {};
    const indexedInputs = inputs.map((x, i) => [x, i]).filter(([x]) => "indexed" in x && x.indexed);
    for (let i = 0; i < indexedInputs.length; i++) {
      const [param, argIndex] = indexedInputs[i];
      const topic = argTopics[i];
      if (!topic)
        throw new DecodeLogTopicsMismatch({
          abiItem,
          param
        });
      args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({
        param,
        value: topic
      });
    }
    const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
      if (data && data !== "0x") {
        try {
          const decodedData = decodeAbiParameters(nonIndexedInputs, data);
          if (decodedData) {
            if (isUnnamed)
              for (let i = 0; i < inputs.length; i++)
                args[i] = args[i] ?? decodedData.shift();
            else
              for (let i = 0; i < nonIndexedInputs.length; i++)
                args[nonIndexedInputs[i].name] = decodedData[i];
          }
        } catch (err) {
          if (strict) {
            if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
              throw new DecodeLogDataMismatch({
                abiItem,
                data,
                params: nonIndexedInputs,
                size: size(data)
              });
            throw err;
          }
        }
      } else if (strict) {
        throw new DecodeLogDataMismatch({
          abiItem,
          data: "0x",
          params: nonIndexedInputs,
          size: 0
        });
      }
    }
    return {
      eventName: name,
      args: Object.values(args).length > 0 ? args : void 0
    };
  }
  function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = decodeAbiParameters([param], value) || [];
    return decodedArg[0];
  }
  var docsPath3;
  var init_decodeEventLog = __esm({
    "node_modules/viem/_esm/utils/abi/decodeEventLog.js"() {
      init_abi();
      init_size();
      init_toEventSelector();
      init_cursor();
      init_decodeAbiParameters();
      init_formatAbiItem2();
      docsPath3 = "/docs/contract/decodeEventLog";
    }
  });

  // node_modules/viem/_esm/utils/abi/parseEventLogs.js
  function parseEventLogs(parameters) {
    const { abi: abi2, args, logs, strict = true } = parameters;
    const eventName = (() => {
      if (!parameters.eventName)
        return void 0;
      if (Array.isArray(parameters.eventName))
        return parameters.eventName;
      return [parameters.eventName];
    })();
    return logs.map((log) => {
      try {
        const abiItem = abi2.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
        if (!abiItem)
          return null;
        const event = decodeEventLog({
          ...log,
          abi: [abiItem],
          strict
        });
        if (eventName && !eventName.includes(event.eventName))
          return null;
        if (!includesArgs({
          args: event.args,
          inputs: abiItem.inputs,
          matchArgs: args
        }))
          return null;
        return { ...event, ...log };
      } catch (err) {
        let eventName2;
        let isUnnamed;
        if (err instanceof AbiEventSignatureNotFoundError)
          return null;
        if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
          if (strict)
            return null;
          eventName2 = err.abiItem.name;
          isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
        }
        return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
      }
    }).filter(Boolean);
  }
  function includesArgs(parameters) {
    const { args, inputs, matchArgs } = parameters;
    if (!matchArgs)
      return true;
    if (!args)
      return false;
    function isEqual(input, value, arg) {
      try {
        if (input.type === "address")
          return isAddressEqual(value, arg);
        if (input.type === "string" || input.type === "bytes")
          return keccak256(toBytes2(value)) === arg;
        return value === arg;
      } catch {
        return false;
      }
    }
    if (Array.isArray(args) && Array.isArray(matchArgs)) {
      return matchArgs.every((value, index2) => {
        if (value === null || value === void 0)
          return true;
        const input = inputs[index2];
        if (!input)
          return false;
        const value_ = Array.isArray(value) ? value : [value];
        return value_.some((value2) => isEqual(input, value2, args[index2]));
      });
    }
    if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
      return Object.entries(matchArgs).every(([key, value]) => {
        if (value === null || value === void 0)
          return true;
        const input = inputs.find((input2) => input2.name === key);
        if (!input)
          return false;
        const value_ = Array.isArray(value) ? value : [value];
        return value_.some((value2) => isEqual(input, value2, args[key]));
      });
    return false;
  }
  var init_parseEventLogs = __esm({
    "node_modules/viem/_esm/utils/abi/parseEventLogs.js"() {
      init_abi();
      init_isAddressEqual();
      init_toBytes();
      init_keccak256();
      init_toEventSelector();
      init_decodeEventLog();
    }
  });

  // node_modules/viem/_esm/utils/formatters/log.js
  function formatLog(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? Number(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }
  var init_log2 = __esm({
    "node_modules/viem/_esm/utils/formatters/log.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getLogs.js
  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : void 0);
    let topics = [];
    if (events) {
      const encoded = events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args: events_ ? void 0 : args
      }));
      topics = [encoded];
      if (event)
        topics = topics[0];
    }
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
          }
        ]
      });
    }
    const formattedLogs = logs.map((log) => formatLog(log));
    if (!events)
      return formattedLogs;
    return parseEventLogs({
      abi: events,
      args,
      logs: formattedLogs,
      strict
    });
  }
  var init_getLogs = __esm({
    "node_modules/viem/_esm/actions/public/getLogs.js"() {
      init_encodeEventTopics();
      init_parseEventLogs();
      init_toHex();
      init_log2();
    }
  });

  // node_modules/viem/_esm/actions/public/getContractEvents.js
  async function getContractEvents(client, parameters) {
    const { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;
    const events = !event ? abi2.filter((x) => x.type === "event") : void 0;
    return getAction(client, getLogs, "getLogs")({
      address,
      args,
      blockHash,
      event,
      events,
      fromBlock,
      toBlock,
      strict
    });
  }
  var init_getContractEvents = __esm({
    "node_modules/viem/_esm/actions/public/getContractEvents.js"() {
      init_getAbiItem();
      init_getAction();
      init_getLogs();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
  function decodeFunctionResult(parameters) {
    const { abi: abi2, args, functionName, data } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({ abi: abi2, args, name: functionName });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath4 });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
    const values = decodeAbiParameters(abiItem.outputs, data);
    if (values && values.length > 1)
      return values;
    if (values && values.length === 1)
      return values[0];
    return void 0;
  }
  var docsPath4;
  var init_decodeFunctionResult = __esm({
    "node_modules/viem/_esm/utils/abi/decodeFunctionResult.js"() {
      init_abi();
      init_decodeAbiParameters();
      init_getAbiItem();
      docsPath4 = "/docs/contract/decodeFunctionResult";
    }
  });

  // node_modules/ox/_esm/core/version.js
  var version3;
  var init_version4 = __esm({
    "node_modules/ox/_esm/core/version.js"() {
      version3 = "0.1.1";
    }
  });

  // node_modules/ox/_esm/core/internal/errors.js
  function getVersion() {
    return version3;
  }
  var init_errors3 = __esm({
    "node_modules/ox/_esm/core/internal/errors.js"() {
      init_version4();
    }
  });

  // node_modules/ox/_esm/core/Errors.js
  function walk2(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err && err.cause)
      return walk2(err.cause, fn);
    return fn ? null : err;
  }
  var BaseError3;
  var init_Errors = __esm({
    "node_modules/ox/_esm/core/Errors.js"() {
      init_errors3();
      BaseError3 = class _BaseError extends Error {
        constructor(shortMessage, options = {}) {
          const details = (() => {
            if (options.cause instanceof _BaseError) {
              if (options.cause.details)
                return options.cause.details;
              if (options.cause.shortMessage)
                return options.cause.shortMessage;
            }
            if (options.cause && "details" in options.cause && typeof options.cause.details === "string")
              return options.cause.details;
            if (options.cause?.message)
              return options.cause.message;
            return options.details;
          })();
          const docsPath9 = (() => {
            if (options.cause instanceof _BaseError)
              return options.cause.docsPath || options.docsPath;
            return options.docsPath;
          })();
          const docsBaseUrl = "https://oxlib.sh";
          const docs = `${docsBaseUrl}${docsPath9 ?? ""}`;
          const message = [
            shortMessage || "An error occurred.",
            ...options.metaMessages ? ["", ...options.metaMessages] : [],
            ...details || docsPath9 ? [
              "",
              details ? `Details: ${details}` : void 0,
              docsPath9 ? `See: ${docs}` : void 0
            ] : []
          ].filter((x) => typeof x === "string").join("\n");
          super(message, options.cause ? { cause: options.cause } : void 0);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BaseError"
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: `ox@${getVersion()}`
          });
          this.cause = options.cause;
          this.details = details;
          this.docs = docs;
          this.docsPath = docsPath9;
          this.shortMessage = shortMessage;
        }
        walk(fn) {
          return walk2(this, fn);
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Json.js
  function stringify2(value, replacer, space) {
    return JSON.stringify(value, (key, value2) => {
      if (typeof replacer === "function")
        return replacer(key, value2);
      if (typeof value2 === "bigint")
        return value2.toString() + bigIntSuffix;
      return value2;
    }, space);
  }
  var bigIntSuffix;
  var init_Json = __esm({
    "node_modules/ox/_esm/core/Json.js"() {
      bigIntSuffix = "#__bigint";
    }
  });

  // node_modules/ox/_esm/core/internal/bytes.js
  function assertSize2(bytes, size_) {
    if (size2(bytes) > size_)
      throw new SizeOverflowError2({
        givenSize: size2(bytes),
        maxSize: size_
      });
  }
  function charCodeToBase162(char) {
    if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
      return char - charCodeMap2.zero;
    if (char >= charCodeMap2.A && char <= charCodeMap2.F)
      return char - (charCodeMap2.A - 10);
    if (char >= charCodeMap2.a && char <= charCodeMap2.f)
      return char - (charCodeMap2.a - 10);
    return void 0;
  }
  function pad2(bytes, options = {}) {
    const { dir, size: size5 = 32 } = options;
    if (size5 === 0)
      return bytes;
    if (bytes.length > size5)
      throw new SizeExceedsPaddingSizeError2({
        size: bytes.length,
        targetSize: size5,
        type: "Bytes"
      });
    const paddedBytes = new Uint8Array(size5);
    for (let i = 0; i < size5; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size5 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
  }
  var charCodeMap2;
  var init_bytes2 = __esm({
    "node_modules/ox/_esm/core/internal/bytes.js"() {
      init_Bytes();
      charCodeMap2 = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };
    }
  });

  // node_modules/ox/_esm/core/internal/hex.js
  function assertSize3(hex, size_) {
    if (size3(hex) > size_)
      throw new SizeOverflowError3({
        givenSize: size3(hex),
        maxSize: size_
      });
  }
  function assertStartOffset2(value, start) {
    if (typeof start === "number" && start > 0 && start > size3(value) - 1)
      throw new SliceOffsetOutOfBoundsError3({
        offset: start,
        position: "start",
        size: size3(value)
      });
  }
  function assertEndOffset2(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size3(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError3({
        offset: end,
        position: "end",
        size: size3(value)
      });
    }
  }
  function pad3(hex_, options = {}) {
    const { dir, size: size5 = 32 } = options;
    if (size5 === 0)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size5 * 2)
      throw new SizeExceedsPaddingSizeError3({
        size: Math.ceil(hex.length / 2),
        targetSize: size5,
        type: "Hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size5 * 2, "0")}`;
  }
  var init_hex = __esm({
    "node_modules/ox/_esm/core/internal/hex.js"() {
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/Bytes.js
  function from(value) {
    if (value instanceof Uint8Array)
      return value;
    if (typeof value === "string")
      return fromHex3(value);
    return fromArray(value);
  }
  function fromArray(value) {
    return value instanceof Uint8Array ? value : new Uint8Array(value);
  }
  function fromHex3(value, options = {}) {
    const { size: size5 } = options;
    let hex = value;
    if (size5) {
      assertSize3(value, size5);
      hex = padRight(value, size5);
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index2 = 0, j = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase162(hexString.charCodeAt(j++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError3(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
  }
  function fromString(value, options = {}) {
    const { size: size5 } = options;
    const bytes = encoder3.encode(value);
    if (typeof size5 === "number") {
      assertSize2(bytes, size5);
      return padRight2(bytes, size5);
    }
    return bytes;
  }
  function padRight2(value, size5) {
    return pad2(value, { dir: "right", size: size5 });
  }
  function size2(value) {
    return value.length;
  }
  var encoder3, SizeOverflowError2, SizeExceedsPaddingSizeError2;
  var init_Bytes = __esm({
    "node_modules/ox/_esm/core/Bytes.js"() {
      init_Errors();
      init_Hex();
      init_bytes2();
      init_hex();
      encoder3 = /* @__PURE__ */ new TextEncoder();
      SizeOverflowError2 = class extends BaseError3 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Bytes.SizeOverflowError"
          });
        }
      };
      SizeExceedsPaddingSizeError2 = class extends BaseError3 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Bytes.SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Hex.js
  function assert(value, options = {}) {
    const { strict = false } = options;
    if (!value)
      throw new InvalidHexTypeError(value);
    if (typeof value !== "string")
      throw new InvalidHexTypeError(value);
    if (strict) {
      if (!/^0x[0-9a-fA-F]*$/.test(value))
        throw new InvalidHexValueError2(value);
    }
    if (!value.startsWith("0x"))
      throw new InvalidHexValueError2(value);
  }
  function concat2(...values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  function fromBoolean(value, options = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof options.size === "number") {
      assertSize3(hex, options.size);
      return padLeft(hex, options.size);
    }
    return hex;
  }
  function fromBytes2(value, options = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++)
      string += hexes4[value[i]];
    const hex = `0x${string}`;
    if (typeof options.size === "number") {
      assertSize3(hex, options.size);
      return padRight(hex, options.size);
    }
    return hex;
  }
  function fromNumber(value, options = {}) {
    const { signed, size: size5 } = options;
    const value_ = BigInt(value);
    let maxValue;
    if (size5) {
      if (signed)
        maxValue = (1n << BigInt(size5) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size5) * 8n) - 1n;
    } else if (typeof value === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value_ > maxValue || value_ < minValue) {
      const suffix = typeof value === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError2({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size5,
        value: `${value}${suffix}`
      });
    }
    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value_) : value_).toString(16);
    const hex = `0x${stringValue}`;
    if (size5)
      return padLeft(hex, size5);
    return hex;
  }
  function fromString2(value, options = {}) {
    return fromBytes2(encoder4.encode(value), options);
  }
  function padLeft(value, size5) {
    return pad3(value, { dir: "left", size: size5 });
  }
  function padRight(value, size5) {
    return pad3(value, { dir: "right", size: size5 });
  }
  function slice2(value, start, end, options = {}) {
    const { strict } = options;
    assertStartOffset2(value, start);
    const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
    if (strict)
      assertEndOffset2(value_, start, end);
    return value_;
  }
  function size3(value) {
    return Math.ceil((value.length - 2) / 2);
  }
  function validate(value, options = {}) {
    const { strict = false } = options;
    try {
      assert(value, { strict });
      return true;
    } catch {
      return false;
    }
  }
  var encoder4, hexes4, IntegerOutOfRangeError2, InvalidHexTypeError, InvalidHexValueError2, SizeOverflowError3, SliceOffsetOutOfBoundsError3, SizeExceedsPaddingSizeError3;
  var init_Hex = __esm({
    "node_modules/ox/_esm/core/Hex.js"() {
      init_Errors();
      init_Json();
      init_hex();
      encoder4 = /* @__PURE__ */ new TextEncoder();
      hexes4 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
      IntegerOutOfRangeError2 = class extends BaseError3 {
        constructor({ max, min, signed, size: size5, value }) {
          super(`Number \`${value}\` is not in safe${size5 ? ` ${size5 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.IntegerOutOfRangeError"
          });
        }
      };
      InvalidHexTypeError = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${typeof value === "object" ? stringify2(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
            metaMessages: ['Hex types must be represented as `"0x${string}"`.']
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.InvalidHexTypeError"
          });
        }
      };
      InvalidHexValueError2 = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${value}\` is an invalid hex value.`, {
            metaMessages: [
              'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.InvalidHexValueError"
          });
        }
      };
      SizeOverflowError3 = class extends BaseError3 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SizeOverflowError"
          });
        }
      };
      SliceOffsetOutOfBoundsError3 = class extends BaseError3 {
        constructor({ offset, position, size: size5 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size5}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SliceOffsetOutOfBoundsError"
          });
        }
      };
      SizeExceedsPaddingSizeError3 = class extends BaseError3 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Withdrawal.js
  function toRpc(withdrawal) {
    return {
      address: withdrawal.address,
      amount: fromNumber(withdrawal.amount),
      index: fromNumber(withdrawal.index),
      validatorIndex: fromNumber(withdrawal.validatorIndex)
    };
  }
  var init_Withdrawal = __esm({
    "node_modules/ox/_esm/core/Withdrawal.js"() {
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/BlockOverrides.js
  function toRpc2(blockOverrides) {
    return {
      ...typeof blockOverrides.baseFeePerGas === "bigint" && {
        baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
      },
      ...typeof blockOverrides.blobBaseFee === "bigint" && {
        blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
      },
      ...typeof blockOverrides.feeRecipient === "string" && {
        feeRecipient: blockOverrides.feeRecipient
      },
      ...typeof blockOverrides.gasLimit === "bigint" && {
        gasLimit: fromNumber(blockOverrides.gasLimit)
      },
      ...typeof blockOverrides.number === "bigint" && {
        number: fromNumber(blockOverrides.number)
      },
      ...typeof blockOverrides.prevRandao === "bigint" && {
        prevRandao: fromNumber(blockOverrides.prevRandao)
      },
      ...typeof blockOverrides.time === "bigint" && {
        time: fromNumber(blockOverrides.time)
      },
      ...blockOverrides.withdrawals && {
        withdrawals: blockOverrides.withdrawals.map(toRpc)
      }
    };
  }
  var init_BlockOverrides = __esm({
    "node_modules/ox/_esm/core/BlockOverrides.js"() {
      init_Hex();
      init_Withdrawal();
    }
  });

  // node_modules/viem/_esm/constants/abis.js
  var multicall3Abi, batchGatewayAbi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi, erc20Abi, erc20Abi_bytes32, erc1155Abi, erc721Abi, erc4626Abi;
  var init_abis = __esm({
    "node_modules/viem/_esm/constants/abis.js"() {
      multicall3Abi = [
        {
          inputs: [
            {
              components: [
                {
                  name: "target",
                  type: "address"
                },
                {
                  name: "allowFailure",
                  type: "bool"
                },
                {
                  name: "callData",
                  type: "bytes"
                }
              ],
              name: "calls",
              type: "tuple[]"
            }
          ],
          name: "aggregate3",
          outputs: [
            {
              components: [
                {
                  name: "success",
                  type: "bool"
                },
                {
                  name: "returnData",
                  type: "bytes"
                }
              ],
              name: "returnData",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
      batchGatewayAbi = [
        {
          name: "query",
          type: "function",
          stateMutability: "view",
          inputs: [
            {
              type: "tuple[]",
              name: "queries",
              components: [
                {
                  type: "address",
                  name: "sender"
                },
                {
                  type: "string[]",
                  name: "urls"
                },
                {
                  type: "bytes",
                  name: "data"
                }
              ]
            }
          ],
          outputs: [
            {
              type: "bool[]",
              name: "failures"
            },
            {
              type: "bytes[]",
              name: "responses"
            }
          ]
        },
        {
          name: "HttpError",
          type: "error",
          inputs: [
            {
              type: "uint16",
              name: "status"
            },
            {
              type: "string",
              name: "message"
            }
          ]
        }
      ];
      universalResolverErrors = [
        {
          inputs: [],
          name: "ResolverNotFound",
          type: "error"
        },
        {
          inputs: [],
          name: "ResolverWildcardNotSupported",
          type: "error"
        },
        {
          inputs: [],
          name: "ResolverNotContract",
          type: "error"
        },
        {
          inputs: [
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "ResolverError",
          type: "error"
        },
        {
          inputs: [
            {
              components: [
                {
                  name: "status",
                  type: "uint16"
                },
                {
                  name: "message",
                  type: "string"
                }
              ],
              name: "errors",
              type: "tuple[]"
            }
          ],
          name: "HttpError",
          type: "error"
        }
      ];
      universalResolverResolveAbi = [
        ...universalResolverErrors,
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        },
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" },
            { name: "gateways", type: "string[]" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        }
      ];
      universalResolverReverseAbi = [
        ...universalResolverErrors,
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [{ type: "bytes", name: "reverseName" }],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        },
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [
            { type: "bytes", name: "reverseName" },
            { type: "string[]", name: "gateways" }
          ],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        }
      ];
      textResolverAbi = [
        {
          name: "text",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "key", type: "string" }
          ],
          outputs: [{ name: "", type: "string" }]
        }
      ];
      addressResolverAbi = [
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "name", type: "bytes32" }],
          outputs: [{ name: "", type: "address" }]
        },
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "coinType", type: "uint256" }
          ],
          outputs: [{ name: "", type: "bytes" }]
        }
      ];
      universalSignatureValidatorAbi = [
        {
          inputs: [
            {
              name: "_signer",
              type: "address"
            },
            {
              name: "_hash",
              type: "bytes32"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              name: "_signer",
              type: "address"
            },
            {
              name: "_hash",
              type: "bytes32"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "isValidSig"
        }
      ];
      erc20Abi = [
        {
          type: "event",
          name: "Approval",
          inputs: [
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              name: "spender",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ]
        },
        {
          type: "event",
          name: "Transfer",
          inputs: [
            {
              indexed: true,
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "allowance",
          stateMutability: "view",
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "spender",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "approve",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "spender",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        },
        {
          type: "function",
          name: "balanceOf",
          stateMutability: "view",
          inputs: [
            {
              name: "account",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "decimals",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "uint8"
            }
          ]
        },
        {
          type: "function",
          name: "name",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "string"
            }
          ]
        },
        {
          type: "function",
          name: "symbol",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "string"
            }
          ]
        },
        {
          type: "function",
          name: "totalSupply",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "transfer",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "recipient",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        },
        {
          type: "function",
          name: "transferFrom",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "sender",
              type: "address"
            },
            {
              name: "recipient",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        }
      ];
      erc20Abi_bytes32 = [
        {
          type: "event",
          name: "Approval",
          inputs: [
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              name: "spender",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ]
        },
        {
          type: "event",
          name: "Transfer",
          inputs: [
            {
              indexed: true,
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "allowance",
          stateMutability: "view",
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "spender",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "approve",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "spender",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        },
        {
          type: "function",
          name: "balanceOf",
          stateMutability: "view",
          inputs: [
            {
              name: "account",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "decimals",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "uint8"
            }
          ]
        },
        {
          type: "function",
          name: "name",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "bytes32"
            }
          ]
        },
        {
          type: "function",
          name: "symbol",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "bytes32"
            }
          ]
        },
        {
          type: "function",
          name: "totalSupply",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "transfer",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "recipient",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        },
        {
          type: "function",
          name: "transferFrom",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "sender",
              type: "address"
            },
            {
              name: "recipient",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        }
      ];
      erc1155Abi = [
        {
          inputs: [
            {
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "balance",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "needed",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256"
            }
          ],
          name: "ERC1155InsufficientBalance",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "approver",
              type: "address"
            }
          ],
          name: "ERC1155InvalidApprover",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "idsLength",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "valuesLength",
              type: "uint256"
            }
          ],
          name: "ERC1155InvalidArrayLength",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "operator",
              type: "address"
            }
          ],
          name: "ERC1155InvalidOperator",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "receiver",
              type: "address"
            }
          ],
          name: "ERC1155InvalidReceiver",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "sender",
              type: "address"
            }
          ],
          name: "ERC1155InvalidSender",
          type: "error"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "operator",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ERC1155MissingApprovalForAll",
          type: "error"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "operator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bool",
              name: "approved",
              type: "bool"
            }
          ],
          name: "ApprovalForAll",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "operator",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256[]",
              name: "ids",
              type: "uint256[]"
            },
            {
              indexed: false,
              internalType: "uint256[]",
              name: "values",
              type: "uint256[]"
            }
          ],
          name: "TransferBatch",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "operator",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "id",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "TransferSingle",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "string",
              name: "value",
              type: "string"
            },
            {
              indexed: true,
              internalType: "uint256",
              name: "id",
              type: "uint256"
            }
          ],
          name: "URI",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "id",
              type: "uint256"
            }
          ],
          name: "balanceOf",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "accounts",
              type: "address[]"
            },
            {
              internalType: "uint256[]",
              name: "ids",
              type: "uint256[]"
            }
          ],
          name: "balanceOfBatch",
          outputs: [
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            },
            {
              internalType: "address",
              name: "operator",
              type: "address"
            }
          ],
          name: "isApprovedForAll",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "ids",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "values",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "safeBatchTransferFrom",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "id",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "safeTransferFrom",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "operator",
              type: "address"
            },
            {
              internalType: "bool",
              name: "approved",
              type: "bool"
            }
          ],
          name: "setApprovalForAll",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          name: "uri",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
      erc721Abi = [
        {
          type: "event",
          name: "Approval",
          inputs: [
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              name: "spender",
              type: "address"
            },
            {
              indexed: true,
              name: "tokenId",
              type: "uint256"
            }
          ]
        },
        {
          type: "event",
          name: "ApprovalForAll",
          inputs: [
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              name: "operator",
              type: "address"
            },
            {
              indexed: false,
              name: "approved",
              type: "bool"
            }
          ]
        },
        {
          type: "event",
          name: "Transfer",
          inputs: [
            {
              indexed: true,
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              name: "tokenId",
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "approve",
          stateMutability: "payable",
          inputs: [
            {
              name: "spender",
              type: "address"
            },
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: []
        },
        {
          type: "function",
          name: "balanceOf",
          stateMutability: "view",
          inputs: [
            {
              name: "account",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "getApproved",
          stateMutability: "view",
          inputs: [
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "address"
            }
          ]
        },
        {
          type: "function",
          name: "isApprovedForAll",
          stateMutability: "view",
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "operator",
              type: "address"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ]
        },
        {
          type: "function",
          name: "name",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "string"
            }
          ]
        },
        {
          type: "function",
          name: "ownerOf",
          stateMutability: "view",
          inputs: [
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: [
            {
              name: "owner",
              type: "address"
            }
          ]
        },
        {
          type: "function",
          name: "safeTransferFrom",
          stateMutability: "payable",
          inputs: [
            {
              name: "from",
              type: "address"
            },
            {
              name: "to",
              type: "address"
            },
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: []
        },
        {
          type: "function",
          name: "safeTransferFrom",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "from",
              type: "address"
            },
            {
              name: "to",
              type: "address"
            },
            {
              name: "id",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            }
          ],
          outputs: []
        },
        {
          type: "function",
          name: "setApprovalForAll",
          stateMutability: "nonpayable",
          inputs: [
            {
              name: "operator",
              type: "address"
            },
            {
              name: "approved",
              type: "bool"
            }
          ],
          outputs: []
        },
        {
          type: "function",
          name: "symbol",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "string"
            }
          ]
        },
        {
          type: "function",
          name: "tokenByIndex",
          stateMutability: "view",
          inputs: [
            {
              name: "index",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "tokenByIndex",
          stateMutability: "view",
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "index",
              type: "uint256"
            }
          ],
          outputs: [
            {
              name: "tokenId",
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "tokenURI",
          stateMutability: "view",
          inputs: [
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: [
            {
              type: "string"
            }
          ]
        },
        {
          type: "function",
          name: "totalSupply",
          stateMutability: "view",
          inputs: [],
          outputs: [
            {
              type: "uint256"
            }
          ]
        },
        {
          type: "function",
          name: "transferFrom",
          stateMutability: "payable",
          inputs: [
            {
              name: "sender",
              type: "address"
            },
            {
              name: "recipient",
              type: "address"
            },
            {
              name: "tokenId",
              type: "uint256"
            }
          ],
          outputs: []
        }
      ];
      erc4626Abi = [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              name: "spender",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ],
          name: "Approval",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              name: "sender",
              type: "address"
            },
            {
              indexed: true,
              name: "receiver",
              type: "address"
            },
            {
              indexed: false,
              name: "assets",
              type: "uint256"
            },
            {
              indexed: false,
              name: "shares",
              type: "uint256"
            }
          ],
          name: "Deposit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              name: "value",
              type: "uint256"
            }
          ],
          name: "Transfer",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              name: "sender",
              type: "address"
            },
            {
              indexed: true,
              name: "receiver",
              type: "address"
            },
            {
              indexed: true,
              name: "owner",
              type: "address"
            },
            {
              indexed: false,
              name: "assets",
              type: "uint256"
            },
            {
              indexed: false,
              name: "shares",
              type: "uint256"
            }
          ],
          name: "Withdraw",
          type: "event"
        },
        {
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "spender",
              type: "address"
            }
          ],
          name: "allowance",
          outputs: [
            {
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "spender",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          name: "approve",
          outputs: [
            {
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "asset",
          outputs: [
            {
              name: "assetTokenAddress",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "account",
              type: "address"
            }
          ],
          name: "balanceOf",
          outputs: [
            {
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          name: "convertToAssets",
          outputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          name: "convertToShares",
          outputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "assets",
              type: "uint256"
            },
            {
              name: "receiver",
              type: "address"
            }
          ],
          name: "deposit",
          outputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              name: "caller",
              type: "address"
            }
          ],
          name: "maxDeposit",
          outputs: [
            {
              name: "maxAssets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "caller",
              type: "address"
            }
          ],
          name: "maxMint",
          outputs: [
            {
              name: "maxShares",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "owner",
              type: "address"
            }
          ],
          name: "maxRedeem",
          outputs: [
            {
              name: "maxShares",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "owner",
              type: "address"
            }
          ],
          name: "maxWithdraw",
          outputs: [
            {
              name: "maxAssets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "shares",
              type: "uint256"
            },
            {
              name: "receiver",
              type: "address"
            }
          ],
          name: "mint",
          outputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          name: "previewDeposit",
          outputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          name: "previewMint",
          outputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          name: "previewRedeem",
          outputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          name: "previewWithdraw",
          outputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "shares",
              type: "uint256"
            },
            {
              name: "receiver",
              type: "address"
            },
            {
              name: "owner",
              type: "address"
            }
          ],
          name: "redeem",
          outputs: [
            {
              name: "assets",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "totalAssets",
          outputs: [
            {
              name: "totalManagedAssets",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "totalSupply",
          outputs: [
            {
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transfer",
          outputs: [
            {
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              name: "from",
              type: "address"
            },
            {
              name: "to",
              type: "address"
            },
            {
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transferFrom",
          outputs: [
            {
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              name: "assets",
              type: "uint256"
            },
            {
              name: "receiver",
              type: "address"
            },
            {
              name: "owner",
              type: "address"
            }
          ],
          name: "withdraw",
          outputs: [
            {
              name: "shares",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ];
    }
  });

  // node_modules/viem/_esm/constants/contract.js
  var aggregate3Signature;
  var init_contract2 = __esm({
    "node_modules/viem/_esm/constants/contract.js"() {
      aggregate3Signature = "0x82ad56cb";
    }
  });

  // node_modules/viem/_esm/constants/contracts.js
  var deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode, universalSignatureValidatorByteCode;
  var init_contracts = __esm({
    "node_modules/viem/_esm/constants/contracts.js"() {
      deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe";
      deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";
      universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
    }
  });

  // node_modules/viem/_esm/errors/chain.js
  var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError;
  var init_chain = __esm({
    "node_modules/viem/_esm/errors/chain.js"() {
      init_base2();
      ChainDoesNotSupportContract = class extends BaseError2 {
        constructor({ blockNumber, chain, contract }) {
          super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
              "This could be due to any of the following:",
              ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
              ] : [
                `- The chain does not have the contract "${contract.name}" configured.`
              ]
            ],
            name: "ChainDoesNotSupportContract"
          });
        }
      };
      ChainMismatchError = class extends BaseError2 {
        constructor({ chain, currentChainId }) {
          super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
            metaMessages: [
              `Current Chain ID:  ${currentChainId}`,
              `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
            ],
            name: "ChainMismatchError"
          });
        }
      };
      ChainNotFoundError = class extends BaseError2 {
        constructor() {
          super([
            "No chain was provided to the request.",
            "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
          ].join("\n"), {
            name: "ChainNotFoundError"
          });
        }
      };
      ClientChainNotConfiguredError = class extends BaseError2 {
        constructor() {
          super("No chain was provided to the Client.", {
            name: "ClientChainNotConfiguredError"
          });
        }
      };
      InvalidChainIdError = class extends BaseError2 {
        constructor({ chainId }) {
          super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeDeployData.js
  function encodeDeployData(parameters) {
    const { abi: abi2, args, bytecode } = parameters;
    if (!args || args.length === 0)
      return bytecode;
    const description = abi2.find((x) => "type" in x && x.type === "constructor");
    if (!description)
      throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });
    if (!("inputs" in description))
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    if (!description.inputs || description.inputs.length === 0)
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    const data = encodeAbiParameters(description.inputs, args);
    return concatHex([bytecode, data]);
  }
  var docsPath5;
  var init_encodeDeployData = __esm({
    "node_modules/viem/_esm/utils/abi/encodeDeployData.js"() {
      init_abi();
      init_concat();
      init_encodeAbiParameters();
      docsPath5 = "/docs/contract/encodeDeployData";
    }
  });

  // node_modules/viem/_esm/utils/chain/getChainContractAddress.js
  function getChainContractAddress({ blockNumber, chain, contract: name }) {
    const contract = chain?.contracts?.[name];
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain,
        contract: { name }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain,
        contract: {
          name,
          blockCreated: contract.blockCreated
        }
      });
    return contract.address;
  }
  var init_getChainContractAddress = __esm({
    "node_modules/viem/_esm/utils/chain/getChainContractAddress.js"() {
      init_chain();
    }
  });

  // node_modules/viem/_esm/utils/errors/getCallError.js
  function getCallError(err, { docsPath: docsPath9, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new CallExecutionError(cause, {
      docsPath: docsPath9,
      ...args
    });
  }
  var init_getCallError = __esm({
    "node_modules/viem/_esm/utils/errors/getCallError.js"() {
      init_contract();
      init_node();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/utils/promise/withResolvers.js
  function withResolvers() {
    let resolve = () => void 0;
    let reject = () => void 0;
    const promise = new Promise((resolve_, reject_) => {
      resolve = resolve_;
      reject = reject_;
    });
    return { promise, resolve, reject };
  }
  var init_withResolvers = __esm({
    "node_modules/viem/_esm/utils/promise/withResolvers.js"() {
    }
  });

  // node_modules/viem/_esm/utils/promise/createBatchScheduler.js
  function createBatchScheduler({ fn, id, shouldSplitBatch, wait: wait2 = 0, sort }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn(args).then((data) => {
        if (sort && Array.isArray(data))
          data.sort(sort);
        for (let i = 0; i < scheduler.length; i++) {
          const { resolve } = scheduler[i];
          resolve?.([data[i], data]);
        }
      }).catch((err) => {
        for (let i = 0; i < scheduler.length; i++) {
          const { reject } = scheduler[i];
          reject?.(err);
        }
      });
    };
    const flush = () => schedulerCache.delete(id);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id) || [];
    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const { promise, resolve, reject } = withResolvers();
        const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split2)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, resolve, reject });
          return promise;
        }
        setScheduler({ args, resolve, reject });
        setTimeout(exec, wait2);
        return promise;
      }
    };
  }
  var schedulerCache;
  var init_createBatchScheduler = __esm({
    "node_modules/viem/_esm/utils/promise/createBatchScheduler.js"() {
      init_withResolvers();
      schedulerCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/errors/ccip.js
  var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
  var init_ccip = __esm({
    "node_modules/viem/_esm/errors/ccip.js"() {
      init_stringify();
      init_base2();
      init_utils5();
      OffchainLookupError = class extends BaseError2 {
        constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
          super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
            cause,
            metaMessages: [
              ...cause.metaMessages || [],
              cause.metaMessages?.length ? "" : [],
              "Offchain Gateway Call:",
              urls && [
                "  Gateway URL(s):",
                ...urls.map((url) => `    ${getUrl(url)}`)
              ],
              `  Sender: ${sender}`,
              `  Data: ${data}`,
              `  Callback selector: ${callbackSelector}`,
              `  Extra data: ${extraData}`
            ].flat(),
            name: "OffchainLookupError"
          });
        }
      };
      OffchainLookupResponseMalformedError = class extends BaseError2 {
        constructor({ result, url }) {
          super("Offchain gateway response is malformed. Response data must be a hex value.", {
            metaMessages: [
              `Gateway URL: ${getUrl(url)}`,
              `Response: ${stringify(result)}`
            ],
            name: "OffchainLookupResponseMalformedError"
          });
        }
      };
      OffchainLookupSenderMismatchError = class extends BaseError2 {
        constructor({ sender, to }) {
          super("Reverted sender address does not match target contract address (`to`).", {
            metaMessages: [
              `Contract address: ${to}`,
              `OffchainLookup sender address: ${sender}`
            ],
            name: "OffchainLookupSenderMismatchError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeFunctionData.js
  function decodeFunctionData(parameters) {
    const { abi: abi2, data } = parameters;
    const signature = slice(data, 0, 4);
    const description = abi2.find((x) => x.type === "function" && signature === toFunctionSelector(formatAbiItem2(x)));
    if (!description)
      throw new AbiFunctionSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeFunctionData"
      });
    return {
      functionName: description.name,
      args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0
    };
  }
  var init_decodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/decodeFunctionData.js"() {
      init_abi();
      init_slice();
      init_toFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem2();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeErrorResult.js
  function encodeErrorResult(parameters) {
    const { abi: abi2, errorName, args } = parameters;
    let abiItem = abi2[0];
    if (errorName) {
      const item = getAbiItem({ abi: abi2, args, name: errorName });
      if (!item)
        throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath6 });
      abiItem = item;
    }
    if (abiItem.type !== "error")
      throw new AbiErrorNotFoundError(void 0, { docsPath: docsPath6 });
    const definition = formatAbiItem2(abiItem);
    const signature = toFunctionSelector(definition);
    let data = "0x";
    if (args && args.length > 0) {
      if (!abiItem.inputs)
        throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath6 });
      data = encodeAbiParameters(abiItem.inputs, args);
    }
    return concatHex([signature, data]);
  }
  var docsPath6;
  var init_encodeErrorResult = __esm({
    "node_modules/viem/_esm/utils/abi/encodeErrorResult.js"() {
      init_abi();
      init_concat();
      init_toFunctionSelector();
      init_encodeAbiParameters();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath6 = "/docs/contract/encodeErrorResult";
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeFunctionResult.js
  function encodeFunctionResult(parameters) {
    const { abi: abi2, functionName, result } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({ abi: abi2, name: functionName });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath7 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath7 });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath7 });
    const values = (() => {
      if (abiItem.outputs.length === 0)
        return [];
      if (abiItem.outputs.length === 1)
        return [result];
      if (Array.isArray(result))
        return result;
      throw new InvalidArrayError(result);
    })();
    return encodeAbiParameters(abiItem.outputs, values);
  }
  var docsPath7;
  var init_encodeFunctionResult = __esm({
    "node_modules/viem/_esm/utils/abi/encodeFunctionResult.js"() {
      init_abi();
      init_encodeAbiParameters();
      init_getAbiItem();
      docsPath7 = "/docs/contract/encodeFunctionResult";
    }
  });

  // node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js
  async function localBatchGatewayRequest(parameters) {
    const { data, ccipRequest: ccipRequest2 } = parameters;
    const { args: [queries] } = decodeFunctionData({ abi: batchGatewayAbi, data });
    const failures = [];
    const responses = [];
    await Promise.all(queries.map(async (query, i) => {
      try {
        responses[i] = query.urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({ data: query.data, ccipRequest: ccipRequest2 }) : await ccipRequest2(query);
        failures[i] = false;
      } catch (err) {
        failures[i] = true;
        responses[i] = encodeError(err);
      }
    }));
    return encodeFunctionResult({
      abi: batchGatewayAbi,
      functionName: "query",
      result: [failures, responses]
    });
  }
  function encodeError(error) {
    if (error.name === "HttpRequestError" && error.status)
      return encodeErrorResult({
        abi: batchGatewayAbi,
        errorName: "HttpError",
        args: [error.status, error.shortMessage]
      });
    return encodeErrorResult({
      abi: [solidityError],
      errorName: "Error",
      args: ["shortMessage" in error ? error.shortMessage : error.message]
    });
  }
  var localBatchGatewayUrl;
  var init_localBatchGatewayRequest = __esm({
    "node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js"() {
      init_abis();
      init_solidity();
      init_decodeFunctionData();
      init_encodeErrorResult();
      init_encodeFunctionResult();
      localBatchGatewayUrl = "x-batch-gateway:true";
    }
  });

  // node_modules/viem/_esm/utils/ccip.js
  var ccip_exports = {};
  __export(ccip_exports, {
    ccipRequest: () => ccipRequest,
    offchainLookup: () => offchainLookup,
    offchainLookupAbiItem: () => offchainLookupAbiItem,
    offchainLookupSignature: () => offchainLookupSignature
  });
  async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
    const { args } = decodeErrorResult({
      data,
      abi: [offchainLookupAbiItem]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
    try {
      if (!isAddressEqual(to, sender))
        throw new OffchainLookupSenderMismatchError({ sender, to });
      const result = urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({
        data: callData,
        ccipRequest: ccipRequest_
      }) : await ccipRequest_({ data: callData, sender, urls });
      const { data: data_ } = await call(client, {
        blockNumber,
        blockTag,
        data: concat([
          callbackSelector,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
        ]),
        to
      });
      return data_;
    } catch (err) {
      throw new OffchainLookupError({
        callbackSelector,
        cause: err,
        data,
        extraData,
        sender,
        urls
      });
    }
  }
  async function ccipRequest({ data, sender, urls }) {
    let error = new Error("An unknown error occurred.");
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const method = url.includes("{data}") ? "GET" : "POST";
      const body = method === "POST" ? { data, sender } : void 0;
      const headers = method === "POST" ? { "Content-Type": "application/json" } : {};
      try {
        const response = await fetch(url.replace("{sender}", sender.toLowerCase()).replace("{data}", data), {
          body: JSON.stringify(body),
          headers,
          method
        });
        let result;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          result = (await response.json()).data;
        } else {
          result = await response.text();
        }
        if (!response.ok) {
          error = new HttpRequestError({
            body,
            details: result?.error ? stringify(result.error) : response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
          continue;
        }
        if (!isHex(result)) {
          error = new OffchainLookupResponseMalformedError({
            result,
            url
          });
          continue;
        }
        return result;
      } catch (err) {
        error = new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    throw error;
  }
  var offchainLookupSignature, offchainLookupAbiItem;
  var init_ccip2 = __esm({
    "node_modules/viem/_esm/utils/ccip.js"() {
      init_call();
      init_ccip();
      init_request();
      init_decodeErrorResult();
      init_encodeAbiParameters();
      init_isAddressEqual();
      init_concat();
      init_isHex();
      init_localBatchGatewayRequest();
      init_stringify();
      offchainLookupSignature = "0x556f1830";
      offchainLookupAbiItem = {
        name: "OffchainLookup",
        type: "error",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "urls",
            type: "string[]"
          },
          {
            name: "callData",
            type: "bytes"
          },
          {
            name: "callbackFunction",
            type: "bytes4"
          },
          {
            name: "extraData",
            type: "bytes"
          }
        ]
      };
    }
  });

  // node_modules/viem/_esm/actions/public/call.js
  async function call(client, args) {
    const { account: account_ = client.account, authorizationList, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = client.experimental_blockTag ?? "latest", accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (code && (factory || factoryData))
      throw new BaseError2("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
    if (code && to)
      throw new BaseError2("Cannot provide both `code` & `to` as parameters.");
    const deploylessCallViaBytecode = code && data_;
    const deploylessCallViaFactory = factory && factoryData && to && data_;
    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
    const data = (() => {
      if (deploylessCallViaBytecode)
        return toDeploylessCallViaBytecodeData({
          code,
          data: data_
        });
      if (deploylessCallViaFactory)
        return toDeploylessCallViaFactoryData({
          data: data_,
          factory,
          factoryData,
          to
        });
      return data_;
    })();
    try {
      assertRequest(args);
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const rpcBlockOverrides = blockOverrides ? toRpc2(blockOverrides) : void 0;
      const rpcStateOverride = serializeStateOverride(stateOverride);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request2 = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        authorizationList,
        blobs,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: deploylessCall ? void 0 : to,
        value
      });
      if (batch && shouldPerformMulticall({ request: request2 }) && !rpcStateOverride && !rpcBlockOverrides) {
        try {
          return await scheduleMulticall(client, {
            ...request2,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
            throw err;
        }
      }
      const params = (() => {
        const base2 = [
          request2,
          block
        ];
        if (rpcStateOverride && rpcBlockOverrides)
          return [...base2, rpcStateOverride, rpcBlockOverrides];
        if (rpcStateOverride)
          return [...base2, rpcStateOverride];
        if (rpcBlockOverrides)
          return [...base2, {}, rpcBlockOverrides];
        return base2;
      })();
      const response = await client.request({
        method: "eth_call",
        params
      });
      if (response === "0x")
        return { data: void 0 };
      return { data: response };
    } catch (err) {
      const data2 = getRevertErrorData(err);
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));
      if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
        return { data: await offchainLookup2(client, { data: data2, to }) };
      if (deploylessCall && data2?.slice(0, 10) === "0x101bb98d")
        throw new CounterfactualDeploymentFailedError({ factory });
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  function shouldPerformMulticall({ request: request2 }) {
    const { data, to, ...request_ } = request2;
    if (!data)
      return false;
    if (data.startsWith(aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
    const { blockNumber, blockTag = client.experimental_blockTag ?? "latest", data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new ClientChainNotConfiguredError();
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const { schedule } = createBatchScheduler({
      id: `${client.uid}.${block}`,
      wait: wait2,
      shouldSplitBatch(args2) {
        const size5 = args2.reduce((size6, { data: data2 }) => size6 + (data2.length - 2), 0);
        return size5 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request2) => ({
          allowFailure: true,
          callData: request2.data,
          target: request2.to
        }));
        const calldata = encodeFunctionData({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data2 = await client.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block
          ]
        });
        return decodeFunctionResult({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data2 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
      throw new RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: void 0 };
    return { data: returnData };
  }
  function toDeploylessCallViaBytecodeData(parameters) {
    const { code, data } = parameters;
    return encodeDeployData({
      abi: parseAbi(["constructor(bytes, bytes)"]),
      bytecode: deploylessCallViaBytecodeBytecode,
      args: [code, data]
    });
  }
  function toDeploylessCallViaFactoryData(parameters) {
    const { data, factory, factoryData, to } = parameters;
    return encodeDeployData({
      abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
      bytecode: deploylessCallViaFactoryBytecode,
      args: [to, data, factory, factoryData]
    });
  }
  function getRevertErrorData(err) {
    if (!(err instanceof BaseError2))
      return void 0;
    const error = err.walk();
    return typeof error?.data === "object" ? error.data?.data : error.data;
  }
  var init_call = __esm({
    "node_modules/viem/_esm/actions/public/call.js"() {
      init_exports();
      init_BlockOverrides();
      init_parseAccount();
      init_abis();
      init_contract2();
      init_contracts();
      init_base2();
      init_chain();
      init_contract();
      init_decodeFunctionResult();
      init_encodeDeployData();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_toHex();
      init_getCallError();
      init_extract();
      init_transactionRequest();
      init_createBatchScheduler();
      init_stateOverride2();
      init_assertRequest();
    }
  });

  // node_modules/viem/_esm/actions/public/readContract.js
  async function readContract(client, parameters) {
    const { abi: abi2, address, args, functionName, ...rest } = parameters;
    const calldata = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      const { data } = await getAction(client, call, "call")({
        ...rest,
        data: calldata,
        to: address
      });
      return decodeFunctionResult({
        abi: abi2,
        args,
        functionName,
        data: data || "0x"
      });
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/readContract",
        functionName
      });
    }
  }
  var init_readContract = __esm({
    "node_modules/viem/_esm/actions/public/readContract.js"() {
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_call();
    }
  });

  // node_modules/viem/_esm/actions/public/simulateContract.js
  async function simulateContract(client, parameters) {
    const { abi: abi2, address, args, dataSuffix, functionName, ...callRequest } = parameters;
    const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
    const calldata = encodeFunctionData({ abi: abi2, args, functionName });
    try {
      const { data } = await getAction(client, call, "call")({
        batch: false,
        data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...callRequest,
        account
      });
      const result = decodeFunctionResult({
        abi: abi2,
        args,
        functionName,
        data: data || "0x"
      });
      const minimizedAbi = abi2.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
      return {
        result,
        request: {
          abi: minimizedAbi,
          address,
          args,
          dataSuffix,
          functionName,
          ...callRequest,
          account
        }
      };
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_simulateContract = __esm({
    "node_modules/viem/_esm/actions/public/simulateContract.js"() {
      init_parseAccount();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_call();
    }
  });

  // node_modules/viem/_esm/utils/observe.js
  function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = () => listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners2 = getListeners();
      listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
      const listeners2 = getListeners();
      if (!listeners2.some((cb) => cb.id === callbackId))
        return;
      const cleanup2 = cleanupCache.get(observerId);
      if (listeners2.length === 1 && cleanup2) {
        const p = cleanup2();
        if (p instanceof Promise)
          p.catch(() => {
          });
      }
      unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
      ...listeners,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners && listeners.length > 0)
      return unwatch;
    const emit = {};
    for (const key in callbacks) {
      emit[key] = (...args) => {
        const listeners2 = getListeners();
        if (listeners2.length === 0)
          return;
        for (const listener of listeners2)
          listener.fns[key]?.(...args);
      };
    }
    const cleanup = fn(emit);
    if (typeof cleanup === "function")
      cleanupCache.set(observerId, cleanup);
    return unwatch;
  }
  var listenersCache, cleanupCache, callbackCount;
  var init_observe = __esm({
    "node_modules/viem/_esm/utils/observe.js"() {
      listenersCache = /* @__PURE__ */ new Map();
      cleanupCache = /* @__PURE__ */ new Map();
      callbackCount = 0;
    }
  });

  // node_modules/viem/_esm/utils/wait.js
  async function wait(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  var init_wait = __esm({
    "node_modules/viem/_esm/utils/wait.js"() {
    }
  });

  // node_modules/viem/_esm/utils/poll.js
  function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => active = false;
    const watch = async () => {
      let data = void 0;
      if (emitOnBegin)
        data = await fn({ unpoll: unwatch });
      const initialWait = await initialWaitTime?.(data) ?? interval;
      await wait(initialWait);
      const poll2 = async () => {
        if (!active)
          return;
        await fn({ unpoll: unwatch });
        await wait(interval);
        poll2();
      };
      poll2();
    };
    watch();
    return unwatch;
  }
  var init_poll = __esm({
    "node_modules/viem/_esm/utils/poll.js"() {
      init_wait();
    }
  });

  // node_modules/viem/_esm/utils/promise/withCache.js
  function getCache(cacheKey2) {
    const buildCache = (cacheKey3, cache) => ({
      clear: () => cache.delete(cacheKey3),
      get: () => cache.get(cacheKey3),
      set: (data) => cache.set(cacheKey3, data)
    });
    const promise = buildCache(cacheKey2, promiseCache);
    const response = buildCache(cacheKey2, responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
    const cache = getCache(cacheKey2);
    const response = cache.response.get();
    if (response && cacheTime > 0) {
      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
      if (age < cacheTime)
        return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
      promise = fn();
      cache.promise.set(promise);
    }
    try {
      const data = await promise;
      cache.response.set({ created: /* @__PURE__ */ new Date(), data });
      return data;
    } finally {
      cache.promise.clear();
    }
  }
  var promiseCache, responseCache;
  var init_withCache = __esm({
    "node_modules/viem/_esm/utils/promise/withCache.js"() {
      promiseCache = /* @__PURE__ */ new Map();
      responseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/actions/public/getBlockNumber.js
  async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
    const blockNumberHex = await withCache(() => client.request({
      method: "eth_blockNumber"
    }), { cacheKey: cacheKey(client.uid), cacheTime });
    return BigInt(blockNumberHex);
  }
  var cacheKey;
  var init_getBlockNumber = __esm({
    "node_modules/viem/_esm/actions/public/getBlockNumber.js"() {
      init_withCache();
      cacheKey = (id) => `blockNumber.${id}`;
    }
  });

  // node_modules/viem/_esm/actions/public/getFilterChanges.js
  async function getFilterChanges(_client, { filter }) {
    const strict = "strict" in filter && filter.strict;
    const logs = await filter.request({
      method: "eth_getFilterChanges",
      params: [filter.id]
    });
    if (typeof logs[0] === "string")
      return logs;
    const formattedLogs = logs.map((log) => formatLog(log));
    if (!("abi" in filter) || !filter.abi)
      return formattedLogs;
    return parseEventLogs({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  var init_getFilterChanges = __esm({
    "node_modules/viem/_esm/actions/public/getFilterChanges.js"() {
      init_parseEventLogs();
      init_log2();
    }
  });

  // node_modules/viem/_esm/actions/public/uninstallFilter.js
  async function uninstallFilter(_client, { filter }) {
    return filter.request({
      method: "eth_uninstallFilter",
      params: [filter.id]
    });
  }
  var init_uninstallFilter = __esm({
    "node_modules/viem/_esm/actions/public/uninstallFilter.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/watchContractEvent.js
  function watchContractEvent(client, parameters) {
    const { abi: abi2, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (typeof fromBlock === "bigint")
        return true;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const pollContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = stringify([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict,
        fromBlock
      ]);
      return observe(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        if (fromBlock !== void 0)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = poll(async () => {
          if (!initialized) {
            try {
              filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
                abi: abi2,
                address,
                args,
                eventName,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber < blockNumber) {
                logs = await getAction(client, getContractEvents, "getContractEvents")({
                  abi: abi2,
                  address,
                  args,
                  eventName,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber,
                  strict
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              for (const log of logs)
                emit.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof InvalidInputRpcError)
              initialized = false;
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = stringify([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict
      ]);
      let active = true;
      let unsubscribe = () => active = false;
      return observe(observerId, { onLogs, onError }, (emit) => {
        ;
        (async () => {
          try {
            const transport = (() => {
              if (client.transport.type === "fallback") {
                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
                if (!transport2)
                  return client.transport;
                return transport2.value;
              }
              return client.transport;
            })();
            const topics = eventName ? encodeEventTopics({
              abi: abi2,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = decodeEventLog({
                    abi: abi2,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = formatLog(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  emit.onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = formatLog(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  emit.onLogs([formatted]);
                }
              },
              onError(error) {
                emit.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
  }
  var init_watchContractEvent = __esm({
    "node_modules/viem/_esm/actions/public/watchContractEvent.js"() {
      init_abi();
      init_rpc();
      init_decodeEventLog();
      init_encodeEventTopics();
      init_log2();
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_createContractEventFilter();
      init_getBlockNumber();
      init_getContractEvents();
      init_getFilterChanges();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/errors/account.js
  var AccountNotFoundError, AccountTypeNotSupportedError;
  var init_account = __esm({
    "node_modules/viem/_esm/errors/account.js"() {
      init_base2();
      AccountNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath9 } = {}) {
          super([
            "Could not find an Account to execute with this Action.",
            "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
          ].join("\n"), {
            docsPath: docsPath9,
            docsSlug: "account",
            name: "AccountNotFoundError"
          });
        }
      };
      AccountTypeNotSupportedError = class extends BaseError2 {
        constructor({ docsPath: docsPath9, metaMessages, type }) {
          super(`Account type "${type}" is not supported.`, {
            docsPath: docsPath9,
            metaMessages,
            name: "AccountTypeNotSupportedError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/chain/assertCurrentChain.js
  function assertCurrentChain({ chain, currentChainId }) {
    if (!chain)
      throw new ChainNotFoundError();
    if (currentChainId !== chain.id)
      throw new ChainMismatchError({ chain, currentChainId });
  }
  var init_assertCurrentChain = __esm({
    "node_modules/viem/_esm/utils/chain/assertCurrentChain.js"() {
      init_chain();
    }
  });

  // node_modules/viem/_esm/utils/errors/getTransactionError.js
  function getTransactionError(err, { docsPath: docsPath9, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new TransactionExecutionError(cause, {
      docsPath: docsPath9,
      ...args
    });
  }
  var init_getTransactionError = __esm({
    "node_modules/viem/_esm/utils/errors/getTransactionError.js"() {
      init_node();
      init_transaction();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
  async function sendRawTransaction(client, { serializedTransaction }) {
    return client.request({
      method: "eth_sendRawTransaction",
      params: [serializedTransaction]
    }, { retryCount: 0 });
  }
  var init_sendRawTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/sendRawTransaction.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendTransaction.js
  async function sendTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
    if (typeof account_ === "undefined")
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    const account = account_ ? parseAccount(account_) : null;
    try {
      assertRequest(parameters);
      const to = await (async () => {
        if (parameters.to)
          return parameters.to;
        if (parameters.to === null)
          return void 0;
        if (authorizationList && authorizationList.length > 0)
          return await recoverAuthorizationAddress({
            authorization: authorizationList[0]
          }).catch(() => {
            throw new BaseError2("`to` is required. Could not infer from `authorizationList`.");
          });
        return void 0;
      })();
      if (account?.type === "json-rpc" || account === null) {
        let chainId;
        if (chain !== null) {
          chainId = await getAction(client, getChainId, "getChainId")({});
          assertCurrentChain({
            currentChainId: chainId,
            chain
          });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || formatTransactionRequest;
        const request2 = format({
          // Pick out extra data that might exist on the chain's transaction request type.
          ...extract(rest, { format: chainFormat }),
          accessList,
          authorizationList,
          blobs,
          chainId,
          data,
          from: account?.address,
          gas,
          gasPrice,
          maxFeePerBlobGas,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          type,
          value
        });
        const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
        const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
        try {
          return await client.request({
            method,
            params: [request2]
          }, { retryCount: 0 });
        } catch (e) {
          if (isWalletNamespaceSupported === false)
            throw e;
          const error = e;
          if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError") {
            return await client.request({
              method: "wallet_sendTransaction",
              params: [request2]
            }, { retryCount: 0 }).then((hash2) => {
              supportsWalletNamespace.set(client.uid, true);
              return hash2;
            }).catch((e2) => {
              const walletNamespaceError = e2;
              if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
                supportsWalletNamespace.set(client.uid, false);
                throw error;
              }
              throw walletNamespaceError;
            });
          }
          throw error;
        }
      }
      if (account?.type === "local") {
        const request2 = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
          account,
          accessList,
          authorizationList,
          blobs,
          chain,
          data,
          gas,
          gasPrice,
          maxFeePerBlobGas,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          nonceManager: account.nonceManager,
          parameters: [...defaultParameters, "sidecars"],
          type,
          value,
          ...rest,
          to
        });
        const serializer = chain?.serializers?.transaction;
        const serializedTransaction = await account.signTransaction(request2, {
          serializer
        });
        return await getAction(client, sendRawTransaction, "sendRawTransaction")({
          serializedTransaction
        });
      }
      if (account?.type === "smart")
        throw new AccountTypeNotSupportedError({
          metaMessages: [
            "Consider using the `sendUserOperation` Action instead."
          ],
          docsPath: "/docs/actions/bundler/sendUserOperation",
          type: "smart"
        });
      throw new AccountTypeNotSupportedError({
        docsPath: "/docs/actions/wallet/sendTransaction",
        type: account?.type
      });
    } catch (err) {
      if (err instanceof AccountTypeNotSupportedError)
        throw err;
      throw getTransactionError(err, {
        ...parameters,
        account,
        chain: parameters.chain || void 0
      });
    }
  }
  var supportsWalletNamespace;
  var init_sendTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/sendTransaction.js"() {
      init_parseAccount();
      init_account();
      init_base2();
      init_recoverAuthorizationAddress();
      init_assertCurrentChain();
      init_getTransactionError();
      init_extract();
      init_transactionRequest();
      init_getAction();
      init_lru();
      init_assertRequest();
      init_getChainId();
      init_prepareTransactionRequest();
      init_sendRawTransaction();
      supportsWalletNamespace = new LruMap(128);
    }
  });

  // node_modules/viem/_esm/actions/wallet/writeContract.js
  async function writeContract(client, parameters) {
    const { abi: abi2, account: account_ = client.account, address, args, dataSuffix, functionName, ...request2 } = parameters;
    if (typeof account_ === "undefined")
      throw new AccountNotFoundError({
        docsPath: "/docs/contract/writeContract"
      });
    const account = account_ ? parseAccount(account_) : null;
    const data = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      return await getAction(client, sendTransaction, "sendTransaction")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        account,
        ...request2
      });
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/writeContract",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_writeContract = __esm({
    "node_modules/viem/_esm/actions/wallet/writeContract.js"() {
      init_parseAccount();
      init_account();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_sendTransaction();
    }
  });

  // node_modules/viem/_esm/actions/getContract.js
  function getContract({ abi: abi2, address, client: client_ }) {
    const client = client_;
    const [publicClient, walletClient] = (() => {
      if (!client)
        return [void 0, void 0];
      if ("public" in client && "wallet" in client)
        return [client.public, client.wallet];
      if ("public" in client)
        return [client.public, void 0];
      if ("wallet" in client)
        return [void 0, client.wallet];
      return [client, client];
    })();
    const hasPublicClient = publicClient !== void 0 && publicClient !== null;
    const hasWalletClient = walletClient !== void 0 && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi2) {
      if (item.type === "function")
        if (item.stateMutability === "view" || item.stateMutability === "pure")
          hasReadFunction = true;
        else
          hasWriteFunction = true;
      else if (item.type === "event")
        hasEvent = true;
      if (hasReadFunction && hasWriteFunction && hasEvent)
        break;
    }
    if (hasPublicClient) {
      if (hasReadFunction)
        contract.read = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options } = getFunctionParameters(parameters);
              return getAction(publicClient, readContract, "readContract")({
                abi: abi2,
                address,
                functionName,
                args,
                ...options
              });
            };
          }
        });
      if (hasWriteFunction)
        contract.simulate = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options } = getFunctionParameters(parameters);
              return getAction(publicClient, simulateContract, "simulateContract")({
                abi: abi2,
                address,
                functionName,
                args,
                ...options
              });
            };
          }
        });
      if (hasEvent) {
        contract.createEventFilter = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi2.find((x) => x.type === "event" && x.name === eventName);
              const { args, options } = getEventParameters(parameters, abiEvent);
              return getAction(publicClient, createContractEventFilter, "createContractEventFilter")({
                abi: abi2,
                address,
                eventName,
                args,
                ...options
              });
            };
          }
        });
        contract.getEvents = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi2.find((x) => x.type === "event" && x.name === eventName);
              const { args, options } = getEventParameters(parameters, abiEvent);
              return getAction(publicClient, getContractEvents, "getContractEvents")({
                abi: abi2,
                address,
                eventName,
                args,
                ...options
              });
            };
          }
        });
        contract.watchEvent = new Proxy({}, {
          get(_, eventName) {
            return (...parameters) => {
              const abiEvent = abi2.find((x) => x.type === "event" && x.name === eventName);
              const { args, options } = getEventParameters(parameters, abiEvent);
              return getAction(publicClient, watchContractEvent, "watchContractEvent")({
                abi: abi2,
                address,
                eventName,
                args,
                ...options
              });
            };
          }
        });
      }
    }
    if (hasWalletClient) {
      if (hasWriteFunction)
        contract.write = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options } = getFunctionParameters(parameters);
              return getAction(walletClient, writeContract, "writeContract")({
                abi: abi2,
                address,
                functionName,
                args,
                ...options
              });
            };
          }
        });
    }
    if (hasPublicClient || hasWalletClient) {
      if (hasWriteFunction)
        contract.estimateGas = new Proxy({}, {
          get(_, functionName) {
            return (...parameters) => {
              const { args, options } = getFunctionParameters(parameters);
              const client2 = publicClient ?? walletClient;
              return getAction(client2, estimateContractGas, "estimateContractGas")({
                abi: abi2,
                address,
                functionName,
                args,
                ...options,
                account: options.account ?? walletClient.account
              });
            };
          }
        });
    }
    contract.address = address;
    contract.abi = abi2;
    return contract;
  }
  function getFunctionParameters(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
  }
  function getEventParameters(values, abiEvent) {
    let hasArgs = false;
    if (Array.isArray(values[0]))
      hasArgs = true;
    else if (values.length === 1) {
      hasArgs = abiEvent.inputs.some((x) => x.indexed);
    } else if (values.length === 2) {
      hasArgs = true;
    }
    const args = hasArgs ? values[0] : void 0;
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
  }
  var init_getContract = __esm({
    "node_modules/viem/_esm/actions/getContract.js"() {
      init_getAction();
      init_createContractEventFilter();
      init_estimateContractGas();
      init_getContractEvents();
      init_readContract();
      init_simulateContract();
      init_watchContractEvent();
      init_writeContract();
    }
  });

  // node_modules/viem/_esm/utils/formatters/transactionReceipt.js
  function formatTransactionReceipt(transactionReceipt) {
    const receipt = {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
    };
    if (transactionReceipt.blobGasPrice)
      receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed)
      receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
  }
  var receiptStatuses, defineTransactionReceipt;
  var init_transactionReceipt = __esm({
    "node_modules/viem/_esm/utils/formatters/transactionReceipt.js"() {
      init_fromHex();
      init_formatter();
      init_log2();
      init_transaction2();
      receiptStatuses = {
        "0x0": "reverted",
        "0x1": "success"
      };
      defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendCalls.js
  async function sendCalls(client, parameters) {
    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version: version4 = "2.0.0" } = parameters;
    const account = account_ ? parseAccount(account_) : null;
    const calls = parameters.calls.map((call_) => {
      const call2 = call_;
      const data = call2.abi ? encodeFunctionData({
        abi: call2.abi,
        functionName: call2.functionName,
        args: call2.args
      }) : call2.data;
      return {
        data: call2.dataSuffix && data ? concat([data, call2.dataSuffix]) : data,
        to: call2.to,
        value: call2.value ? numberToHex(call2.value) : void 0
      };
    });
    try {
      const response = await client.request({
        method: "wallet_sendCalls",
        params: [
          {
            atomicRequired: forceAtomic,
            calls,
            capabilities,
            chainId: numberToHex(chain.id),
            from: account?.address,
            id,
            version: version4
          }
        ]
      }, { retryCount: 0 });
      if (typeof response === "string")
        return { id: response };
      return response;
    } catch (err) {
      const error = err;
      if (experimental_fallback && (error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError" || error.name === "UnknownRpcError" || error.details.toLowerCase().includes("does not exist / is not available") || error.details.toLowerCase().includes("missing or invalid. request()") || error.details.toLowerCase().includes("did not match any variant of untagged enum") || error.details.toLowerCase().includes("account upgraded to unsupported contract") || error.details.toLowerCase().includes("eip-7702 not supported") || error.details.toLowerCase().includes("unsupported wc_ method"))) {
        if (capabilities) {
          const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);
          if (hasNonOptionalCapability) {
            const message = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
            throw new UnsupportedNonOptionalCapabilityError(new BaseError2(message, {
              details: message
            }));
          }
        }
        if (forceAtomic && calls.length > 1) {
          const message = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
          throw new AtomicityNotSupportedError(new BaseError2(message, {
            details: message
          }));
        }
        const promises = [];
        for (const call2 of calls) {
          const promise = sendTransaction(client, {
            account,
            chain,
            data: call2.data,
            to: call2.to,
            value: call2.value ? hexToBigInt(call2.value) : void 0
          });
          promises.push(promise);
          if (experimental_fallbackDelay > 0)
            await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));
        }
        const results = await Promise.allSettled(promises);
        if (results.every((r) => r.status === "rejected"))
          throw results[0].reason;
        const hashes = results.map((result) => {
          if (result.status === "fulfilled")
            return result.value;
          return fallbackTransactionErrorMagicIdentifier;
        });
        return {
          id: concat([
            ...hashes,
            numberToHex(chain.id, { size: 32 }),
            fallbackMagicIdentifier
          ])
        };
      }
      throw getTransactionError(err, {
        ...parameters,
        account,
        chain: parameters.chain
      });
    }
  }
  var fallbackMagicIdentifier, fallbackTransactionErrorMagicIdentifier;
  var init_sendCalls = __esm({
    "node_modules/viem/_esm/actions/wallet/sendCalls.js"() {
      init_parseAccount();
      init_base2();
      init_rpc();
      init_encodeFunctionData();
      init_concat();
      init_fromHex();
      init_toHex();
      init_getTransactionError();
      init_sendTransaction();
      fallbackMagicIdentifier = "0x5792579257925792579257925792579257925792579257925792579257925792";
      fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
        size: 32
      });
    }
  });

  // node_modules/viem/_esm/actions/wallet/getCallsStatus.js
  async function getCallsStatus(client, parameters) {
    async function getStatus(id) {
      const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2));
      if (isTransactions) {
        const chainId2 = trim(sliceHex(id, -64, -32));
        const hashes = sliceHex(id, 0, -64).slice(2).match(/.{1,64}/g);
        const receipts2 = await Promise.all(hashes.map((hash2) => fallbackTransactionErrorMagicIdentifier.slice(2) !== hash2 ? client.request({
          method: "eth_getTransactionReceipt",
          params: [`0x${hash2}`]
        }, { dedupe: true }) : void 0));
        const status2 = (() => {
          if (receipts2.some((r) => r === null))
            return 100;
          if (receipts2.every((r) => r?.status === "0x1"))
            return 200;
          if (receipts2.every((r) => r?.status === "0x0"))
            return 500;
          return 600;
        })();
        return {
          atomic: false,
          chainId: hexToNumber2(chainId2),
          receipts: receipts2.filter(Boolean),
          status: status2,
          version: "2.0.0"
        };
      }
      return client.request({
        method: "wallet_getCallsStatus",
        params: [id]
      });
    }
    const { atomic = false, chainId, receipts, version: version4 = "2.0.0", ...response } = await getStatus(parameters.id);
    const [status, statusCode] = (() => {
      const statusCode2 = response.status;
      if (statusCode2 >= 100 && statusCode2 < 200)
        return ["pending", statusCode2];
      if (statusCode2 >= 200 && statusCode2 < 300)
        return ["success", statusCode2];
      if (statusCode2 >= 300 && statusCode2 < 700)
        return ["failure", statusCode2];
      if (statusCode2 === "CONFIRMED")
        return ["success", 200];
      if (statusCode2 === "PENDING")
        return ["pending", 100];
      return [void 0, statusCode2];
    })();
    return {
      ...response,
      atomic,
      // @ts-expect-error: for backwards compatibility
      chainId: chainId ? hexToNumber2(chainId) : void 0,
      receipts: receipts?.map((receipt) => ({
        ...receipt,
        blockNumber: hexToBigInt(receipt.blockNumber),
        gasUsed: hexToBigInt(receipt.gasUsed),
        status: receiptStatuses[receipt.status]
      })) ?? [],
      statusCode,
      status,
      version: version4
    };
  }
  var init_getCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/getCallsStatus.js"() {
      init_slice();
      init_trim();
      init_fromHex();
      init_transactionReceipt();
      init_sendCalls();
    }
  });

  // node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js
  async function waitForCallsStatus(client, parameters) {
    const { id, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode >= 200, timeout = 6e4 } = parameters;
    const observerId = stringify(["waitForCallsStatus", client.uid, id]);
    const { promise, resolve, reject } = withResolvers();
    let timer = void 0;
    const unobserve = observe(observerId, { resolve, reject }, (emit) => {
      const unpoll = poll(async () => {
        const done = (fn) => {
          clearTimeout(timer);
          unpoll();
          fn();
          unobserve();
        };
        try {
          const result = await getCallsStatus(client, { id });
          if (!status(result))
            return;
          done(() => emit.resolve(result));
        } catch (error) {
          done(() => emit.reject(error));
        }
      }, {
        interval: pollingInterval,
        emitOnBegin: true
      });
      return unpoll;
    });
    timer = timeout ? setTimeout(() => {
      unobserve();
      clearTimeout(timer);
      reject(new WaitForCallsStatusTimeoutError({ id }));
    }, timeout) : void 0;
    return await promise;
  }
  var WaitForCallsStatusTimeoutError;
  var init_waitForCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js"() {
      init_base2();
      init_observe();
      init_poll();
      init_withResolvers();
      init_stringify();
      init_getCallsStatus();
      WaitForCallsStatusTimeoutError = class extends BaseError2 {
        constructor({ id }) {
          super(`Timed out while waiting for call bundle with id "${id}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/uid.js
  function uid(length = 11) {
    if (!buffer || index + length > size4 * 2) {
      buffer = "";
      index = 0;
      for (let i = 0; i < size4; i++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length);
  }
  var size4, index, buffer;
  var init_uid = __esm({
    "node_modules/viem/_esm/utils/uid.js"() {
      size4 = 256;
      index = size4;
    }
  });

  // node_modules/viem/_esm/clients/createClient.js
  function createClient(parameters) {
    const { batch, chain, ccipRead, key = "base", name = "Base Client", type = "base" } = parameters;
    const experimental_blockTag = parameters.experimental_blockTag ?? (typeof chain?.experimental_preconfirmationTime === "number" ? "pending" : void 0);
    const blockTime = chain?.blockTime ?? 12e3;
    const defaultPollingInterval = Math.min(Math.max(Math.floor(blockTime / 2), 500), 4e3);
    const pollingInterval = parameters.pollingInterval ?? defaultPollingInterval;
    const cacheTime = parameters.cacheTime ?? pollingInterval;
    const account = parameters.account ? parseAccount(parameters.account) : void 0;
    const { config: config2, request: request2, value } = parameters.transport({
      chain,
      pollingInterval
    });
    const transport = { ...config2, ...value };
    const client = {
      account,
      batch,
      cacheTime,
      ccipRead,
      chain,
      key,
      name,
      pollingInterval,
      request: request2,
      transport,
      type,
      uid: uid(),
      ...experimental_blockTag ? { experimental_blockTag } : {}
    };
    function extend(base2) {
      return (extendFn) => {
        const extended = extendFn(base2);
        for (const key2 in client)
          delete extended[key2];
        const combined = { ...base2, ...extended };
        return Object.assign(combined, { extend: extend(combined) });
      };
    }
    return Object.assign(client, { extend: extend(client) });
  }
  function rpcSchema() {
    return null;
  }
  var init_createClient = __esm({
    "node_modules/viem/_esm/clients/createClient.js"() {
      init_parseAccount();
      init_uid();
    }
  });

  // node_modules/viem/_esm/utils/promise/withDedupe.js
  function withDedupe(fn, { enabled = true, id }) {
    if (!enabled || !id)
      return fn();
    if (promiseCache2.get(id))
      return promiseCache2.get(id);
    const promise = fn().finally(() => promiseCache2.delete(id));
    promiseCache2.set(id, promise);
    return promise;
  }
  var promiseCache2;
  var init_withDedupe = __esm({
    "node_modules/viem/_esm/utils/promise/withDedupe.js"() {
      init_lru();
      promiseCache2 = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/promise/withRetry.js
  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay)
            await wait(delay);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data = await fn();
          resolve(data);
        } catch (err) {
          if (count < retryCount && await shouldRetry2({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }
  var init_withRetry = __esm({
    "node_modules/viem/_esm/utils/promise/withRetry.js"() {
      init_wait();
    }
  });

  // node_modules/viem/_esm/utils/buildRequest.js
  function buildRequest(request2, options = {}) {
    return async (args, overrideOptions = {}) => {
      const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
        ...options,
        ...overrideOptions
      };
      const { method } = args;
      if (methods?.exclude?.includes(method))
        throw new MethodNotSupportedRpcError(new Error("method not supported"), {
          method
        });
      if (methods?.include && !methods.include.includes(method))
        throw new MethodNotSupportedRpcError(new Error("method not supported"), {
          method
        });
      const requestId = dedupe ? stringToHex(`${uid2}.${stringify(args)}`) : void 0;
      return withDedupe(() => withRetry(async () => {
        try {
          return await request2(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            // -32700
            case ParseRpcError.code:
              throw new ParseRpcError(err);
            // -32600
            case InvalidRequestRpcError.code:
              throw new InvalidRequestRpcError(err);
            // -32601
            case MethodNotFoundRpcError.code:
              throw new MethodNotFoundRpcError(err, { method: args.method });
            // -32602
            case InvalidParamsRpcError.code:
              throw new InvalidParamsRpcError(err);
            // -32603
            case InternalRpcError.code:
              throw new InternalRpcError(err);
            // -32000
            case InvalidInputRpcError.code:
              throw new InvalidInputRpcError(err);
            // -32001
            case ResourceNotFoundRpcError.code:
              throw new ResourceNotFoundRpcError(err);
            // -32002
            case ResourceUnavailableRpcError.code:
              throw new ResourceUnavailableRpcError(err);
            // -32003
            case TransactionRejectedRpcError.code:
              throw new TransactionRejectedRpcError(err);
            // -32004
            case MethodNotSupportedRpcError.code:
              throw new MethodNotSupportedRpcError(err, {
                method: args.method
              });
            // -32005
            case LimitExceededRpcError.code:
              throw new LimitExceededRpcError(err);
            // -32006
            case JsonRpcVersionUnsupportedError.code:
              throw new JsonRpcVersionUnsupportedError(err);
            // 4001
            case UserRejectedRequestError.code:
              throw new UserRejectedRequestError(err);
            // 4100
            case UnauthorizedProviderError.code:
              throw new UnauthorizedProviderError(err);
            // 4200
            case UnsupportedProviderMethodError.code:
              throw new UnsupportedProviderMethodError(err);
            // 4900
            case ProviderDisconnectedError.code:
              throw new ProviderDisconnectedError(err);
            // 4901
            case ChainDisconnectedError.code:
              throw new ChainDisconnectedError(err);
            // 4902
            case SwitchChainError.code:
              throw new SwitchChainError(err);
            // 5700
            case UnsupportedNonOptionalCapabilityError.code:
              throw new UnsupportedNonOptionalCapabilityError(err);
            // 5710
            case UnsupportedChainIdError.code:
              throw new UnsupportedChainIdError(err);
            // 5720
            case DuplicateIdError.code:
              throw new DuplicateIdError(err);
            // 5730
            case UnknownBundleIdError.code:
              throw new UnknownBundleIdError(err);
            // 5740
            case BundleTooLargeError.code:
              throw new BundleTooLargeError(err);
            // 5750
            case AtomicReadyWalletRejectedUpgradeError.code:
              throw new AtomicReadyWalletRejectedUpgradeError(err);
            // 5760
            case AtomicityNotSupportedError.code:
              throw new AtomicityNotSupportedError(err);
            // CAIP-25: User Rejected Error
            // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
            case 5e3:
              throw new UserRejectedRequestError(err);
            default:
              if (err_ instanceof BaseError2)
                throw err_;
              throw new UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return Number.parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => shouldRetry(error)
      }), { enabled: dedupe, id: requestId });
    };
  }
  function shouldRetry(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === -1)
        return true;
      if (error.code === LimitExceededRpcError.code)
        return true;
      if (error.code === InternalRpcError.code)
        return true;
      return false;
    }
    if (error instanceof HttpRequestError && error.status) {
      if (error.status === 403)
        return true;
      if (error.status === 408)
        return true;
      if (error.status === 413)
        return true;
      if (error.status === 429)
        return true;
      if (error.status === 500)
        return true;
      if (error.status === 502)
        return true;
      if (error.status === 503)
        return true;
      if (error.status === 504)
        return true;
      return false;
    }
    return true;
  }
  var init_buildRequest = __esm({
    "node_modules/viem/_esm/utils/buildRequest.js"() {
      init_base2();
      init_request();
      init_rpc();
      init_toHex();
      init_withDedupe();
      init_withRetry();
      init_stringify();
    }
  });

  // node_modules/viem/_esm/clients/transports/createTransport.js
  function createTransport({ key, methods, name, request: request2, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    const uid2 = uid();
    return {
      config: {
        key,
        methods,
        name,
        request: request2,
        retryCount,
        retryDelay,
        timeout,
        type
      },
      request: buildRequest(request2, { methods, retryCount, retryDelay, uid: uid2 }),
      value
    };
  }
  var init_createTransport = __esm({
    "node_modules/viem/_esm/clients/transports/createTransport.js"() {
      init_buildRequest();
      init_uid();
    }
  });

  // node_modules/viem/_esm/clients/transports/custom.js
  function custom(provider, config2 = {}) {
    const { key = "custom", methods, name = "Custom Provider", retryDelay } = config2;
    return ({ retryCount: defaultRetryCount }) => createTransport({
      key,
      methods,
      name,
      request: provider.request.bind(provider),
      retryCount: config2.retryCount ?? defaultRetryCount,
      retryDelay,
      type: "custom"
    });
  }
  var init_custom = __esm({
    "node_modules/viem/_esm/clients/transports/custom.js"() {
      init_createTransport();
    }
  });

  // node_modules/viem/_esm/clients/transports/fallback.js
  function fallback(transports_, config2 = {}) {
    const { key = "fallback", name = "Fallback", rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config2;
    return ({ chain, pollingInterval = 4e3, timeout, ...rest }) => {
      let transports = transports_;
      let onResponse = () => {
      };
      const transport = createTransport({
        key,
        name,
        async request({ method, params }) {
          let includes;
          const fetch3 = async (i = 0) => {
            const transport2 = transports[i]({
              ...rest,
              chain,
              retryCount: 0,
              timeout
            });
            try {
              const response = await transport2.request({
                method,
                params
              });
              onResponse({
                method,
                params,
                response,
                transport: transport2,
                status: "success"
              });
              return response;
            } catch (err) {
              onResponse({
                error: err,
                method,
                params,
                transport: transport2,
                status: "error"
              });
              if (shouldThrow_(err))
                throw err;
              if (i === transports.length - 1)
                throw err;
              includes ??= transports.slice(i + 1).some((transport3) => {
                const { include, exclude } = transport3({ chain }).config.methods || {};
                if (include)
                  return include.includes(method);
                if (exclude)
                  return !exclude.includes(method);
                return true;
              });
              if (!includes)
                throw err;
              return fetch3(i + 1);
            }
          };
          return fetch3();
        },
        retryCount,
        retryDelay,
        type: "fallback"
      }, {
        onResponse: (fn) => onResponse = fn,
        transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
      });
      if (rank) {
        const rankOptions = typeof rank === "object" ? rank : {};
        rankTransports({
          chain,
          interval: rankOptions.interval ?? pollingInterval,
          onTransports: (transports_2) => transports = transports_2,
          ping: rankOptions.ping,
          sampleCount: rankOptions.sampleCount,
          timeout: rankOptions.timeout,
          transports,
          weights: rankOptions.weights
        });
      }
      return transport;
    };
  }
  function shouldThrow(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5e3)
        return true;
    }
    return false;
  }
  function rankTransports({ chain, interval = 4e3, onTransports, ping, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
      const sample = await Promise.all(transports.map(async (transport) => {
        const transport_ = transport({ chain, retryCount: 0, timeout });
        const start = Date.now();
        let end;
        let success;
        try {
          await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
          success = 1;
        } catch {
          success = 0;
        } finally {
          end = Date.now();
        }
        const latency = end - start;
        return { latency, success };
      }));
      samples.push(sample);
      if (samples.length > sampleCount)
        samples.shift();
      const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
      const scores = transports.map((_, i) => {
        const latencies = samples.map((sample2) => sample2[i].latency);
        const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
        const latencyScore = 1 - meanLatency / maxLatency;
        const successes = samples.map((sample2) => sample2[i].success);
        const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
        if (stabilityScore === 0)
          return [0, i];
        return [
          latencyWeight * latencyScore + stabilityWeight * stabilityScore,
          i
        ];
      }).sort((a, b) => b[0] - a[0]);
      onTransports(scores.map(([, i]) => transports[i]));
      await wait(interval);
      rankTransports_();
    };
    rankTransports_();
  }
  var init_fallback = __esm({
    "node_modules/viem/_esm/clients/transports/fallback.js"() {
      init_node();
      init_rpc();
      init_wait();
      init_createTransport();
    }
  });

  // node_modules/viem/_esm/errors/transport.js
  var UrlRequiredError;
  var init_transport = __esm({
    "node_modules/viem/_esm/errors/transport.js"() {
      init_base2();
      UrlRequiredError = class extends BaseError2 {
        constructor() {
          super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro",
            name: "UrlRequiredError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/promise/withTimeout.js
  function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
    return new Promise((resolve, reject) => {
      ;
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController();
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn({ signal: controller?.signal || null }));
        } catch (err) {
          if (err?.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }
  var init_withTimeout = __esm({
    "node_modules/viem/_esm/utils/promise/withTimeout.js"() {
    }
  });

  // node_modules/viem/_esm/utils/rpc/id.js
  function createIdStore() {
    return {
      current: 0,
      take() {
        return this.current++;
      },
      reset() {
        this.current = 0;
      }
    };
  }
  var idCache;
  var init_id = __esm({
    "node_modules/viem/_esm/utils/rpc/id.js"() {
      idCache = /* @__PURE__ */ createIdStore();
    }
  });

  // node_modules/viem/_esm/utils/rpc/http.js
  function getHttpRpcClient(url, options = {}) {
    return {
      async request(params) {
        const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
        const fetchOptions = {
          ...options.fetchOptions ?? {},
          ...params.fetchOptions ?? {}
        };
        const { headers, method, signal: signal_ } = fetchOptions;
        try {
          const response = await withTimeout(async ({ signal }) => {
            const init2 = {
              ...fetchOptions,
              body: Array.isArray(body) ? stringify(body.map((body2) => ({
                jsonrpc: "2.0",
                id: body2.id ?? idCache.take(),
                ...body2
              }))) : stringify({
                jsonrpc: "2.0",
                id: body.id ?? idCache.take(),
                ...body
              }),
              headers: {
                "Content-Type": "application/json",
                ...headers
              },
              method: method || "POST",
              signal: signal_ || (timeout > 0 ? signal : null)
            };
            const request2 = new Request(url, init2);
            const args = await onRequest?.(request2, init2) ?? { ...init2, url };
            const response2 = await fetch(args.url ?? url, args);
            return response2;
          }, {
            errorInstance: new TimeoutError({ body, url }),
            timeout,
            signal: true
          });
          if (onResponse)
            await onResponse(response);
          let data;
          if (response.headers.get("Content-Type")?.startsWith("application/json"))
            data = await response.json();
          else {
            data = await response.text();
            try {
              data = JSON.parse(data || "{}");
            } catch (err) {
              if (response.ok)
                throw err;
              data = { error: data };
            }
          }
          if (!response.ok) {
            throw new HttpRequestError({
              body,
              details: stringify(data.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
          }
          return data;
        } catch (err) {
          if (err instanceof HttpRequestError)
            throw err;
          if (err instanceof TimeoutError)
            throw err;
          throw new HttpRequestError({
            body,
            cause: err,
            url
          });
        }
      }
    };
  }
  var init_http = __esm({
    "node_modules/viem/_esm/utils/rpc/http.js"() {
      init_request();
      init_withTimeout();
      init_stringify();
      init_id();
    }
  });

  // node_modules/viem/_esm/clients/transports/http.js
  function http(url, config2 = {}) {
    const { batch, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config2;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.http[0];
      if (!url_)
        throw new UrlRequiredError();
      const rpcClient = getHttpRpcClient(url_, {
        fetchOptions,
        onRequest: onFetchRequest,
        onResponse: onFetchResponse,
        timeout
      });
      return createTransport({
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const { schedule } = createBatchScheduler({
            id: url_,
            wait: wait2,
            shouldSplitBatch(requests) {
              return requests.length > batchSize;
            },
            fn: (body2) => rpcClient.request({
              body: body2
            }),
            sort: (a, b) => a.id - b.id
          });
          const fn = async (body2) => batch ? schedule(body2) : [
            await rpcClient.request({
              body: body2
            })
          ];
          const [{ error, result }] = await fn(body);
          if (raw)
            return { error, result };
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        fetchOptions,
        url: url_
      });
    };
  }
  var init_http2 = __esm({
    "node_modules/viem/_esm/clients/transports/http.js"() {
      init_request();
      init_transport();
      init_createBatchScheduler();
      init_http();
      init_createTransport();
    }
  });

  // node_modules/viem/_esm/utils/ens/errors.js
  function isNullUniversalResolverError(err, callType) {
    if (!(err instanceof BaseError2))
      return false;
    const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
    if (!(cause instanceof ContractFunctionRevertedError))
      return false;
    if (cause.data?.errorName === "ResolverNotFound")
      return true;
    if (cause.data?.errorName === "ResolverWildcardNotSupported")
      return true;
    if (cause.data?.errorName === "ResolverNotContract")
      return true;
    if (cause.data?.errorName === "ResolverError")
      return true;
    if (cause.data?.errorName === "HttpError")
      return true;
    if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
      return true;
    if (callType === "reverse" && cause.reason === panicReasons[50])
      return true;
    return false;
  }
  var init_errors4 = __esm({
    "node_modules/viem/_esm/utils/ens/errors.js"() {
      init_solidity();
      init_base2();
      init_contract();
    }
  });

  // node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
  function encodedLabelToLabelhash(label) {
    if (label.length !== 66)
      return null;
    if (label.indexOf("[") !== 0)
      return null;
    if (label.indexOf("]") !== 65)
      return null;
    const hash2 = `0x${label.slice(1, 65)}`;
    if (!isHex(hash2))
      return null;
    return hash2;
  }
  var init_encodedLabelToLabelhash = __esm({
    "node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/_esm/utils/ens/namehash.js
  function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
      return bytesToHex3(result);
    const labels = name.split(".");
    for (let i = labels.length - 1; i >= 0; i -= 1) {
      const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
      const hashed = hashFromEncodedLabel ? toBytes2(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
      result = keccak256(concat([result, hashed]), "bytes");
    }
    return bytesToHex3(result);
  }
  var init_namehash = __esm({
    "node_modules/viem/_esm/utils/ens/namehash.js"() {
      init_concat();
      init_toBytes();
      init_toHex();
      init_keccak256();
      init_encodedLabelToLabelhash();
    }
  });

  // node_modules/viem/_esm/utils/ens/encodeLabelhash.js
  function encodeLabelhash(hash2) {
    return `[${hash2.slice(2)}]`;
  }
  var init_encodeLabelhash = __esm({
    "node_modules/viem/_esm/utils/ens/encodeLabelhash.js"() {
    }
  });

  // node_modules/viem/_esm/utils/ens/labelhash.js
  function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
      return bytesToHex3(result);
    return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
  }
  var init_labelhash = __esm({
    "node_modules/viem/_esm/utils/ens/labelhash.js"() {
      init_toBytes();
      init_toHex();
      init_keccak256();
      init_encodedLabelToLabelhash();
    }
  });

  // node_modules/viem/_esm/utils/ens/packetToBytes.js
  function packetToBytes(packet) {
    const value = packet.replace(/^\.|\.$/gm, "");
    if (value.length === 0)
      return new Uint8Array(1);
    const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
    let offset = 0;
    const list = value.split(".");
    for (let i = 0; i < list.length; i++) {
      let encoded = stringToBytes(list[i]);
      if (encoded.byteLength > 255)
        encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
      bytes[offset] = encoded.length;
      bytes.set(encoded, offset + 1);
      offset += encoded.length + 1;
    }
    if (bytes.byteLength !== offset + 1)
      return bytes.slice(0, offset + 1);
    return bytes;
  }
  var init_packetToBytes = __esm({
    "node_modules/viem/_esm/utils/ens/packetToBytes.js"() {
      init_toBytes();
      init_encodeLabelhash();
      init_labelhash();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsAddress.js
  async function getEnsAddress(client, parameters) {
    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      return null;
    try {
      const functionData = encodeFunctionData({
        abi: addressResolverAbi,
        functionName: "addr",
        ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
      });
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverResolveAbi,
        functionName: "resolve",
        args: [
          toHex2(packetToBytes(name)),
          functionData,
          gatewayUrls ?? [localBatchGatewayUrl]
        ],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const res = await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const address = decodeFunctionResult({
        abi: addressResolverAbi,
        args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,
        functionName: "addr",
        data: res[0]
      });
      if (address === "0x")
        return null;
      if (trim(address) === "0x00")
        return null;
      return address;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "resolve"))
        return null;
      throw err;
    }
  }
  var init_getEnsAddress = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsAddress.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_trim();
      init_toHex();
      init_errors4();
      init_localBatchGatewayRequest();
      init_namehash();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/errors/ens.js
  var EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUriResolutionError, EnsAvatarUnsupportedNamespaceError;
  var init_ens = __esm({
    "node_modules/viem/_esm/errors/ens.js"() {
      init_base2();
      EnsAvatarInvalidMetadataError = class extends BaseError2 {
        constructor({ data }) {
          super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: [
              "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
              "",
              `Provided data: ${JSON.stringify(data)}`
            ],
            name: "EnsAvatarInvalidMetadataError"
          });
        }
      };
      EnsAvatarInvalidNftUriError = class extends BaseError2 {
        constructor({ reason }) {
          super(`ENS NFT avatar URI is invalid. ${reason}`, {
            name: "EnsAvatarInvalidNftUriError"
          });
        }
      };
      EnsAvatarUriResolutionError = class extends BaseError2 {
        constructor({ uri }) {
          super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
        }
      };
      EnsAvatarUnsupportedNamespaceError = class extends BaseError2 {
        constructor({ namespace }) {
          super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/ens/avatar/utils.js
  async function isImageUri(uri) {
    try {
      const res = await fetch(uri, { method: "HEAD" });
      if (res.status === 200) {
        const contentType = res.headers.get("content-type");
        return contentType?.startsWith("image/");
      }
      return false;
    } catch (error) {
      if (typeof error === "object" && typeof error.response !== "undefined") {
        return false;
      }
      if (!globalThis.hasOwnProperty("Image"))
        return false;
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          resolve(true);
        };
        img.onerror = () => {
          resolve(false);
        };
        img.src = uri;
      });
    }
  }
  function getGateway(custom2, defaultGateway) {
    if (!custom2)
      return defaultGateway;
    if (custom2.endsWith("/"))
      return custom2.slice(0, -1);
    return custom2;
  }
  function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
      return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
      let replacedUri = uri;
      if (gatewayUrls?.arweave)
        replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
      return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
      return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    if (protocol === "ar:/" && target) {
      return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) {
      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
      return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
      };
    }
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function getJsonImage(data) {
    if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
      throw new EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
  }
  async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
      const res = await fetch(uri).then((res2) => res2.json());
      const image = await parseAvatarUri({
        gatewayUrls,
        uri: getJsonImage(res)
      });
      return image;
    } catch {
      throw new EnsAvatarUriResolutionError({ uri });
    }
  }
  async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
      return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
      return resolvedURI;
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function parseNftUri(uri_) {
    let uri = uri_;
    if (uri.startsWith("did:nft:")) {
      uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    }
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
      throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
    if (!chainID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
    if (!contractAddress)
      throw new EnsAvatarInvalidNftUriError({
        reason: "Contract address not found"
      });
    if (!tokenID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
    if (!erc_namespace)
      throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
    return {
      chainID: Number.parseInt(chainID),
      namespace: erc_namespace.toLowerCase(),
      contractAddress,
      tokenID
    };
  }
  async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "tokenId", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "tokenURI",
        args: [BigInt(nft.tokenID)]
      });
    }
    if (nft.namespace === "erc1155") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "_id", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "uri",
        args: [BigInt(nft.tokenID)]
      });
    }
    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
  }
  var networkRegex, ipfsHashRegex, base64Regex, dataURIRegex;
  var init_utils7 = __esm({
    "node_modules/viem/_esm/utils/ens/avatar/utils.js"() {
      init_readContract();
      init_ens();
      networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
      ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
      base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
      dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    }
  });

  // node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
  async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record))
      return parseNftAvatarUri(client, { gatewayUrls, record });
    return parseAvatarUri({ uri: record, gatewayUrls });
  }
  async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    const nft = parseNftUri(record);
    const nftUri = await getNftTokenUri(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
      const encodedJson = isEncoded ? (
        // if it is encoded, decode it
        atob(resolvedNftUri.replace("data:application/json;base64,", ""))
      ) : (
        // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
        resolvedNftUri
      );
      const decoded = JSON.parse(encodedJson);
      return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155")
      uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return getMetadataAvatarUri({
      gatewayUrls,
      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
  }
  var init_parseAvatarRecord = __esm({
    "node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js"() {
      init_utils7();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsText.js
  async function getEnsText(client, parameters) {
    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      return null;
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverResolveAbi,
        functionName: "resolve",
        args: [
          toHex2(packetToBytes(name)),
          encodeFunctionData({
            abi: textResolverAbi,
            functionName: "text",
            args: [namehash(name), key]
          }),
          gatewayUrls ?? [localBatchGatewayUrl]
        ],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const res = await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const record = decodeFunctionResult({
        abi: textResolverAbi,
        functionName: "text",
        data: res[0]
      });
      return record === "" ? null : record;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "resolve"))
        return null;
      throw err;
    }
  }
  var init_getEnsText = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsText.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_toHex();
      init_errors4();
      init_localBatchGatewayRequest();
      init_namehash();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsAvatar.js
  async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
    const record = await getAction(client, getEnsText, "getEnsText")({
      blockNumber,
      blockTag,
      key: "avatar",
      name,
      universalResolverAddress,
      gatewayUrls,
      strict
    });
    if (!record)
      return null;
    try {
      return await parseAvatarRecord(client, {
        record,
        gatewayUrls: assetGatewayUrls
      });
    } catch {
      return null;
    }
  }
  var init_getEnsAvatar = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsAvatar.js"() {
      init_parseAvatarRecord();
      init_getAction();
      init_getEnsText();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsName.js
  async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverReverseAbi,
        functionName: "reverse",
        args: [toHex2(packetToBytes(reverseNode))],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
        ...readContractParameters,
        args: [...readContractParameters.args, gatewayUrls]
      }) : await readContractAction(readContractParameters);
      if (address.toLowerCase() !== resolvedAddress.toLowerCase())
        return null;
      return name;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "reverse"))
        return null;
      throw err;
    }
  }
  var init_getEnsName = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsName.js"() {
      init_abis();
      init_getChainContractAddress();
      init_toHex();
      init_errors4();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsResolver.js
  async function getEnsResolver(client, parameters) {
    const { blockNumber, blockTag, name } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(", ")}) for chain "${chain.name}" (id: ${chain.id}).`);
    const [resolverAddress] = await getAction(client, readContract, "readContract")({
      address: universalResolverAddress,
      abi: [
        {
          inputs: [{ type: "bytes" }],
          name: "findResolver",
          outputs: [{ type: "address" }, { type: "bytes32" }],
          stateMutability: "view",
          type: "function"
        }
      ],
      functionName: "findResolver",
      args: [toHex2(packetToBytes(name))],
      blockNumber,
      blockTag
    });
    return resolverAddress;
  }
  var init_getEnsResolver = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsResolver.js"() {
      init_getChainContractAddress();
      init_toHex();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/public/createAccessList.js
  async function createAccessList(client, args) {
    const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      assertRequest(args);
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request2 = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        blobs,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        to,
        value
      });
      const response = await client.request({
        method: "eth_createAccessList",
        params: [request2, block]
      });
      return {
        accessList: response.accessList,
        gasUsed: BigInt(response.gasUsed)
      };
    } catch (err) {
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  var init_createAccessList = __esm({
    "node_modules/viem/_esm/actions/public/createAccessList.js"() {
      init_parseAccount();
      init_toHex();
      init_getCallError();
      init_extract();
      init_transactionRequest();
      init_assertRequest();
    }
  });

  // node_modules/viem/_esm/actions/public/createBlockFilter.js
  async function createBlockFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newBlockFilter"
    });
    const id = await client.request({
      method: "eth_newBlockFilter"
    });
    return { id, request: getRequest(id), type: "block" };
  }
  var init_createBlockFilter = __esm({
    "node_modules/viem/_esm/actions/public/createBlockFilter.js"() {
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/createEventFilter.js
  async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
    const events = events_ ?? (event ? [event] : void 0);
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    let topics = [];
    if (events) {
      const encoded = events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }));
      topics = [encoded];
      if (event)
        topics = topics[0];
    }
    const id = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          ...topics.length ? { topics } : {}
        }
      ]
    });
    return {
      abi: events,
      args,
      eventName: event ? event.name : void 0,
      fromBlock,
      id,
      request: getRequest(id),
      strict: Boolean(strict),
      toBlock,
      type: "event"
    };
  }
  var init_createEventFilter = __esm({
    "node_modules/viem/_esm/actions/public/createEventFilter.js"() {
      init_encodeEventTopics();
      init_toHex();
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
  async function createPendingTransactionFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newPendingTransactionFilter"
    });
    const id = await client.request({
      method: "eth_newPendingTransactionFilter"
    });
    return { id, request: getRequest(id), type: "transaction" };
  }
  var init_createPendingTransactionFilter = __esm({
    "node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js"() {
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/getBlobBaseFee.js
  async function getBlobBaseFee(client) {
    const baseFee = await client.request({
      method: "eth_blobBaseFee"
    });
    return BigInt(baseFee);
  }
  var init_getBlobBaseFee = __esm({
    "node_modules/viem/_esm/actions/public/getBlobBaseFee.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let count;
    if (blockHash) {
      count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [blockHash]
      }, { dedupe: true });
    } else {
      count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [blockNumberHex || blockTag]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    return hexToNumber2(count);
  }
  var init_getBlockTransactionCount = __esm({
    "node_modules/viem/_esm/actions/public/getBlockTransactionCount.js"() {
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/getCode.js
  async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const hex = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
    if (hex === "0x")
      return void 0;
    return hex;
  }
  var init_getCode = __esm({
    "node_modules/viem/_esm/actions/public/getCode.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/errors/eip712.js
  var Eip712DomainNotFoundError;
  var init_eip712 = __esm({
    "node_modules/viem/_esm/errors/eip712.js"() {
      init_base2();
      Eip712DomainNotFoundError = class extends BaseError2 {
        constructor({ address }) {
          super(`No EIP-712 domain found on contract "${address}".`, {
            metaMessages: [
              "Ensure that:",
              `- The contract is deployed at the address "${address}".`,
              "- `eip712Domain()` function exists on the contract.",
              "- `eip712Domain()` function matches signature to ERC-5267 specification."
            ],
            name: "Eip712DomainNotFoundError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/actions/public/getEip712Domain.js
  async function getEip712Domain(client, parameters) {
    const { address, factory, factoryData } = parameters;
    try {
      const [fields, name, version4, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
        abi,
        address,
        functionName: "eip712Domain",
        factory,
        factoryData
      });
      return {
        domain: {
          name,
          version: version4,
          chainId: Number(chainId),
          verifyingContract,
          salt
        },
        extensions,
        fields
      };
    } catch (e) {
      const error = e;
      if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
        throw new Eip712DomainNotFoundError({ address });
      }
      throw error;
    }
  }
  var abi;
  var init_getEip712Domain = __esm({
    "node_modules/viem/_esm/actions/public/getEip712Domain.js"() {
      init_eip712();
      init_getAction();
      init_readContract();
      abi = [
        {
          inputs: [],
          name: "eip712Domain",
          outputs: [
            { name: "fields", type: "bytes1" },
            { name: "name", type: "string" },
            { name: "version", type: "string" },
            { name: "chainId", type: "uint256" },
            { name: "verifyingContract", type: "address" },
            { name: "salt", type: "bytes32" },
            { name: "extensions", type: "uint256[]" }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
    }
  });

  // node_modules/viem/_esm/utils/formatters/feeHistory.js
  function formatFeeHistory(feeHistory) {
    return {
      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
      gasUsedRatio: feeHistory.gasUsedRatio,
      oldestBlock: BigInt(feeHistory.oldestBlock),
      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
    };
  }
  var init_feeHistory = __esm({
    "node_modules/viem/_esm/utils/formatters/feeHistory.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getFeeHistory.js
  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const feeHistory = await client.request({
      method: "eth_feeHistory",
      params: [
        numberToHex(blockCount),
        blockNumberHex || blockTag,
        rewardPercentiles
      ]
    }, { dedupe: Boolean(blockNumberHex) });
    return formatFeeHistory(feeHistory);
  }
  var init_getFeeHistory = __esm({
    "node_modules/viem/_esm/actions/public/getFeeHistory.js"() {
      init_toHex();
      init_feeHistory();
    }
  });

  // node_modules/viem/_esm/actions/public/getFilterLogs.js
  async function getFilterLogs(_client, { filter }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
      method: "eth_getFilterLogs",
      params: [filter.id]
    });
    const formattedLogs = logs.map((log) => formatLog(log));
    if (!filter.abi)
      return formattedLogs;
    return parseEventLogs({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  var init_getFilterLogs = __esm({
    "node_modules/viem/_esm/actions/public/getFilterLogs.js"() {
      init_parseEventLogs();
      init_log2();
    }
  });

  // node_modules/viem/_esm/utils/chain/defineChain.js
  function defineChain(chain) {
    return {
      formatters: void 0,
      fees: void 0,
      serializers: void 0,
      ...chain
    };
  }
  var init_defineChain = __esm({
    "node_modules/viem/_esm/utils/chain/defineChain.js"() {
    }
  });

  // node_modules/viem/_esm/utils/chain/extractChain.js
  function extractChain({ chains, id }) {
    return chains.find((chain) => chain.id === id);
  }
  var init_extractChain = __esm({
    "node_modules/viem/_esm/utils/chain/extractChain.js"() {
    }
  });

  // node_modules/viem/_esm/utils/rpc/socket.js
  async function getSocketRpcClient(parameters) {
    const { getSocket: getSocket2, keepAlive = true, key = "socket", reconnect = true, url } = parameters;
    const { interval: keepAliveInterval = 3e4 } = typeof keepAlive === "object" ? keepAlive : {};
    const { attempts = 5, delay = 2e3 } = typeof reconnect === "object" ? reconnect : {};
    const id = JSON.stringify({ keepAlive, key, url, reconnect });
    let socketClient = socketClientCache.get(id);
    if (socketClient)
      return socketClient;
    let reconnectCount = 0;
    const { schedule } = createBatchScheduler({
      id,
      fn: async () => {
        const requests = /* @__PURE__ */ new Map();
        const subscriptions = /* @__PURE__ */ new Map();
        let error;
        let socket;
        let keepAliveTimer;
        let reconnectInProgress = false;
        function attemptReconnect() {
          if (reconnect && reconnectCount < attempts) {
            if (reconnectInProgress)
              return;
            reconnectInProgress = true;
            reconnectCount++;
            socket?.close();
            setTimeout(async () => {
              await setup().catch(console.error);
              reconnectInProgress = false;
            }, delay);
          } else {
            requests.clear();
            subscriptions.clear();
          }
        }
        async function setup() {
          const result = await getSocket2({
            onClose() {
              for (const request2 of requests.values())
                request2.onError?.(new SocketClosedError({ url }));
              for (const subscription of subscriptions.values())
                subscription.onError?.(new SocketClosedError({ url }));
              attemptReconnect();
            },
            onError(error_) {
              error = error_;
              for (const request2 of requests.values())
                request2.onError?.(error);
              for (const subscription of subscriptions.values())
                subscription.onError?.(error);
              attemptReconnect();
            },
            onOpen() {
              error = void 0;
              reconnectCount = 0;
            },
            onResponse(data) {
              const isSubscription = data.method === "eth_subscription";
              const id2 = isSubscription ? data.params.subscription : data.id;
              const cache = isSubscription ? subscriptions : requests;
              const callback = cache.get(id2);
              if (callback)
                callback.onResponse(data);
              if (!isSubscription)
                cache.delete(id2);
            }
          });
          socket = result;
          if (keepAlive) {
            if (keepAliveTimer)
              clearInterval(keepAliveTimer);
            keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval);
          }
          if (reconnect && subscriptions.size > 0) {
            const subscriptionEntries = subscriptions.entries();
            for (const [key2, { onResponse, body, onError }] of subscriptionEntries) {
              if (!body)
                continue;
              subscriptions.delete(key2);
              socketClient?.request({ body, onResponse, onError });
            }
          }
          return result;
        }
        await setup();
        error = void 0;
        socketClient = {
          close() {
            keepAliveTimer && clearInterval(keepAliveTimer);
            socket.close();
            socketClientCache.delete(id);
          },
          get socket() {
            return socket;
          },
          request({ body, onError, onResponse }) {
            if (error && onError)
              onError(error);
            const id2 = body.id ?? idCache.take();
            const callback = (response) => {
              if (typeof response.id === "number" && id2 !== response.id)
                return;
              if (body.method === "eth_subscribe" && typeof response.result === "string")
                subscriptions.set(response.result, {
                  onResponse: callback,
                  onError,
                  body
                });
              if (body.method === "eth_unsubscribe")
                subscriptions.delete(body.params?.[0]);
              onResponse(response);
            };
            requests.set(id2, { onResponse: callback, onError });
            try {
              socket.request({
                body: {
                  jsonrpc: "2.0",
                  id: id2,
                  ...body
                }
              });
            } catch (error2) {
              onError?.(error2);
            }
          },
          requestAsync({ body, timeout = 1e4 }) {
            return withTimeout(() => new Promise((onResponse, onError) => this.request({
              body,
              onError,
              onResponse
            })), {
              errorInstance: new TimeoutError({ body, url }),
              timeout
            });
          },
          requests,
          subscriptions,
          url
        };
        socketClientCache.set(id, socketClient);
        return [socketClient];
      }
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
  }
  var socketClientCache;
  var init_socket = __esm({
    "node_modules/viem/_esm/utils/rpc/socket.js"() {
      init_request();
      init_createBatchScheduler();
      init_withTimeout();
      init_id();
      socketClientCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/isows/_esm/utils.js
  function getNativeWebSocket() {
    if (typeof WebSocket !== "undefined")
      return WebSocket;
    if (typeof global.WebSocket !== "undefined")
      return global.WebSocket;
    if (typeof window.WebSocket !== "undefined")
      return window.WebSocket;
    if (typeof self.WebSocket !== "undefined")
      return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment");
  }
  var init_utils8 = __esm({
    "node_modules/isows/_esm/utils.js"() {
    }
  });

  // node_modules/isows/_esm/native.js
  var native_exports = {};
  __export(native_exports, {
    WebSocket: () => WebSocket2
  });
  var WebSocket2;
  var init_native = __esm({
    "node_modules/isows/_esm/native.js"() {
      init_utils8();
      WebSocket2 = getNativeWebSocket();
    }
  });

  // node_modules/viem/_esm/utils/rpc/webSocket.js
  async function getWebSocketRpcClient(url, options = {}) {
    const { keepAlive, reconnect } = options;
    return getSocketRpcClient({
      async getSocket({ onClose, onError, onOpen, onResponse }) {
        const WebSocket3 = await Promise.resolve().then(() => (init_native(), native_exports)).then((module) => module.WebSocket);
        const socket = new WebSocket3(url);
        function onClose_() {
          socket.removeEventListener("close", onClose_);
          socket.removeEventListener("message", onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("open", onOpen);
          onClose();
        }
        function onMessage({ data }) {
          try {
            const _data = JSON.parse(data);
            onResponse(_data);
          } catch (error) {
            onError(error);
          }
        }
        socket.addEventListener("close", onClose_);
        socket.addEventListener("message", onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("open", onOpen);
        if (socket.readyState === WebSocket3.CONNECTING) {
          await new Promise((resolve, reject) => {
            if (!socket)
              return;
            socket.onopen = resolve;
            socket.onerror = reject;
          });
        }
        const { close: close_ } = socket;
        return Object.assign(socket, {
          close() {
            close_.bind(socket)();
            onClose_();
          },
          ping() {
            try {
              if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
                throw new WebSocketRequestError({
                  url: socket.url,
                  cause: new SocketClosedError({ url: socket.url })
                });
              const body = {
                jsonrpc: "2.0",
                method: "net_version",
                params: []
              };
              socket.send(JSON.stringify(body));
            } catch (error) {
              onError(error);
            }
          },
          request({ body }) {
            if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
              throw new WebSocketRequestError({
                body,
                url: socket.url,
                cause: new SocketClosedError({ url: socket.url })
              });
            return socket.send(JSON.stringify(body));
          }
        });
      },
      keepAlive,
      reconnect,
      url
    });
  }
  var init_webSocket = __esm({
    "node_modules/viem/_esm/utils/rpc/webSocket.js"() {
      init_request();
      init_socket();
    }
  });

  // node_modules/viem/_esm/utils/rpc/compat.js
  async function getSocket(url) {
    const client = await getWebSocketRpcClient(url);
    return Object.assign(client.socket, {
      requests: client.requests,
      subscriptions: client.subscriptions
    });
  }
  var init_compat = __esm({
    "node_modules/viem/_esm/utils/rpc/compat.js"() {
      init_webSocket();
    }
  });

  // node_modules/viem/_esm/errors/typedData.js
  var InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError;
  var init_typedData = __esm({
    "node_modules/viem/_esm/errors/typedData.js"() {
      init_stringify();
      init_base2();
      InvalidDomainError = class extends BaseError2 {
        constructor({ domain }) {
          super(`Invalid domain "${stringify(domain)}".`, {
            metaMessages: ["Must be a valid EIP-712 domain."]
          });
        }
      };
      InvalidPrimaryTypeError = class extends BaseError2 {
        constructor({ primaryType, types }) {
          super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
            docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
            metaMessages: ["Check that the primary type is a key in `types`."]
          });
        }
      };
      InvalidStructTypeError = class extends BaseError2 {
        constructor({ type }) {
          super(`Struct type "${type}" is invalid.`, {
            metaMessages: ["Struct type must not be a Solidity type."],
            name: "InvalidStructTypeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/signature/hashTypedData.js
  function hashTypedData(parameters) {
    const { domain = {}, message, primaryType } = parameters;
    const types = {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
      ...parameters.types
    };
    validateTypedData({
      domain,
      message,
      primaryType,
      types
    });
    const parts = ["0x1901"];
    if (domain)
      parts.push(hashDomain({
        domain,
        types
      }));
    if (primaryType !== "EIP712Domain")
      parts.push(hashStruct({
        data: message,
        primaryType,
        types
      }));
    return keccak256(concat(parts));
  }
  function hashDomain({ domain, types }) {
    return hashStruct({
      data: domain,
      primaryType: "EIP712Domain",
      types
    });
  }
  function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
      data,
      primaryType,
      types
    });
    return keccak256(encoded);
  }
  function encodeData({ data, primaryType, types }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
      const [type, value] = encodeField({
        types,
        name: field.name,
        type: field.type,
        value: data[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return encodeAbiParameters(encodedTypes, encodedValues);
  }
  function hashType({ primaryType, types }) {
    const encodedHashType = toHex2(encodeType({ primaryType, types }));
    return keccak256(encodedHashType);
  }
  function encodeType({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === void 0) {
      return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
      findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
  }
  function encodeField({ types, name, type, value }) {
    if (types[type] !== void 0) {
      return [
        { type: "bytes32" },
        keccak256(encodeData({ data: value, primaryType: type, types }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, keccak256(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, keccak256(toHex2(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField({
        name,
        type: parsedType,
        types,
        value: item
      }));
      return [
        { type: "bytes32" },
        keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
      ];
    }
    return [{ type }, value];
  }
  var init_hashTypedData = __esm({
    "node_modules/viem/_esm/utils/signature/hashTypedData.js"() {
      init_encodeAbiParameters();
      init_concat();
      init_toHex();
      init_keccak256();
      init_typedData2();
    }
  });

  // node_modules/viem/_esm/utils/typedData.js
  function serializeTypedData(parameters) {
    const { domain: domain_, message: message_, primaryType, types } = parameters;
    const normalizeData = (struct, data_) => {
      const data = { ...data_ };
      for (const param of struct) {
        const { name, type } = param;
        if (type === "address")
          data[name] = data[name].toLowerCase();
      }
      return data;
    };
    const domain = (() => {
      if (!types.EIP712Domain)
        return {};
      if (!domain_)
        return {};
      return normalizeData(types.EIP712Domain, domain_);
    })();
    const message = (() => {
      if (primaryType === "EIP712Domain")
        return void 0;
      return normalizeData(types[primaryType], message_);
    })();
    return stringify({ domain, message, primaryType, types });
  }
  function validateTypedData(parameters) {
    const { domain, message, primaryType, types } = parameters;
    const validateData = (struct, data) => {
      for (const param of struct) {
        const { name, type } = param;
        const value = data[name];
        const integerMatch = type.match(integerRegex2);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type, base2, size_] = integerMatch;
          numberToHex(value, {
            signed: base2 === "int",
            size: Number.parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !isAddress(value))
          throw new InvalidAddressError({ address: value });
        const bytesMatch = type.match(bytesRegex2);
        if (bytesMatch) {
          const [_type, size_] = bytesMatch;
          if (size_ && size(value) !== Number.parseInt(size_))
            throw new BytesSizeMismatchError({
              expectedSize: Number.parseInt(size_),
              givenSize: size(value)
            });
        }
        const struct2 = types[type];
        if (struct2) {
          validateReference(type);
          validateData(struct2, value);
        }
      }
    };
    if (types.EIP712Domain && domain) {
      if (typeof domain !== "object")
        throw new InvalidDomainError({ domain });
      validateData(types.EIP712Domain, domain);
    }
    if (primaryType !== "EIP712Domain") {
      if (types[primaryType])
        validateData(types[primaryType], message);
      else
        throw new InvalidPrimaryTypeError({ primaryType, types });
    }
  }
  function getTypesForEIP712Domain({ domain }) {
    return [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      (typeof domain?.chainId === "number" || typeof domain?.chainId === "bigint") && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean);
  }
  function domainSeparator({ domain }) {
    return hashDomain({
      domain,
      types: {
        EIP712Domain: getTypesForEIP712Domain({ domain })
      }
    });
  }
  function validateReference(type) {
    if (type === "address" || type === "bool" || type === "string" || type.startsWith("bytes") || type.startsWith("uint") || type.startsWith("int"))
      throw new InvalidStructTypeError({ type });
  }
  var init_typedData2 = __esm({
    "node_modules/viem/_esm/utils/typedData.js"() {
      init_abi();
      init_address();
      init_typedData();
      init_isAddress();
      init_size();
      init_toHex();
      init_regex2();
      init_hashTypedData();
      init_stringify();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodePacked.js
  function encodePacked(types, values) {
    if (types.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
      });
    const data = [];
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const value = values[i];
      data.push(encode(type, value));
    }
    return concatHex(data);
  }
  function encode(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      if (!isAddress(address))
        throw new InvalidAddressError({ address });
      return pad(address.toLowerCase(), {
        size: isArray ? 32 : null
      });
    }
    if (type === "string")
      return stringToHex(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return pad(boolToHex(value), { size: isArray ? 32 : 1 });
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size5 = Number.parseInt(bits) / 8;
      return numberToHex(value, {
        size: isArray ? 32 : size5,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size5] = bytesMatch;
      if (Number.parseInt(size5) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError({
          expectedSize: Number.parseInt(size5),
          givenSize: (value.length - 2) / 2
        });
      return pad(value, { dir: "right", size: isArray ? 32 : null });
    }
    const arrayMatch = type.match(arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i = 0; i < value.length; i++) {
        data.push(encode(childType, value[i], true));
      }
      if (data.length === 0)
        return "0x";
      return concatHex(data);
    }
    throw new UnsupportedPackedAbiType(type);
  }
  var init_encodePacked = __esm({
    "node_modules/viem/_esm/utils/abi/encodePacked.js"() {
      init_abi();
      init_address();
      init_isAddress();
      init_concat();
      init_pad();
      init_toHex();
      init_regex2();
    }
  });

  // node_modules/viem/_esm/utils/transaction/assertTransaction.js
  function assertTransactionEIP7702(transaction) {
    const { authorizationList } = transaction;
    if (authorizationList) {
      for (const authorization of authorizationList) {
        const { chainId } = authorization;
        const address = authorization.address;
        if (!isAddress(address))
          throw new InvalidAddressError({ address });
        if (chainId < 0)
          throw new InvalidChainIdError({ chainId });
      }
    }
    assertTransactionEIP1559(transaction);
  }
  function assertTransactionEIP4844(transaction) {
    const { blobVersionedHashes } = transaction;
    if (blobVersionedHashes) {
      if (blobVersionedHashes.length === 0)
        throw new EmptyBlobError();
      for (const hash2 of blobVersionedHashes) {
        const size_ = size(hash2);
        const version4 = hexToNumber2(slice(hash2, 0, 1));
        if (size_ !== 32)
          throw new InvalidVersionedHashSizeError({ hash: hash2, size: size_ });
        if (version4 !== versionedHashVersionKzg)
          throw new InvalidVersionedHashVersionError({
            hash: hash2,
            version: version4
          });
      }
    }
    assertTransactionEIP1559(transaction);
  }
  function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (maxFeePerGas && maxFeePerGas > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
    if (gasPrice && gasPrice > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (typeof chainId !== "undefined" && chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
    if (gasPrice && gasPrice > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  var init_assertTransaction = __esm({
    "node_modules/viem/_esm/utils/transaction/assertTransaction.js"() {
      init_kzg();
      init_number();
      init_address();
      init_base2();
      init_blob2();
      init_chain();
      init_node();
      init_isAddress();
      init_size();
      init_slice();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/transaction/serializeAccessList.js
  function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
      return [];
    const serializedAccessList = [];
    for (let i = 0; i < accessList.length; i++) {
      const { address, storageKeys } = accessList[i];
      for (let j = 0; j < storageKeys.length; j++) {
        if (storageKeys[j].length - 2 !== 64) {
          throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
        }
      }
      if (!isAddress(address, { strict: false })) {
        throw new InvalidAddressError({ address });
      }
      serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
  }
  var init_serializeAccessList = __esm({
    "node_modules/viem/_esm/utils/transaction/serializeAccessList.js"() {
      init_address();
      init_transaction();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/utils/transaction/serializeTransaction.js
  function serializeTransaction(transaction, signature) {
    const type = getTransactionType(transaction);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction, signature);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction, signature);
    if (type === "eip4844")
      return serializeTransactionEIP4844(transaction, signature);
    if (type === "eip7702")
      return serializeTransactionEIP7702(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
  }
  function serializeTransactionEIP7702(transaction, signature) {
    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP7702(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
    return concatHex([
      "0x04",
      toRlp([
        numberToHex(chainId),
        nonce ? numberToHex(nonce) : "0x",
        maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
        gas ? numberToHex(gas) : "0x",
        to ?? "0x",
        value ? numberToHex(value) : "0x",
        data ?? "0x",
        serializedAccessList,
        serializedAuthorizationList,
        ...toYParitySignatureArray(transaction, signature)
      ])
    ]);
  }
  function serializeTransactionEIP4844(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP4844(transaction);
    let blobVersionedHashes = transaction.blobVersionedHashes;
    let sidecars = transaction.sidecars;
    if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
      const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex3(x));
      const kzg = transaction.kzg;
      const commitments2 = blobsToCommitments({
        blobs: blobs2,
        kzg
      });
      if (typeof blobVersionedHashes === "undefined")
        blobVersionedHashes = commitmentsToVersionedHashes({
          commitments: commitments2
        });
      if (typeof sidecars === "undefined") {
        const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
        sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
      }
    }
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      maxFeePerBlobGas ? numberToHex(maxFeePerBlobGas) : "0x",
      blobVersionedHashes ?? [],
      ...toYParitySignatureArray(transaction, signature)
    ];
    const blobs = [];
    const commitments = [];
    const proofs = [];
    if (sidecars)
      for (let i = 0; i < sidecars.length; i++) {
        const { blob, commitment, proof } = sidecars[i];
        blobs.push(blob);
        commitments.push(commitment);
        proofs.push(proof);
      }
    return concatHex([
      "0x03",
      sidecars ? (
        // If sidecars are enabled, envelope turns into a "wrapper":
        toRlp([serializedTransaction, blobs, commitments, proofs])
      ) : (
        // If sidecars are disabled, standard envelope is used:
        toRlp(serializedTransaction)
      )
    ]);
  }
  function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP1559(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return concatHex([
      "0x02",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    assertTransactionEIP2930(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      gasPrice ? numberToHex(gasPrice) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return concatHex([
      "0x01",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    assertTransactionLegacy(transaction);
    let serializedTransaction = [
      nonce ? numberToHex(nonce) : "0x",
      gasPrice ? numberToHex(gasPrice) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x"
    ];
    if (signature) {
      const v = (() => {
        if (signature.v >= 35n) {
          const inferredChainId = (signature.v - 35n) / 2n;
          if (inferredChainId > 0)
            return signature.v;
          return 27n + (signature.v === 35n ? 0n : 1n);
        }
        if (chainId > 0)
          return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        const v2 = 27n + (signature.v === 27n ? 0n : 1n);
        if (signature.v !== v2)
          throw new InvalidLegacyVError({ v: signature.v });
        return v2;
      })();
      const r = trim(signature.r);
      const s = trim(signature.s);
      serializedTransaction = [
        ...serializedTransaction,
        numberToHex(v),
        r === "0x00" ? "0x" : r,
        s === "0x00" ? "0x" : s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        numberToHex(chainId),
        "0x",
        "0x"
      ];
    }
    return toRlp(serializedTransaction);
  }
  function toYParitySignatureArray(transaction, signature_) {
    const signature = signature_ ?? transaction;
    const { v, yParity } = signature;
    if (typeof signature.r === "undefined")
      return [];
    if (typeof signature.s === "undefined")
      return [];
    if (typeof v === "undefined" && typeof yParity === "undefined")
      return [];
    const r = trim(signature.r);
    const s = trim(signature.s);
    const yParity_ = (() => {
      if (typeof yParity === "number")
        return yParity ? numberToHex(1) : "0x";
      if (v === 0n)
        return "0x";
      if (v === 1n)
        return numberToHex(1);
      return v === 27n ? "0x" : numberToHex(1);
    })();
    return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
  }
  var init_serializeTransaction = __esm({
    "node_modules/viem/_esm/utils/transaction/serializeTransaction.js"() {
      init_transaction();
      init_serializeAuthorizationList();
      init_blobsToCommitments();
      init_blobsToProofs();
      init_commitmentsToVersionedHashes();
      init_toBlobSidecars();
      init_concat();
      init_trim();
      init_toHex();
      init_toRlp();
      init_assertTransaction();
      init_getTransactionType();
      init_serializeAccessList();
    }
  });

  // node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js
  function serializeAuthorizationList(authorizationList) {
    if (!authorizationList || authorizationList.length === 0)
      return [];
    const serializedAuthorizationList = [];
    for (const authorization of authorizationList) {
      const { chainId, nonce, ...signature } = authorization;
      const contractAddress = authorization.address;
      serializedAuthorizationList.push([
        chainId ? toHex2(chainId) : "0x",
        contractAddress,
        nonce ? toHex2(nonce) : "0x",
        ...toYParitySignatureArray({}, signature)
      ]);
    }
    return serializedAuthorizationList;
  }
  var init_serializeAuthorizationList = __esm({
    "node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js"() {
      init_toHex();
      init_serializeTransaction();
    }
  });

  // node_modules/viem/_esm/utils/data/isBytes.js
  function isBytes3(value) {
    if (!value)
      return false;
    if (typeof value !== "object")
      return false;
    if (!("BYTES_PER_ELEMENT" in value))
      return false;
    return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
  }
  var init_isBytes = __esm({
    "node_modules/viem/_esm/utils/data/isBytes.js"() {
    }
  });

  // node_modules/viem/_esm/utils/address/getContractAddress.js
  function getContractAddress2(opts) {
    if (opts.opcode === "CREATE2")
      return getCreate2Address(opts);
    return getCreateAddress(opts);
  }
  function getCreateAddress(opts) {
    const from5 = toBytes2(getAddress(opts.from));
    let nonce = toBytes2(opts.nonce);
    if (nonce[0] === 0)
      nonce = new Uint8Array([]);
    return getAddress(`0x${keccak256(toRlp([from5, nonce], "bytes")).slice(26)}`);
  }
  function getCreate2Address(opts) {
    const from5 = toBytes2(getAddress(opts.from));
    const salt = pad(isBytes3(opts.salt) ? opts.salt : toBytes2(opts.salt), {
      size: 32
    });
    const bytecodeHash = (() => {
      if ("bytecodeHash" in opts) {
        if (isBytes3(opts.bytecodeHash))
          return opts.bytecodeHash;
        return toBytes2(opts.bytecodeHash);
      }
      return keccak256(opts.bytecode, "bytes");
    })();
    return getAddress(slice(keccak256(concat([toBytes2("0xff"), from5, salt, bytecodeHash])), 12));
  }
  var init_getContractAddress = __esm({
    "node_modules/viem/_esm/utils/address/getContractAddress.js"() {
      init_concat();
      init_isBytes();
      init_pad();
      init_slice();
      init_toBytes();
      init_toRlp();
      init_keccak256();
      init_getAddress();
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromRlp.js
  function fromRlp(value, to = "hex") {
    const bytes = (() => {
      if (typeof value === "string") {
        if (value.length > 3 && value.length % 2 !== 0)
          throw new InvalidHexValueError(value);
        return hexToBytes3(value);
      }
      return value;
    })();
    const cursor = createCursor(bytes, {
      recursiveReadLimit: Number.POSITIVE_INFINITY
    });
    const result = fromRlpCursor(cursor, to);
    return result;
  }
  function fromRlpCursor(cursor, to = "hex") {
    if (cursor.bytes.length === 0)
      return to === "hex" ? bytesToHex3(cursor.bytes) : cursor.bytes;
    const prefix = cursor.readByte();
    if (prefix < 128)
      cursor.decrementPosition(1);
    if (prefix < 192) {
      const length2 = readLength(cursor, prefix, 128);
      const bytes = cursor.readBytes(length2);
      return to === "hex" ? bytesToHex3(bytes) : bytes;
    }
    const length = readLength(cursor, prefix, 192);
    return readList(cursor, length, to);
  }
  function readLength(cursor, prefix, offset) {
    if (offset === 128 && prefix < 128)
      return 1;
    if (prefix <= offset + 55)
      return prefix - offset;
    if (prefix === offset + 55 + 1)
      return cursor.readUint8();
    if (prefix === offset + 55 + 2)
      return cursor.readUint16();
    if (prefix === offset + 55 + 3)
      return cursor.readUint24();
    if (prefix === offset + 55 + 4)
      return cursor.readUint32();
    throw new BaseError2("Invalid RLP prefix");
  }
  function readList(cursor, length, to) {
    const position = cursor.position;
    const value = [];
    while (cursor.position - position < length)
      value.push(fromRlpCursor(cursor, to));
    return value;
  }
  var init_fromRlp = __esm({
    "node_modules/viem/_esm/utils/encoding/fromRlp.js"() {
      init_base2();
      init_encoding();
      init_cursor2();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/hash/toEventSignature.js
  var init_toEventSignature = __esm({
    "node_modules/viem/_esm/utils/hash/toEventSignature.js"() {
      init_toSignature();
    }
  });

  // node_modules/viem/_esm/utils/hash/toFunctionSignature.js
  var init_toFunctionSignature = __esm({
    "node_modules/viem/_esm/utils/hash/toFunctionSignature.js"() {
      init_toSignature();
    }
  });

  // node_modules/viem/_esm/utils/hash/toEventHash.js
  var init_toEventHash = __esm({
    "node_modules/viem/_esm/utils/hash/toEventHash.js"() {
      init_toSignatureHash();
    }
  });

  // node_modules/viem/_esm/utils/hash/toFunctionHash.js
  var init_toFunctionHash = __esm({
    "node_modules/viem/_esm/utils/hash/toFunctionHash.js"() {
      init_toSignatureHash();
    }
  });

  // node_modules/viem/_esm/utils/hash/isHash.js
  function isHash2(hash2) {
    return isHex(hash2) && size(hash2) === 32;
  }
  var init_isHash = __esm({
    "node_modules/viem/_esm/utils/hash/isHash.js"() {
      init_isHex();
      init_size();
    }
  });

  // node_modules/@noble/hashes/esm/legacy.js
  function ripemd_f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    if (group === 1)
      return x & y | ~x & z;
    if (group === 2)
      return (x | ~y) ^ z;
    if (group === 3)
      return x & z | y & ~z;
    return x ^ (y | ~z);
  }
  var Rho160, Id160, Pi160, idxLR, idxL, idxR, shifts160, shiftsL160, shiftsR160, Kl160, Kr160, BUF_160, RIPEMD160, ripemd160;
  var init_legacy = __esm({
    "node_modules/@noble/hashes/esm/legacy.js"() {
      init_md();
      init_utils2();
      Rho160 = /* @__PURE__ */ Uint8Array.from([
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8
      ]);
      Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
      Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
      idxLR = /* @__PURE__ */ (() => {
        const L = [Id160];
        const R = [Pi160];
        const res = [L, R];
        for (let i = 0; i < 4; i++)
          for (let j of res)
            j.push(j[i].map((k) => Rho160[k]));
        return res;
      })();
      idxL = /* @__PURE__ */ (() => idxLR[0])();
      idxR = /* @__PURE__ */ (() => idxLR[1])();
      shifts160 = /* @__PURE__ */ [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
      ].map((i) => Uint8Array.from(i));
      shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
      shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
      Kl160 = /* @__PURE__ */ Uint32Array.from([
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
      ]);
      Kr160 = /* @__PURE__ */ Uint32Array.from([
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
      ]);
      BUF_160 = /* @__PURE__ */ new Uint32Array(16);
      RIPEMD160 = class extends HashMD {
        constructor() {
          super(64, 20, 8, true);
          this.h0 = 1732584193 | 0;
          this.h1 = 4023233417 | 0;
          this.h2 = 2562383102 | 0;
          this.h3 = 271733878 | 0;
          this.h4 = 3285377520 | 0;
        }
        get() {
          const { h0, h1, h2, h3, h4 } = this;
          return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            BUF_160[i] = view.getUint32(offset, true);
          let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
          for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group];
            const rl = idxL[group], rr = idxR[group];
            const sl = shiftsL160[group], sr = shiftsR160[group];
            for (let i = 0; i < 16; i++) {
              const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
              al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
            }
            for (let i = 0; i < 16; i++) {
              const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
              ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
            }
          }
          this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
        }
        roundClean() {
          clean(BUF_160);
        }
        destroy() {
          this.destroyed = true;
          clean(this.buffer);
          this.set(0, 0, 0, 0, 0);
        }
      };
      ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());
    }
  });

  // node_modules/@noble/hashes/esm/ripemd160.js
  var ripemd1602;
  var init_ripemd160 = __esm({
    "node_modules/@noble/hashes/esm/ripemd160.js"() {
      init_legacy();
      ripemd1602 = ripemd160;
    }
  });

  // node_modules/viem/_esm/utils/hash/ripemd160.js
  function ripemd1603(value, to_) {
    const to = to_ || "hex";
    const bytes = ripemd1602(isHex(value, { strict: false }) ? toBytes2(value) : value);
    if (to === "bytes")
      return bytes;
    return toHex2(bytes);
  }
  var init_ripemd1602 = __esm({
    "node_modules/viem/_esm/utils/hash/ripemd160.js"() {
      init_ripemd160();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/constants/strings.js
  var presignMessagePrefix;
  var init_strings = __esm({
    "node_modules/viem/_esm/constants/strings.js"() {
      presignMessagePrefix = "Ethereum Signed Message:\n";
    }
  });

  // node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
  function toPrefixedMessage(message_) {
    const message = (() => {
      if (typeof message_ === "string")
        return stringToHex(message_);
      if (typeof message_.raw === "string")
        return message_.raw;
      return bytesToHex3(message_.raw);
    })();
    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
    return concat([prefix, message]);
  }
  var init_toPrefixedMessage = __esm({
    "node_modules/viem/_esm/utils/signature/toPrefixedMessage.js"() {
      init_strings();
      init_concat();
      init_size();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/hashMessage.js
  function hashMessage(message, to_) {
    return keccak256(toPrefixedMessage(message), to_);
  }
  var init_hashMessage = __esm({
    "node_modules/viem/_esm/utils/signature/hashMessage.js"() {
      init_keccak256();
      init_toPrefixedMessage();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverMessageAddress.js
  async function recoverMessageAddress({ message, signature }) {
    return recoverAddress({ hash: hashMessage(message), signature });
  }
  var init_recoverMessageAddress = __esm({
    "node_modules/viem/_esm/utils/signature/recoverMessageAddress.js"() {
      init_hashMessage();
      init_recoverAddress();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js
  async function recoverTypedDataAddress(parameters) {
    const { domain, message, primaryType, signature, types } = parameters;
    return recoverAddress({
      hash: hashTypedData({
        domain,
        message,
        primaryType,
        types
      }),
      signature
    });
  }
  var init_recoverTypedDataAddress = __esm({
    "node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js"() {
      init_hashTypedData();
      init_recoverAddress();
    }
  });

  // node_modules/viem/_esm/utils/signature/verifyHash.js
  async function verifyHash({ address, hash: hash2, signature }) {
    return isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));
  }
  var init_verifyHash = __esm({
    "node_modules/viem/_esm/utils/signature/verifyHash.js"() {
      init_getAddress();
      init_isAddressEqual();
      init_recoverAddress();
    }
  });

  // node_modules/viem/_esm/utils/signature/verifyMessage.js
  async function verifyMessage({ address, message, signature }) {
    return isAddressEqual(getAddress(address), await recoverMessageAddress({ message, signature }));
  }
  var init_verifyMessage = __esm({
    "node_modules/viem/_esm/utils/signature/verifyMessage.js"() {
      init_getAddress();
      init_isAddressEqual();
      init_recoverMessageAddress();
    }
  });

  // node_modules/viem/_esm/utils/signature/verifyTypedData.js
  async function verifyTypedData(parameters) {
    const { address, domain, message, primaryType, signature, types } = parameters;
    return isAddressEqual(getAddress(address), await recoverTypedDataAddress({
      domain,
      message,
      primaryType,
      signature,
      types
    }));
  }
  var init_verifyTypedData = __esm({
    "node_modules/viem/_esm/utils/signature/verifyTypedData.js"() {
      init_getAddress();
      init_isAddressEqual();
      init_recoverTypedDataAddress();
    }
  });

  // node_modules/viem/_esm/constants/bytes.js
  var erc6492MagicBytes, zeroHash;
  var init_bytes3 = __esm({
    "node_modules/viem/_esm/constants/bytes.js"() {
      erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";
      zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
    }
  });

  // node_modules/viem/_esm/utils/signature/isErc6492Signature.js
  function isErc6492Signature(signature) {
    return sliceHex(signature, -32) === erc6492MagicBytes;
  }
  var init_isErc6492Signature = __esm({
    "node_modules/viem/_esm/utils/signature/isErc6492Signature.js"() {
      init_bytes3();
      init_slice();
    }
  });

  // node_modules/viem/_esm/utils/signature/parseErc6492Signature.js
  function parseErc6492Signature(signature) {
    if (!isErc6492Signature(signature))
      return { signature };
    const [address, data, signature_] = decodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], signature);
    return { address, data, signature: signature_ };
  }
  var init_parseErc6492Signature = __esm({
    "node_modules/viem/_esm/utils/signature/parseErc6492Signature.js"() {
      init_decodeAbiParameters();
      init_isErc6492Signature();
    }
  });

  // node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
  function serializeErc6492Signature(parameters) {
    const { address, data, signature, to = "hex" } = parameters;
    const signature_ = concatHex([
      encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
      erc6492MagicBytes
    ]);
    if (to === "hex")
      return signature_;
    return hexToBytes3(signature_);
  }
  var init_serializeErc6492Signature = __esm({
    "node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js"() {
      init_bytes3();
      init_encodeAbiParameters();
      init_concat();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/utils/transaction/getSerializedTransactionType.js
  function getSerializedTransactionType(serializedTransaction) {
    const serializedType = sliceHex(serializedTransaction, 0, 1);
    if (serializedType === "0x04")
      return "eip7702";
    if (serializedType === "0x03")
      return "eip4844";
    if (serializedType === "0x02")
      return "eip1559";
    if (serializedType === "0x01")
      return "eip2930";
    if (serializedType !== "0x" && hexToNumber2(serializedType) >= 192)
      return "legacy";
    throw new InvalidSerializedTransactionTypeError({ serializedType });
  }
  var init_getSerializedTransactionType = __esm({
    "node_modules/viem/_esm/utils/transaction/getSerializedTransactionType.js"() {
      init_transaction();
      init_slice();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/transaction/parseTransaction.js
  function parseTransaction(serializedTransaction) {
    const type = getSerializedTransactionType(serializedTransaction);
    if (type === "eip1559")
      return parseTransactionEIP1559(serializedTransaction);
    if (type === "eip2930")
      return parseTransactionEIP2930(serializedTransaction);
    if (type === "eip4844")
      return parseTransactionEIP4844(serializedTransaction);
    if (type === "eip7702")
      return parseTransactionEIP7702(serializedTransaction);
    return parseTransactionLegacy(serializedTransaction);
  }
  function parseTransactionEIP7702(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s] = transactionArray;
    if (transactionArray.length !== 10 && transactionArray.length !== 13)
      throw new InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gas,
          to,
          value,
          data,
          accessList,
          authorizationList,
          ...transactionArray.length > 9 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip7702"
      });
    const transaction = {
      chainId: hexToNumber2(chainId),
      type: "eip7702"
    };
    if (isHex(to) && to !== "0x")
      transaction.to = to;
    if (isHex(gas) && gas !== "0x")
      transaction.gas = hexToBigInt(gas);
    if (isHex(data) && data !== "0x")
      transaction.data = data;
    if (isHex(nonce))
      transaction.nonce = nonce === "0x" ? 0 : hexToNumber2(nonce);
    if (isHex(value) && value !== "0x")
      transaction.value = hexToBigInt(value);
    if (isHex(maxFeePerGas) && maxFeePerGas !== "0x")
      transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);
    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
      transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    if (authorizationList.length !== 0 && authorizationList !== "0x")
      transaction.authorizationList = parseAuthorizationList(authorizationList);
    assertTransactionEIP7702(transaction);
    const signature = transactionArray.length === 13 ? parseEIP155Signature(transactionArray) : void 0;
    return { ...signature, ...transaction };
  }
  function parseTransactionEIP4844(serializedTransaction) {
    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);
    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
    const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
    const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s] = transactionArray;
    const [blobs, commitments, proofs] = wrapperArray;
    if (!(transactionArray.length === 11 || transactionArray.length === 14))
      throw new InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 9 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip4844"
      });
    const transaction = {
      blobVersionedHashes,
      chainId: hexToNumber2(chainId),
      type: "eip4844"
    };
    if (isHex(to) && to !== "0x")
      transaction.to = to;
    if (isHex(gas) && gas !== "0x")
      transaction.gas = hexToBigInt(gas);
    if (isHex(data) && data !== "0x")
      transaction.data = data;
    if (isHex(nonce))
      transaction.nonce = nonce === "0x" ? 0 : hexToNumber2(nonce);
    if (isHex(value) && value !== "0x")
      transaction.value = hexToBigInt(value);
    if (isHex(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
      transaction.maxFeePerBlobGas = hexToBigInt(maxFeePerBlobGas);
    if (isHex(maxFeePerGas) && maxFeePerGas !== "0x")
      transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);
    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
      transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    if (blobs && commitments && proofs)
      transaction.sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs
      });
    assertTransactionEIP4844(transaction);
    const signature = transactionArray.length === 14 ? parseEIP155Signature(transactionArray) : void 0;
    return { ...signature, ...transaction };
  }
  function parseTransactionEIP1559(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 9 || transactionArray.length === 12))
      throw new InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 9 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip1559"
      });
    const transaction = {
      chainId: hexToNumber2(chainId),
      type: "eip1559"
    };
    if (isHex(to) && to !== "0x")
      transaction.to = to;
    if (isHex(gas) && gas !== "0x")
      transaction.gas = hexToBigInt(gas);
    if (isHex(data) && data !== "0x")
      transaction.data = data;
    if (isHex(nonce))
      transaction.nonce = nonce === "0x" ? 0 : hexToNumber2(nonce);
    if (isHex(value) && value !== "0x")
      transaction.value = hexToBigInt(value);
    if (isHex(maxFeePerGas) && maxFeePerGas !== "0x")
      transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);
    if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
      transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    assertTransactionEIP1559(transaction);
    const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
    return { ...signature, ...transaction };
  }
  function parseTransactionEIP2930(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 8 || transactionArray.length === 11))
      throw new InvalidSerializedTransactionError({
        attributes: {
          chainId,
          nonce,
          gasPrice,
          gas,
          to,
          value,
          data,
          accessList,
          ...transactionArray.length > 8 ? {
            v,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "eip2930"
      });
    const transaction = {
      chainId: hexToNumber2(chainId),
      type: "eip2930"
    };
    if (isHex(to) && to !== "0x")
      transaction.to = to;
    if (isHex(gas) && gas !== "0x")
      transaction.gas = hexToBigInt(gas);
    if (isHex(data) && data !== "0x")
      transaction.data = data;
    if (isHex(nonce))
      transaction.nonce = nonce === "0x" ? 0 : hexToNumber2(nonce);
    if (isHex(value) && value !== "0x")
      transaction.value = hexToBigInt(value);
    if (isHex(gasPrice) && gasPrice !== "0x")
      transaction.gasPrice = hexToBigInt(gasPrice);
    if (accessList.length !== 0 && accessList !== "0x")
      transaction.accessList = parseAccessList(accessList);
    assertTransactionEIP2930(transaction);
    const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
    return { ...signature, ...transaction };
  }
  function parseTransactionLegacy(serializedTransaction) {
    const transactionArray = fromRlp(serializedTransaction, "hex");
    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
    if (!(transactionArray.length === 6 || transactionArray.length === 9))
      throw new InvalidSerializedTransactionError({
        attributes: {
          nonce,
          gasPrice,
          gas,
          to,
          value,
          data,
          ...transactionArray.length > 6 ? {
            v: chainIdOrV_,
            r,
            s
          } : {}
        },
        serializedTransaction,
        type: "legacy"
      });
    const transaction = {
      type: "legacy"
    };
    if (isHex(to) && to !== "0x")
      transaction.to = to;
    if (isHex(gas) && gas !== "0x")
      transaction.gas = hexToBigInt(gas);
    if (isHex(data) && data !== "0x")
      transaction.data = data;
    if (isHex(nonce))
      transaction.nonce = nonce === "0x" ? 0 : hexToNumber2(nonce);
    if (isHex(value) && value !== "0x")
      transaction.value = hexToBigInt(value);
    if (isHex(gasPrice) && gasPrice !== "0x")
      transaction.gasPrice = hexToBigInt(gasPrice);
    assertTransactionLegacy(transaction);
    if (transactionArray.length === 6)
      return transaction;
    const chainIdOrV = isHex(chainIdOrV_) && chainIdOrV_ !== "0x" ? hexToBigInt(chainIdOrV_) : 0n;
    if (s === "0x" && r === "0x") {
      if (chainIdOrV > 0)
        transaction.chainId = Number(chainIdOrV);
      return transaction;
    }
    const v = chainIdOrV;
    const chainId = Number((v - 35n) / 2n);
    if (chainId > 0)
      transaction.chainId = chainId;
    else if (v !== 27n && v !== 28n)
      throw new InvalidLegacyVError({ v });
    transaction.v = v;
    transaction.s = s;
    transaction.r = r;
    transaction.yParity = v % 2n === 0n ? 1 : 0;
    return transaction;
  }
  function toTransactionArray(serializedTransaction) {
    return fromRlp(`0x${serializedTransaction.slice(4)}`, "hex");
  }
  function parseAccessList(accessList_) {
    const accessList = [];
    for (let i = 0; i < accessList_.length; i++) {
      const [address, storageKeys] = accessList_[i];
      if (!isAddress(address, { strict: false }))
        throw new InvalidAddressError({ address });
      accessList.push({
        address,
        storageKeys: storageKeys.map((key) => isHash2(key) ? key : trim(key))
      });
    }
    return accessList;
  }
  function parseAuthorizationList(serializedAuthorizationList) {
    const authorizationList = [];
    for (let i = 0; i < serializedAuthorizationList.length; i++) {
      const [chainId, address, nonce, yParity, r, s] = serializedAuthorizationList[i];
      authorizationList.push({
        address,
        chainId: hexToNumber2(chainId),
        nonce: hexToNumber2(nonce),
        ...parseEIP155Signature([yParity, r, s])
      });
    }
    return authorizationList;
  }
  function parseEIP155Signature(transactionArray) {
    const signature = transactionArray.slice(-3);
    const v = signature[0] === "0x" || hexToBigInt(signature[0]) === 0n ? 27n : 28n;
    return {
      r: padHex(signature[1], { size: 32 }),
      s: padHex(signature[2], { size: 32 }),
      v,
      yParity: v === 27n ? 0 : 1
    };
  }
  var init_parseTransaction = __esm({
    "node_modules/viem/_esm/utils/transaction/parseTransaction.js"() {
      init_address();
      init_transaction();
      init_isAddress();
      init_toBlobSidecars();
      init_isHex();
      init_pad();
      init_trim();
      init_fromHex();
      init_fromRlp();
      init_isHash();
      init_assertTransaction();
      init_getSerializedTransactionType();
    }
  });

  // node_modules/viem/_esm/errors/unit.js
  var InvalidDecimalNumberError;
  var init_unit2 = __esm({
    "node_modules/viem/_esm/errors/unit.js"() {
      init_base2();
      InvalidDecimalNumberError = class extends BaseError2 {
        constructor({ value }) {
          super(`Number \`${value}\` is not a valid decimal number.`, {
            name: "InvalidDecimalNumberError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/unit/parseUnits.js
  function parseUnits(value, decimals) {
    if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
      throw new InvalidDecimalNumberError({ value });
    let [integer, fraction = "0"] = value.split(".");
    const negative = integer.startsWith("-");
    if (negative)
      integer = integer.slice(1);
    fraction = fraction.replace(/(0+)$/, "");
    if (decimals === 0) {
      if (Math.round(Number(`.${fraction}`)) === 1)
        integer = `${BigInt(integer) + 1n}`;
      fraction = "";
    } else if (fraction.length > decimals) {
      const [left, unit, right] = [
        fraction.slice(0, decimals - 1),
        fraction.slice(decimals - 1, decimals),
        fraction.slice(decimals)
      ];
      const rounded = Math.round(Number(`${unit}.${right}`));
      if (rounded > 9)
        fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
      else
        fraction = `${left}${rounded}`;
      if (fraction.length > decimals) {
        fraction = fraction.slice(1);
        integer = `${BigInt(integer) + 1n}`;
      }
      fraction = fraction.slice(0, decimals);
    } else {
      fraction = fraction.padEnd(decimals, "0");
    }
    return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
  }
  var init_parseUnits = __esm({
    "node_modules/viem/_esm/utils/unit/parseUnits.js"() {
      init_unit2();
    }
  });

  // node_modules/viem/_esm/utils/unit/parseEther.js
  function parseEther(ether, unit = "wei") {
    return parseUnits(ether, etherUnits[unit]);
  }
  var init_parseEther = __esm({
    "node_modules/viem/_esm/utils/unit/parseEther.js"() {
      init_unit();
      init_parseUnits();
    }
  });

  // node_modules/viem/_esm/utils/unit/parseGwei.js
  function parseGwei(ether, unit = "wei") {
    return parseUnits(ether, gweiUnits[unit]);
  }
  var init_parseGwei = __esm({
    "node_modules/viem/_esm/utils/unit/parseGwei.js"() {
      init_unit();
      init_parseUnits();
    }
  });

  // node_modules/viem/_esm/utils/nonceManager.js
  function createNonceManager(parameters) {
    const { source } = parameters;
    const deltaMap = /* @__PURE__ */ new Map();
    const nonceMap = new LruMap(8192);
    const promiseMap = /* @__PURE__ */ new Map();
    const getKey = ({ address, chainId }) => `${address}.${chainId}`;
    return {
      async consume({ address, chainId, client }) {
        const key = getKey({ address, chainId });
        const promise = this.get({ address, chainId, client });
        this.increment({ address, chainId });
        const nonce = await promise;
        await source.set({ address, chainId }, nonce);
        nonceMap.set(key, nonce);
        return nonce;
      },
      async increment({ address, chainId }) {
        const key = getKey({ address, chainId });
        const delta = deltaMap.get(key) ?? 0;
        deltaMap.set(key, delta + 1);
      },
      async get({ address, chainId, client }) {
        const key = getKey({ address, chainId });
        let promise = promiseMap.get(key);
        if (!promise) {
          promise = (async () => {
            try {
              const nonce = await source.get({ address, chainId, client });
              const previousNonce = nonceMap.get(key) ?? 0;
              if (previousNonce > 0 && nonce <= previousNonce)
                return previousNonce + 1;
              nonceMap.delete(key);
              return nonce;
            } finally {
              this.reset({ address, chainId });
            }
          })();
          promiseMap.set(key, promise);
        }
        const delta = deltaMap.get(key) ?? 0;
        return delta + await promise;
      },
      reset({ address, chainId }) {
        const key = getKey({ address, chainId });
        deltaMap.delete(key);
        promiseMap.delete(key);
      }
    };
  }
  function jsonRpc() {
    return {
      async get(parameters) {
        const { address, client } = parameters;
        return getTransactionCount(client, {
          address,
          blockTag: "pending"
        });
      },
      set() {
      }
    };
  }
  var nonceManager;
  var init_nonceManager = __esm({
    "node_modules/viem/_esm/utils/nonceManager.js"() {
      init_getTransactionCount();
      init_lru();
      nonceManager = /* @__PURE__ */ createNonceManager({
        source: jsonRpc()
      });
    }
  });

  // node_modules/viem/_esm/utils/index.js
  var init_utils9 = __esm({
    "node_modules/viem/_esm/utils/index.js"() {
      init_encodeFunctionData();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/formatters/proof.js
  function formatStorageProof(storageProof) {
    return storageProof.map((proof) => ({
      ...proof,
      value: BigInt(proof.value)
    }));
  }
  function formatProof(proof) {
    return {
      ...proof,
      balance: proof.balance ? BigInt(proof.balance) : void 0,
      nonce: proof.nonce ? hexToNumber2(proof.nonce) : void 0,
      storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
    };
  }
  var init_proof = __esm({
    "node_modules/viem/_esm/utils/formatters/proof.js"() {
      init_utils9();
    }
  });

  // node_modules/viem/_esm/actions/public/getProof.js
  async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
    const blockTag = blockTag_ ?? "latest";
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const proof = await client.request({
      method: "eth_getProof",
      params: [address, storageKeys, blockNumberHex || blockTag]
    });
    return formatProof(proof);
  }
  var init_getProof = __esm({
    "node_modules/viem/_esm/actions/public/getProof.js"() {
      init_toHex();
      init_proof();
    }
  });

  // node_modules/viem/_esm/actions/public/getStorageAt.js
  async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const data = await client.request({
      method: "eth_getStorageAt",
      params: [address, slot, blockNumberHex || blockTag]
    });
    return data;
  }
  var init_getStorageAt = __esm({
    "node_modules/viem/_esm/actions/public/getStorageAt.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransaction.js
  async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
    const blockTag = blockTag_ || "latest";
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let transaction = null;
    if (hash2) {
      transaction = await client.request({
        method: "eth_getTransactionByHash",
        params: [hash2]
      }, { dedupe: true });
    } else if (blockHash) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [blockHash, numberToHex(index2)]
      }, { dedupe: true });
    } else if (blockNumberHex || blockTag) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [blockNumberHex || blockTag, numberToHex(index2)]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!transaction)
      throw new TransactionNotFoundError({
        blockHash,
        blockNumber,
        blockTag,
        hash: hash2,
        index: index2
      });
    const format = client.chain?.formatters?.transaction?.format || formatTransaction;
    return format(transaction);
  }
  var init_getTransaction = __esm({
    "node_modules/viem/_esm/actions/public/getTransaction.js"() {
      init_transaction();
      init_toHex();
      init_transaction2();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
  async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
      getAction(client, getBlockNumber, "getBlockNumber")({}),
      hash2 ? getAction(client, getTransaction, "getTransaction")({ hash: hash2 }) : void 0
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
      return 0n;
    return blockNumber - transactionBlockNumber + 1n;
  }
  var init_getTransactionConfirmations = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionConfirmations.js"() {
      init_getAction();
      init_getBlockNumber();
      init_getTransaction();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionReceipt.js
  async function getTransactionReceipt(client, { hash: hash2 }) {
    const receipt = await client.request({
      method: "eth_getTransactionReceipt",
      params: [hash2]
    }, { dedupe: true });
    if (!receipt)
      throw new TransactionReceiptNotFoundError({ hash: hash2 });
    const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
    return format(receipt);
  }
  var init_getTransactionReceipt = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionReceipt.js"() {
      init_transaction();
      init_transactionReceipt();
    }
  });

  // node_modules/viem/_esm/actions/public/multicall.js
  async function multicall(client, parameters) {
    const { account, allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
    const contracts = parameters.contracts;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. multicallAddress is required.");
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0; i < contracts.length; i++) {
      const { abi: abi2, address, args, functionName } = contracts[i];
      try {
        const callData = encodeFunctionData({ abi: abi2, args, functionName });
        currentChunkSize += (callData.length - 2) / 2;
        if (
          // Check if batching is enabled.
          batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
          currentChunkSize > batchSize && // Check if the current chunk is not already empty.
          chunkedCalls[currentChunk].length > 0
        ) {
          currentChunk++;
          currentChunkSize = (callData.length - 2) / 2;
          chunkedCalls[currentChunk] = [];
        }
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData,
            target: address
          }
        ];
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName,
          sender: account
        });
        if (!allowFailure)
          throw error;
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData: "0x",
            target: address
          }
        ];
      }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
      abi: multicall3Abi,
      account,
      address: multicallAddress,
      args: [calls],
      blockNumber,
      blockTag,
      functionName: "aggregate3",
      stateOverride
    })));
    const results = [];
    for (let i = 0; i < aggregate3Results.length; i++) {
      const result = aggregate3Results[i];
      if (result.status === "rejected") {
        if (!allowFailure)
          throw result.reason;
        for (let j = 0; j < chunkedCalls[i].length; j++) {
          results.push({
            status: "failure",
            error: result.reason,
            result: void 0
          });
        }
        continue;
      }
      const aggregate3Result = result.value;
      for (let j = 0; j < aggregate3Result.length; j++) {
        const { returnData, success } = aggregate3Result[j];
        const { callData } = chunkedCalls[i][j];
        const { abi: abi2, address, functionName, args } = contracts[results.length];
        try {
          if (callData === "0x")
            throw new AbiDecodingZeroDataError();
          if (!success)
            throw new RawContractError({ data: returnData });
          const result2 = decodeFunctionResult({
            abi: abi2,
            args,
            data: returnData,
            functionName
          });
          results.push(allowFailure ? { result: result2, status: "success" } : result2);
        } catch (err) {
          const error = getContractError(err, {
            abi: abi2,
            address,
            args,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          results.push({ error, result: void 0, status: "failure" });
        }
      }
    }
    if (results.length !== contracts.length)
      throw new BaseError2("multicall results mismatch");
    return results;
  }
  var init_multicall = __esm({
    "node_modules/viem/_esm/actions/public/multicall.js"() {
      init_abis();
      init_abi();
      init_base2();
      init_contract();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_getContractError();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/public/simulateBlocks.js
  async function simulateBlocks(client, parameters) {
    const { blockNumber, blockTag = client.experimental_blockTag ?? "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
    try {
      const blockStateCalls = [];
      for (const block2 of blocks) {
        const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : void 0;
        const calls = block2.calls.map((call_) => {
          const call2 = call_;
          const account = call2.account ? parseAccount(call2.account) : void 0;
          const data = call2.abi ? encodeFunctionData(call2) : call2.data;
          const request2 = {
            ...call2,
            data: call2.dataSuffix ? concat([data || "0x", call2.dataSuffix]) : data,
            from: call2.from ?? account?.address
          };
          assertRequest(request2);
          return formatTransactionRequest(request2);
        });
        const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : void 0;
        blockStateCalls.push({
          blockOverrides,
          calls,
          stateOverrides
        });
      }
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const result = await client.request({
        method: "eth_simulateV1",
        params: [
          { blockStateCalls, returnFullTransactions, traceTransfers, validation },
          block
        ]
      });
      return result.map((block2, i) => ({
        ...formatBlock(block2),
        calls: block2.calls.map((call2, j) => {
          const { abi: abi2, args, functionName, to } = blocks[i].calls[j];
          const data = call2.error?.data ?? call2.returnData;
          const gasUsed = BigInt(call2.gasUsed);
          const logs = call2.logs?.map((log) => formatLog(log));
          const status = call2.status === "0x1" ? "success" : "failure";
          const result2 = abi2 && status === "success" && data !== "0x" ? decodeFunctionResult({
            abi: abi2,
            data,
            functionName
          }) : null;
          const error = (() => {
            if (status === "success")
              return void 0;
            let error2 = void 0;
            if (call2.error?.data === "0x")
              error2 = new AbiDecodingZeroDataError();
            else if (call2.error)
              error2 = new RawContractError(call2.error);
            if (!error2)
              return void 0;
            return getContractError(error2, {
              abi: abi2 ?? [],
              address: to ?? "0x",
              args,
              functionName: functionName ?? "<unknown>"
            });
          })();
          return {
            data,
            gasUsed,
            logs,
            status,
            ...status === "success" ? {
              result: result2
            } : {
              error
            }
          };
        })
      }));
    } catch (e) {
      const cause = e;
      const error = getNodeError(cause, {});
      if (error instanceof UnknownNodeError)
        throw cause;
      throw error;
    }
  }
  var init_simulateBlocks = __esm({
    "node_modules/viem/_esm/actions/public/simulateBlocks.js"() {
      init_BlockOverrides();
      init_parseAccount();
      init_abi();
      init_contract();
      init_node();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_concat();
      init_toHex();
      init_getContractError();
      init_getNodeError();
      init_block2();
      init_log2();
      init_transactionRequest();
      init_stateOverride2();
      init_assertRequest();
    }
  });

  // node_modules/ox/_esm/core/Hash.js
  function keccak2562(value, options = {}) {
    const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
    const bytes = keccak_256(from(value));
    if (as === "Bytes")
      return bytes;
    return fromBytes2(bytes);
  }
  var init_Hash = __esm({
    "node_modules/ox/_esm/core/Hash.js"() {
      init_sha3();
      init_Bytes();
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/internal/lru.js
  var LruMap2;
  var init_lru2 = __esm({
    "node_modules/ox/_esm/core/internal/lru.js"() {
      LruMap2 = class extends Map {
        constructor(size5) {
          super();
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.maxSize = size5;
        }
        get(key) {
          const value = super.get(key);
          if (super.has(key) && value !== void 0) {
            this.delete(key);
            super.set(key, value);
          }
          return value;
        }
        set(key, value) {
          super.set(key, value);
          if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
              this.delete(firstKey);
          }
          return this;
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Caches.js
  var caches, checksum;
  var init_Caches = __esm({
    "node_modules/ox/_esm/core/Caches.js"() {
      init_lru2();
      caches = {
        checksum: /* @__PURE__ */ new LruMap2(8192)
      };
      checksum = caches.checksum;
    }
  });

  // node_modules/ox/_esm/core/Address.js
  function assert2(value, options = {}) {
    const { strict = true } = options;
    if (!addressRegex2.test(value))
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidInputError()
      });
    if (strict) {
      if (value.toLowerCase() === value)
        return;
      if (checksum2(value) !== value)
        throw new InvalidAddressError2({
          address: value,
          cause: new InvalidChecksumError()
        });
    }
  }
  function checksum2(address) {
    if (checksum.has(address))
      return checksum.get(address);
    assert2(address, { strict: false });
    const hexAddress = address.substring(2).toLowerCase();
    const hash2 = keccak2562(fromString(hexAddress), { as: "Bytes" });
    const characters = hexAddress.split("");
    for (let i = 0; i < 40; i += 2) {
      if (hash2[i >> 1] >> 4 >= 8 && characters[i]) {
        characters[i] = characters[i].toUpperCase();
      }
      if ((hash2[i >> 1] & 15) >= 8 && characters[i + 1]) {
        characters[i + 1] = characters[i + 1].toUpperCase();
      }
    }
    const result = `0x${characters.join("")}`;
    checksum.set(address, result);
    return result;
  }
  function validate2(address, options = {}) {
    const { strict = true } = options ?? {};
    try {
      assert2(address, { strict });
      return true;
    } catch {
      return false;
    }
  }
  var addressRegex2, InvalidAddressError2, InvalidInputError, InvalidChecksumError;
  var init_Address = __esm({
    "node_modules/ox/_esm/core/Address.js"() {
      init_Bytes();
      init_Caches();
      init_Errors();
      init_Hash();
      addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
      InvalidAddressError2 = class extends BaseError3 {
        constructor({ address, cause }) {
          super(`Address "${address}" is invalid.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidAddressError"
          });
        }
      };
      InvalidInputError = class extends BaseError3 {
        constructor() {
          super("Address is not a 20 byte (40 hexadecimal character) value.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidInputError"
          });
        }
      };
      InvalidChecksumError = class extends BaseError3 {
        constructor() {
          super("Address does not match its checksum counterpart.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidChecksumError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/internal/abiItem.js
  function normalizeSignature2(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", "error", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new BaseError3("Unable to normalize signature.");
    return result;
  }
  function isArgOfType2(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return validate2(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType2(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes2(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return validate2(args[parameterIndex], {
            strict: false
          });
        if (types.includes("address") && types.includes("bytes"))
          return validate2(args[parameterIndex], {
            strict: false
          });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  var init_abiItem2 = __esm({
    "node_modules/ox/_esm/core/internal/abiItem.js"() {
      init_Address();
      init_Errors();
    }
  });

  // node_modules/ox/_esm/core/AbiItem.js
  function from2(abiItem, options = {}) {
    const { prepare = true } = options;
    const item = (() => {
      if (Array.isArray(abiItem))
        return parseAbiItem(abiItem);
      if (typeof abiItem === "string")
        return parseAbiItem(abiItem);
      return abiItem;
    })();
    return {
      ...item,
      ...prepare ? { hash: getSignatureHash(item) } : {}
    };
  }
  function fromAbi(abi2, name, options) {
    const { args = [], prepare = true } = options ?? {};
    const isSelector = validate(name, { strict: false });
    const abiItems = abi2.filter((abiItem2) => {
      if (isSelector) {
        if (abiItem2.type === "function" || abiItem2.type === "error")
          return getSelector(abiItem2) === slice2(name, 0, 4);
        if (abiItem2.type === "event")
          return getSignatureHash(abiItem2) === name;
        return false;
      }
      return "name" in abiItem2 && abiItem2.name === name;
    });
    if (abiItems.length === 0)
      throw new NotFoundError({ name });
    if (abiItems.length === 1)
      return {
        ...abiItems[0],
        ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
      };
    let matchedAbiItem = void 0;
    for (const abiItem2 of abiItems) {
      if (!("inputs" in abiItem2))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem2.inputs || abiItem2.inputs.length === 0)
          return {
            ...abiItem2,
            ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
          };
        continue;
      }
      if (!abiItem2.inputs)
        continue;
      if (abiItem2.inputs.length === 0)
        continue;
      if (abiItem2.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType2(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new AmbiguityError({
              abiItem: abiItem2,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem2;
      }
    }
    const abiItem = (() => {
      if (matchedAbiItem)
        return matchedAbiItem;
      const [abiItem2, ...overloads] = abiItems;
      return { ...abiItem2, overloads };
    })();
    if (!abiItem)
      throw new NotFoundError({ name });
    return {
      ...abiItem,
      ...prepare ? { hash: getSignatureHash(abiItem) } : {}
    };
  }
  function getSelector(abiItem) {
    return slice2(getSignatureHash(abiItem), 0, 4);
  }
  function getSignature(abiItem) {
    const signature = (() => {
      if (typeof abiItem === "string")
        return abiItem;
      return formatAbiItem(abiItem);
    })();
    return normalizeSignature2(signature);
  }
  function getSignatureHash(abiItem) {
    if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
      return abiItem.hash;
    return keccak2562(fromString2(getSignature(abiItem)));
  }
  var AmbiguityError, NotFoundError;
  var init_AbiItem = __esm({
    "node_modules/ox/_esm/core/AbiItem.js"() {
      init_exports();
      init_Errors();
      init_Hash();
      init_Hex();
      init_abiItem2();
      AmbiguityError = class extends BaseError3 {
        constructor(x, y) {
          super("Found ambiguous types in overloaded ABI Items.", {
            metaMessages: [
              // TODO: abitype to add support for signature-formatted ABI items.
              `\`${x.type}\` in \`${normalizeSignature2(formatAbiItem(x.abiItem))}\`, and`,
              `\`${y.type}\` in \`${normalizeSignature2(formatAbiItem(y.abiItem))}\``,
              "",
              "These types encode differently and cannot be distinguished at runtime.",
              "Remove one of the ambiguous items in the ABI."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiItem.AmbiguityError"
          });
        }
      };
      NotFoundError = class extends BaseError3 {
        constructor({ name, data, type = "item" }) {
          const selector = (() => {
            if (name)
              return ` with name "${name}"`;
            if (data)
              return ` with data "${data}"`;
            return "";
          })();
          super(`ABI ${type}${selector} not found.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiItem.NotFoundError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Solidity.js
  var arrayRegex2, bytesRegex3, integerRegex3, maxInt82, maxInt162, maxInt242, maxInt322, maxInt402, maxInt482, maxInt562, maxInt642, maxInt722, maxInt802, maxInt882, maxInt962, maxInt1042, maxInt1122, maxInt1202, maxInt1282, maxInt1362, maxInt1442, maxInt1522, maxInt1602, maxInt1682, maxInt1762, maxInt1842, maxInt1922, maxInt2002, maxInt2082, maxInt2162, maxInt2242, maxInt2322, maxInt2402, maxInt2482, maxInt2562, minInt82, minInt162, minInt242, minInt322, minInt402, minInt482, minInt562, minInt642, minInt722, minInt802, minInt882, minInt962, minInt1042, minInt1122, minInt1202, minInt1282, minInt1362, minInt1442, minInt1522, minInt1602, minInt1682, minInt1762, minInt1842, minInt1922, minInt2002, minInt2082, minInt2162, minInt2242, minInt2322, minInt2402, minInt2482, minInt2562, maxUint82, maxUint162, maxUint242, maxUint322, maxUint402, maxUint482, maxUint562, maxUint642, maxUint722, maxUint802, maxUint882, maxUint962, maxUint1042, maxUint1122, maxUint1202, maxUint1282, maxUint1362, maxUint1442, maxUint1522, maxUint1602, maxUint1682, maxUint1762, maxUint1842, maxUint1922, maxUint2002, maxUint2082, maxUint2162, maxUint2242, maxUint2322, maxUint2402, maxUint2482, maxUint2562;
  var init_Solidity = __esm({
    "node_modules/ox/_esm/core/Solidity.js"() {
      arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
      bytesRegex3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
      maxInt82 = 2n ** (8n - 1n) - 1n;
      maxInt162 = 2n ** (16n - 1n) - 1n;
      maxInt242 = 2n ** (24n - 1n) - 1n;
      maxInt322 = 2n ** (32n - 1n) - 1n;
      maxInt402 = 2n ** (40n - 1n) - 1n;
      maxInt482 = 2n ** (48n - 1n) - 1n;
      maxInt562 = 2n ** (56n - 1n) - 1n;
      maxInt642 = 2n ** (64n - 1n) - 1n;
      maxInt722 = 2n ** (72n - 1n) - 1n;
      maxInt802 = 2n ** (80n - 1n) - 1n;
      maxInt882 = 2n ** (88n - 1n) - 1n;
      maxInt962 = 2n ** (96n - 1n) - 1n;
      maxInt1042 = 2n ** (104n - 1n) - 1n;
      maxInt1122 = 2n ** (112n - 1n) - 1n;
      maxInt1202 = 2n ** (120n - 1n) - 1n;
      maxInt1282 = 2n ** (128n - 1n) - 1n;
      maxInt1362 = 2n ** (136n - 1n) - 1n;
      maxInt1442 = 2n ** (144n - 1n) - 1n;
      maxInt1522 = 2n ** (152n - 1n) - 1n;
      maxInt1602 = 2n ** (160n - 1n) - 1n;
      maxInt1682 = 2n ** (168n - 1n) - 1n;
      maxInt1762 = 2n ** (176n - 1n) - 1n;
      maxInt1842 = 2n ** (184n - 1n) - 1n;
      maxInt1922 = 2n ** (192n - 1n) - 1n;
      maxInt2002 = 2n ** (200n - 1n) - 1n;
      maxInt2082 = 2n ** (208n - 1n) - 1n;
      maxInt2162 = 2n ** (216n - 1n) - 1n;
      maxInt2242 = 2n ** (224n - 1n) - 1n;
      maxInt2322 = 2n ** (232n - 1n) - 1n;
      maxInt2402 = 2n ** (240n - 1n) - 1n;
      maxInt2482 = 2n ** (248n - 1n) - 1n;
      maxInt2562 = 2n ** (256n - 1n) - 1n;
      minInt82 = -(2n ** (8n - 1n));
      minInt162 = -(2n ** (16n - 1n));
      minInt242 = -(2n ** (24n - 1n));
      minInt322 = -(2n ** (32n - 1n));
      minInt402 = -(2n ** (40n - 1n));
      minInt482 = -(2n ** (48n - 1n));
      minInt562 = -(2n ** (56n - 1n));
      minInt642 = -(2n ** (64n - 1n));
      minInt722 = -(2n ** (72n - 1n));
      minInt802 = -(2n ** (80n - 1n));
      minInt882 = -(2n ** (88n - 1n));
      minInt962 = -(2n ** (96n - 1n));
      minInt1042 = -(2n ** (104n - 1n));
      minInt1122 = -(2n ** (112n - 1n));
      minInt1202 = -(2n ** (120n - 1n));
      minInt1282 = -(2n ** (128n - 1n));
      minInt1362 = -(2n ** (136n - 1n));
      minInt1442 = -(2n ** (144n - 1n));
      minInt1522 = -(2n ** (152n - 1n));
      minInt1602 = -(2n ** (160n - 1n));
      minInt1682 = -(2n ** (168n - 1n));
      minInt1762 = -(2n ** (176n - 1n));
      minInt1842 = -(2n ** (184n - 1n));
      minInt1922 = -(2n ** (192n - 1n));
      minInt2002 = -(2n ** (200n - 1n));
      minInt2082 = -(2n ** (208n - 1n));
      minInt2162 = -(2n ** (216n - 1n));
      minInt2242 = -(2n ** (224n - 1n));
      minInt2322 = -(2n ** (232n - 1n));
      minInt2402 = -(2n ** (240n - 1n));
      minInt2482 = -(2n ** (248n - 1n));
      minInt2562 = -(2n ** (256n - 1n));
      maxUint82 = 2n ** 8n - 1n;
      maxUint162 = 2n ** 16n - 1n;
      maxUint242 = 2n ** 24n - 1n;
      maxUint322 = 2n ** 32n - 1n;
      maxUint402 = 2n ** 40n - 1n;
      maxUint482 = 2n ** 48n - 1n;
      maxUint562 = 2n ** 56n - 1n;
      maxUint642 = 2n ** 64n - 1n;
      maxUint722 = 2n ** 72n - 1n;
      maxUint802 = 2n ** 80n - 1n;
      maxUint882 = 2n ** 88n - 1n;
      maxUint962 = 2n ** 96n - 1n;
      maxUint1042 = 2n ** 104n - 1n;
      maxUint1122 = 2n ** 112n - 1n;
      maxUint1202 = 2n ** 120n - 1n;
      maxUint1282 = 2n ** 128n - 1n;
      maxUint1362 = 2n ** 136n - 1n;
      maxUint1442 = 2n ** 144n - 1n;
      maxUint1522 = 2n ** 152n - 1n;
      maxUint1602 = 2n ** 160n - 1n;
      maxUint1682 = 2n ** 168n - 1n;
      maxUint1762 = 2n ** 176n - 1n;
      maxUint1842 = 2n ** 184n - 1n;
      maxUint1922 = 2n ** 192n - 1n;
      maxUint2002 = 2n ** 200n - 1n;
      maxUint2082 = 2n ** 208n - 1n;
      maxUint2162 = 2n ** 216n - 1n;
      maxUint2242 = 2n ** 224n - 1n;
      maxUint2322 = 2n ** 232n - 1n;
      maxUint2402 = 2n ** 240n - 1n;
      maxUint2482 = 2n ** 248n - 1n;
      maxUint2562 = 2n ** 256n - 1n;
    }
  });

  // node_modules/ox/_esm/core/internal/abiParameters.js
  function prepareParameters({ checksumAddress: checksumAddress2, parameters, values }) {
    const preparedParameters = [];
    for (let i = 0; i < parameters.length; i++) {
      preparedParameters.push(prepareParameter({
        checksumAddress: checksumAddress2,
        parameter: parameters[i],
        value: values[i]
      }));
    }
    return preparedParameters;
  }
  function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value }) {
    const parameter = parameter_;
    const arrayComponents = getArrayComponents2(parameter.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray2(value, {
        checksumAddress: checksumAddress2,
        length,
        parameter: {
          ...parameter,
          type
        }
      });
    }
    if (parameter.type === "tuple") {
      return encodeTuple2(value, {
        checksumAddress: checksumAddress2,
        parameter
      });
    }
    if (parameter.type === "address") {
      return encodeAddress2(value, {
        checksum: checksumAddress2
      });
    }
    if (parameter.type === "bool") {
      return encodeBoolean(value);
    }
    if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
      const signed = parameter.type.startsWith("int");
      const [, , size5 = "256"] = integerRegex3.exec(parameter.type) ?? [];
      return encodeNumber2(value, {
        signed,
        size: Number(size5)
      });
    }
    if (parameter.type.startsWith("bytes")) {
      return encodeBytes2(value, { type: parameter.type });
    }
    if (parameter.type === "string") {
      return encodeString2(value);
    }
    throw new InvalidTypeError(parameter.type);
  }
  function encode2(preparedParameters) {
    let staticSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
      const { dynamic, encoded } = preparedParameters[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size3(encoded);
    }
    const staticParameters = [];
    const dynamicParameters = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
      const { dynamic, encoded } = preparedParameters[i];
      if (dynamic) {
        staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
        dynamicParameters.push(encoded);
        dynamicSize += size3(encoded);
      } else {
        staticParameters.push(encoded);
      }
    }
    return concat2(...staticParameters, ...dynamicParameters);
  }
  function encodeAddress2(value, options) {
    const { checksum: checksum3 = false } = options;
    assert2(value, { strict: checksum3 });
    return {
      dynamic: false,
      encoded: padLeft(value.toLowerCase())
    };
  }
  function encodeArray2(value, options) {
    const { checksumAddress: checksumAddress2, length, parameter } = options;
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError2(value);
    if (!dynamic && value.length !== length)
      throw new ArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${parameter.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParameters = [];
    for (let i = 0; i < value.length; i++) {
      const preparedParam = prepareParameter({
        checksumAddress: checksumAddress2,
        parameter,
        value: value[i]
      });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParameters.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encode2(preparedParameters);
      if (dynamic) {
        const length2 = fromNumber(preparedParameters.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParameters.length > 0 ? concat2(length2, data) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat2(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes2(value, { type }) {
    const [, parametersize] = type.split("bytes");
    const bytesSize = size3(value);
    if (!parametersize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
      return {
        dynamic: true,
        encoded: concat2(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
      };
    }
    if (bytesSize !== Number.parseInt(parametersize))
      throw new BytesSizeMismatchError2({
        expectedSize: Number.parseInt(parametersize),
        value
      });
    return { dynamic: false, encoded: padRight(value) };
  }
  function encodeBoolean(value) {
    if (typeof value !== "boolean")
      throw new BaseError3(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
  }
  function encodeNumber2(value, { signed, size: size5 }) {
    if (typeof size5 === "number") {
      const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;
      const min = signed ? -max - 1n : 0n;
      if (value > max || value < min)
        throw new IntegerOutOfRangeError2({
          max: max.toString(),
          min: min.toString(),
          signed,
          size: size5 / 8,
          value: value.toString()
        });
    }
    return {
      dynamic: false,
      encoded: fromNumber(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString2(value) {
    const hexValue = fromString2(value);
    const partsLength = Math.ceil(size3(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
      parts.push(padRight(slice2(hexValue, i * 32, (i + 1) * 32)));
    }
    return {
      dynamic: true,
      encoded: concat2(padRight(fromNumber(size3(hexValue), { size: 32 })), ...parts)
    };
  }
  function encodeTuple2(value, options) {
    const { checksumAddress: checksumAddress2, parameter } = options;
    let dynamic = false;
    const preparedParameters = [];
    for (let i = 0; i < parameter.components.length; i++) {
      const param_ = parameter.components[i];
      const index2 = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParameter({
        checksumAddress: checksumAddress2,
        parameter: param_,
        value: value[index2]
      });
      preparedParameters.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encode2(preparedParameters) : concat2(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents2(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  var init_abiParameters = __esm({
    "node_modules/ox/_esm/core/internal/abiParameters.js"() {
      init_AbiParameters();
      init_Address();
      init_Errors();
      init_Hex();
      init_Solidity();
    }
  });

  // node_modules/ox/_esm/core/AbiParameters.js
  function encode3(parameters, values, options) {
    const { checksumAddress: checksumAddress2 = false } = options ?? {};
    if (parameters.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: parameters.length,
        givenLength: values.length
      });
    const preparedParameters = prepareParameters({
      checksumAddress: checksumAddress2,
      parameters,
      values
    });
    const data = encode2(preparedParameters);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function encodePacked2(types, values) {
    if (types.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
      });
    const data = [];
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const value = values[i];
      data.push(encodePacked2.encode(type, value));
    }
    return concat2(...data);
  }
  var ArrayLengthMismatchError, BytesSizeMismatchError2, LengthMismatchError, InvalidArrayError2, InvalidTypeError;
  var init_AbiParameters = __esm({
    "node_modules/ox/_esm/core/AbiParameters.js"() {
      init_Address();
      init_Errors();
      init_Hex();
      init_Solidity();
      init_abiParameters();
      (function(encodePacked3) {
        function encode5(type, value, isArray = false) {
          if (type === "address") {
            const address = value;
            assert2(address);
            return padLeft(address.toLowerCase(), isArray ? 32 : 0);
          }
          if (type === "string")
            return fromString2(value);
          if (type === "bytes")
            return value;
          if (type === "bool")
            return padLeft(fromBoolean(value), isArray ? 32 : 1);
          const intMatch = type.match(integerRegex3);
          if (intMatch) {
            const [_type, baseType, bits = "256"] = intMatch;
            const size5 = Number.parseInt(bits) / 8;
            return fromNumber(value, {
              size: isArray ? 32 : size5,
              signed: baseType === "int"
            });
          }
          const bytesMatch = type.match(bytesRegex3);
          if (bytesMatch) {
            const [_type, size5] = bytesMatch;
            if (Number.parseInt(size5) !== (value.length - 2) / 2)
              throw new BytesSizeMismatchError2({
                expectedSize: Number.parseInt(size5),
                value
              });
            return padRight(value, isArray ? 32 : 0);
          }
          const arrayMatch = type.match(arrayRegex2);
          if (arrayMatch && Array.isArray(value)) {
            const [_type, childType] = arrayMatch;
            const data = [];
            for (let i = 0; i < value.length; i++) {
              data.push(encode5(childType, value[i], true));
            }
            if (data.length === 0)
              return "0x";
            return concat2(...data);
          }
          throw new InvalidTypeError(type);
        }
        encodePacked3.encode = encode5;
      })(encodePacked2 || (encodePacked2 = {}));
      ArrayLengthMismatchError = class extends BaseError3 {
        constructor({ expectedLength, givenLength, type }) {
          super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.ArrayLengthMismatchError"
          });
        }
      };
      BytesSizeMismatchError2 = class extends BaseError3 {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.BytesSizeMismatchError"
          });
        }
      };
      LengthMismatchError = class extends BaseError3 {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.LengthMismatchError"
          });
        }
      };
      InvalidArrayError2 = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${value}\` is not a valid array.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.InvalidArrayError"
          });
        }
      };
      InvalidTypeError = class extends BaseError3 {
        constructor(type) {
          super(`Type \`${type}\` is not a valid ABI Type.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.InvalidTypeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/AbiConstructor.js
  function encode4(abiConstructor, options) {
    const { bytecode, args } = options;
    return concat2(bytecode, abiConstructor.inputs?.length && args?.length ? encode3(abiConstructor.inputs, args) : "0x");
  }
  function from3(abiConstructor) {
    return from2(abiConstructor);
  }
  var init_AbiConstructor = __esm({
    "node_modules/ox/_esm/core/AbiConstructor.js"() {
      init_AbiItem();
      init_AbiParameters();
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/AbiFunction.js
  function encodeData2(abiFunction, ...args) {
    const { overloads } = abiFunction;
    const item = overloads ? fromAbi2([abiFunction, ...overloads], abiFunction.name, {
      args: args[0]
    }) : abiFunction;
    const selector = getSelector2(item);
    const data = args.length > 0 ? encode3(item.inputs, args[0]) : void 0;
    return data ? concat2(selector, data) : selector;
  }
  function from4(abiFunction, options = {}) {
    return from2(abiFunction, options);
  }
  function fromAbi2(abi2, name, options) {
    const item = fromAbi(abi2, name, options);
    if (item.type !== "function")
      throw new NotFoundError({ name, type: "function" });
    return item;
  }
  function getSelector2(abiItem) {
    return getSelector(abiItem);
  }
  var init_AbiFunction = __esm({
    "node_modules/ox/_esm/core/AbiFunction.js"() {
      init_AbiItem();
      init_AbiParameters();
      init_Hex();
    }
  });

  // node_modules/viem/_esm/constants/address.js
  var ethAddress, zeroAddress;
  var init_address2 = __esm({
    "node_modules/viem/_esm/constants/address.js"() {
      ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
      zeroAddress = "0x0000000000000000000000000000000000000000";
    }
  });

  // node_modules/viem/_esm/actions/public/simulateCalls.js
  async function simulateCalls(client, parameters) {
    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
    const account = parameters.account ? parseAccount(parameters.account) : void 0;
    if (traceAssetChanges && !account)
      throw new BaseError2("`account` is required when `traceAssetChanges` is true");
    const getBalanceData = account ? encode4(from3("constructor(bytes, bytes)"), {
      bytecode: deploylessCallViaBytecodeBytecode,
      args: [
        getBalanceCode,
        encodeData2(from4("function getBalance(address)"), [account.address])
      ]
    }) : void 0;
    const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {
      if (!call2.data && !call2.abi)
        return;
      const { accessList } = await createAccessList(client, {
        account: account.address,
        ...call2,
        data: call2.abi ? encodeFunctionData(call2) : call2.data
      });
      return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
    })).then((x) => x.flat().filter(Boolean)) : [];
    const blocks = await simulateBlocks(client, {
      blockNumber,
      blockTag,
      blocks: [
        ...traceAssetChanges ? [
          // ETH pre balances
          {
            calls: [{ data: getBalanceData }],
            stateOverrides
          },
          // Asset pre balances
          {
            calls: assetAddresses.map((address, i) => ({
              abi: [
                from4("function balanceOf(address) returns (uint256)")
              ],
              functionName: "balanceOf",
              args: [account.address],
              to: address,
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          }
        ] : [],
        {
          calls: [...calls, {}].map((call2) => ({
            ...call2,
            from: account?.address
          })),
          stateOverrides
        },
        ...traceAssetChanges ? [
          // ETH post balances
          {
            calls: [{ data: getBalanceData }]
          },
          // Asset post balances
          {
            calls: assetAddresses.map((address, i) => ({
              abi: [
                from4("function balanceOf(address) returns (uint256)")
              ],
              functionName: "balanceOf",
              args: [account.address],
              to: address,
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Decimals
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [
                from4("function decimals() returns (uint256)")
              ],
              functionName: "decimals",
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Token URI
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [
                from4("function tokenURI(uint256) returns (string)")
              ],
              functionName: "tokenURI",
              args: [0n],
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Symbols
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [from4("function symbol() returns (string)")],
              functionName: "symbol",
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          }
        ] : []
      ],
      traceTransfers,
      validation
    });
    const block_results = traceAssetChanges ? blocks[2] : blocks[0];
    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
    const { calls: block_calls, ...block } = block_results;
    const results = block_calls.slice(0, -1) ?? [];
    const ethPre = block_ethPre?.calls ?? [];
    const assetsPre = block_assetsPre?.calls ?? [];
    const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
    const ethPost = block_ethPost?.calls ?? [];
    const assetsPost = block_assetsPost?.calls ?? [];
    const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
    const decimals = (block_decimals?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const symbols = (block_symbols?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const changes = [];
    for (const [i, balancePost] of balancesPost.entries()) {
      const balancePre = balancesPre[i];
      if (typeof balancePost !== "bigint")
        continue;
      if (typeof balancePre !== "bigint")
        continue;
      const decimals_ = decimals[i - 1];
      const symbol_ = symbols[i - 1];
      const tokenURI_ = tokenURI[i - 1];
      const token = (() => {
        if (i === 0)
          return {
            address: ethAddress,
            decimals: 18,
            symbol: "ETH"
          };
        return {
          address: assetAddresses[i - 1],
          decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : void 0,
          symbol: symbol_ ?? void 0
        };
      })();
      if (changes.some((change) => change.token.address === token.address))
        continue;
      changes.push({
        token,
        value: {
          pre: balancePre,
          post: balancePost,
          diff: balancePost - balancePre
        }
      });
    }
    return {
      assetChanges: changes,
      block,
      results
    };
  }
  var getBalanceCode;
  var init_simulateCalls = __esm({
    "node_modules/viem/_esm/actions/public/simulateCalls.js"() {
      init_AbiConstructor();
      init_AbiFunction();
      init_parseAccount();
      init_address2();
      init_contracts();
      init_base2();
      init_encodeFunctionData();
      init_utils9();
      init_createAccessList();
      init_simulateBlocks();
      getBalanceCode = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
    }
  });

  // node_modules/viem/_esm/utils/signature/serializeSignature.js
  function serializeSignature({ r, s, to = "hex", v, yParity }) {
    const yParity_ = (() => {
      if (yParity === 0 || yParity === 1)
        return yParity;
      if (v && (v === 27n || v === 28n || v >= 35n))
        return v % 2n === 0n ? 1 : 0;
      throw new Error("Invalid `v` or `yParity` value");
    })();
    const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
    if (to === "hex")
      return signature;
    return hexToBytes3(signature);
  }
  var init_serializeSignature = __esm({
    "node_modules/viem/_esm/utils/signature/serializeSignature.js"() {
      init_secp256k1();
      init_fromHex();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyHash.js
  async function verifyHash2(client, parameters) {
    const { address, factory, factoryData, hash: hash2, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
    const signatureHex = (() => {
      if (isHex(signature))
        return signature;
      if (typeof signature === "object" && "r" in signature && "s" in signature)
        return serializeSignature(signature);
      return bytesToHex3(signature);
    })();
    const wrappedSignature = await (async () => {
      if (!factory && !factoryData)
        return signatureHex;
      if (isErc6492Signature(signatureHex))
        return signatureHex;
      return serializeErc6492Signature({
        address: factory,
        data: factoryData,
        signature: signatureHex
      });
    })();
    try {
      const args = universalSignatureVerifierAddress ? {
        to: universalSignatureVerifierAddress,
        data: encodeFunctionData({
          abi: universalSignatureValidatorAbi,
          functionName: "isValidSig",
          args: [address, hash2, wrappedSignature]
        }),
        ...rest
      } : {
        data: encodeDeployData({
          abi: universalSignatureValidatorAbi,
          args: [address, hash2, wrappedSignature],
          bytecode: universalSignatureValidatorByteCode
        }),
        ...rest
      };
      const { data } = await getAction(client, call, "call")(args);
      return hexToBool(data ?? "0x0");
    } catch (error) {
      try {
        const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));
        if (verified)
          return true;
      } catch {
      }
      if (error instanceof CallExecutionError) {
        return false;
      }
      throw error;
    }
  }
  var init_verifyHash2 = __esm({
    "node_modules/viem/_esm/actions/public/verifyHash.js"() {
      init_abis();
      init_contracts();
      init_contract();
      init_encodeDeployData();
      init_getAddress();
      init_isAddressEqual();
      init_isHex();
      init_toHex();
      init_getAction();
      init_utils9();
      init_isErc6492Signature();
      init_recoverAddress();
      init_serializeErc6492Signature();
      init_serializeSignature();
      init_call();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyMessage.js
  async function verifyMessage2(client, { address, message, factory, factoryData, signature, ...callRequest }) {
    const hash2 = hashMessage(message);
    return verifyHash2(client, {
      address,
      factory,
      factoryData,
      hash: hash2,
      signature,
      ...callRequest
    });
  }
  var init_verifyMessage2 = __esm({
    "node_modules/viem/_esm/actions/public/verifyMessage.js"() {
      init_hashMessage();
      init_verifyHash2();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyTypedData.js
  async function verifyTypedData2(client, parameters) {
    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
    const hash2 = hashTypedData({ message, primaryType, types, domain });
    return verifyHash2(client, {
      address,
      factory,
      factoryData,
      hash: hash2,
      signature,
      ...callRequest
    });
  }
  var init_verifyTypedData2 = __esm({
    "node_modules/viem/_esm/actions/public/verifyTypedData.js"() {
      init_hashTypedData();
      init_verifyHash2();
    }
  });

  // node_modules/viem/_esm/actions/public/watchBlockNumber.js
  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    let prevBlockNumber;
    const pollBlockNumber = () => {
      const observerId = stringify([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
      ]);
      return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
        try {
          const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                emit.onBlockNumber(i, prevBlockNumber);
                prevBlockNumber = i;
              }
            }
          }
          if (!prevBlockNumber || blockNumber > prevBlockNumber) {
            emit.onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlockNumber = () => {
      const observerId = stringify([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed
      ]);
      return observe(observerId, { onBlockNumber, onError }, (emit) => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const transport = (() => {
              if (client.transport.type === "fallback") {
                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
                if (!transport2)
                  return client.transport;
                return transport2.value;
              }
              return client.transport;
            })();
            const { unsubscribe: unsubscribe_ } = await transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = hexToBigInt(data.result?.number);
                emit.onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                emit.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
  }
  var init_watchBlockNumber = __esm({
    "node_modules/viem/_esm/actions/public/watchBlockNumber.js"() {
      init_fromHex();
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_getBlockNumber();
    }
  });

  // node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
  async function waitForTransactionReceipt(client, parameters) {
    const {
      checkReplacement = true,
      confirmations = 1,
      hash: hash2,
      onReplaced,
      retryCount = 6,
      retryDelay = ({ count }) => ~~(1 << count) * 200,
      // exponential backoff
      timeout = 18e4
    } = parameters;
    const observerId = stringify(["waitForTransactionReceipt", client.uid, hash2]);
    const pollingInterval = (() => {
      if (parameters.pollingInterval)
        return parameters.pollingInterval;
      if (client.chain?.experimental_preconfirmationTime)
        return client.chain.experimental_preconfirmationTime;
      return client.pollingInterval;
    })();
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    let _unobserve;
    let _unwatch;
    const { promise, resolve, reject } = withResolvers();
    const timer = timeout ? setTimeout(() => {
      _unwatch();
      _unobserve();
      reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 }));
    }, timeout) : void 0;
    _unobserve = observe(observerId, { onReplaced, resolve, reject }, async (emit) => {
      receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 }).catch(() => void 0);
      if (receipt && confirmations <= 1) {
        clearTimeout(timer);
        emit.resolve(receipt);
        _unobserve();
        return;
      }
      _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          const done = (fn) => {
            clearTimeout(timer);
            _unwatch();
            fn();
            _unobserve();
          };
          let blockNumber = blockNumber_;
          if (retrying)
            return;
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (checkReplacement && !transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
              if (!transaction) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction;
                retrying = true;
                const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from: from5, nonce }) => from5 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err));
            }
          }
        }
      });
    });
    return promise;
  }
  var init_waitForTransactionReceipt = __esm({
    "node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js"() {
      init_block();
      init_transaction();
      init_getAction();
      init_observe();
      init_withResolvers();
      init_withRetry();
      init_stringify();
      init_getBlock();
      init_getTransaction();
      init_getTransactionReceipt();
      init_watchBlockNumber();
    }
  });

  // node_modules/viem/_esm/actions/public/watchBlocks.js
  function watchBlocks(client, { blockTag = client.experimental_blockTag ?? "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = () => {
      const observerId = stringify([
        "watchBlocks",
        client.uid,
        blockTag,
        emitMissed,
        emitOnBegin,
        includeTransactions,
        pollingInterval
      ]);
      return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
        try {
          const block = await getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          });
          if (block.number !== null && prevBlock?.number != null) {
            if (block.number === prevBlock.number)
              return;
            if (block.number - prevBlock.number > 1 && emitMissed) {
              for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                const block2 = await getAction(client, getBlock, "getBlock")({
                  blockNumber: i,
                  includeTransactions
                });
                emit.onBlock(block2, prevBlock);
                prevBlock = block2;
              }
            }
          }
          if (
            // If no previous block exists, emit.
            prevBlock?.number == null || // If the block tag is "pending" with no block number, emit.
            blockTag === "pending" && block?.number == null || // If the next block number is greater than the previous block number, emit.
            // We don't want to emit blocks in the past.
            block.number !== null && block.number > prevBlock.number
          ) {
            emit.onBlock(block, prevBlock);
            prevBlock = block;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlocks = () => {
      let active = true;
      let emitFetched = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          if (emitOnBegin) {
            getAction(client, getBlock, "getBlock")({
              blockTag,
              includeTransactions
            }).then((block) => {
              if (!active)
                return;
              if (!emitFetched)
                return;
              onBlock(block, void 0);
              emitFetched = false;
            }).catch(onError);
          }
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            async onData(data) {
              if (!active)
                return;
              const block = await getAction(client, getBlock, "getBlock")({
                blockNumber: data.result?.number,
                includeTransactions
              }).catch(() => {
              });
              if (!active)
                return;
              onBlock(block, prevBlock);
              emitFetched = false;
              prevBlock = block;
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
  }
  var init_watchBlocks = __esm({
    "node_modules/viem/_esm/actions/public/watchBlocks.js"() {
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_getBlock();
    }
  });

  // node_modules/viem/_esm/actions/public/watchEvent.js
  function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (typeof fromBlock === "bigint")
        return true;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const strict = strict_ ?? false;
    const pollEvent = () => {
      const observerId = stringify([
        "watchEvent",
        address,
        args,
        batch,
        client.uid,
        event,
        pollingInterval,
        fromBlock
      ]);
      return observe(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        if (fromBlock !== void 0)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = poll(async () => {
          if (!initialized) {
            try {
              filter = await getAction(client, createEventFilter, "createEventFilter")({
                address,
                args,
                event,
                events,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await getAction(client, getLogs, "getLogs")({
                  address,
                  args,
                  event,
                  events,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              for (const log of logs)
                emit.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof InvalidInputRpcError)
              initialized = false;
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeEvent = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const events_ = events ?? (event ? [event] : void 0);
          let topics = [];
          if (events_) {
            const encoded = events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }));
            topics = [encoded];
            if (event)
              topics = topics[0];
          }
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName, args: args2 } = decodeEventLog({
                  abi: events_ ?? [],
                  data: log.data,
                  topics: log.topics,
                  strict
                });
                const formatted = formatLog(log, { args: args2, eventName });
                onLogs([formatted]);
              } catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName
                });
                onLogs([formatted]);
              }
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollEvent() : subscribeEvent();
  }
  var init_watchEvent = __esm({
    "node_modules/viem/_esm/actions/public/watchEvent.js"() {
      init_encodeEventTopics();
      init_observe();
      init_poll();
      init_stringify();
      init_abi();
      init_rpc();
      init_decodeEventLog();
      init_log2();
      init_getAction();
      init_createEventFilter();
      init_getBlockNumber();
      init_getFilterChanges();
      init_getLogs();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/actions/public/watchPendingTransactions.js
  function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" && client.transport.type !== "ipc";
    const pollPendingTransactions = () => {
      const observerId = stringify([
        "watchPendingTransactions",
        client.uid,
        batch,
        pollingInterval
      ]);
      return observe(observerId, { onTransactions, onError }, (emit) => {
        let filter;
        const unwatch = poll(async () => {
          try {
            if (!filter) {
              try {
                filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
                return;
              } catch (err) {
                unwatch();
                throw err;
              }
            }
            const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            if (hashes.length === 0)
              return;
            if (batch)
              emit.onTransactions(hashes);
            else
              for (const hash2 of hashes)
                emit.onTransactions([hash2]);
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribePendingTransactions = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newPendingTransactions"],
            onData(data) {
              if (!active)
                return;
              const transaction = data.result;
              onTransactions([transaction]);
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
  }
  var init_watchPendingTransactions = __esm({
    "node_modules/viem/_esm/actions/public/watchPendingTransactions.js"() {
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_createPendingTransactionFilter();
      init_getFilterChanges();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
  function parseSiweMessage(message) {
    const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
    const resources = message.split("Resources:")[1]?.split("\n- ").slice(1);
    return {
      ...prefix,
      ...suffix,
      ...chainId ? { chainId: Number(chainId) } : {},
      ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
      ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
      ...notBefore ? { notBefore: new Date(notBefore) } : {},
      ...requestId ? { requestId } : {},
      ...resources ? { resources } : {},
      ...scheme ? { scheme } : {},
      ...statement ? { statement } : {}
    };
  }
  var prefixRegex, suffixRegex;
  var init_parseSiweMessage = __esm({
    "node_modules/viem/_esm/utils/siwe/parseSiweMessage.js"() {
      prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
      suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
    }
  });

  // node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
  function validateSiweMessage(parameters) {
    const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = parameters;
    if (domain && message.domain !== domain)
      return false;
    if (nonce && message.nonce !== nonce)
      return false;
    if (scheme && message.scheme !== scheme)
      return false;
    if (message.expirationTime && time >= message.expirationTime)
      return false;
    if (message.notBefore && time < message.notBefore)
      return false;
    try {
      if (!message.address)
        return false;
      if (!isAddress(message.address, { strict: false }))
        return false;
      if (address && !isAddressEqual(message.address, address))
        return false;
    } catch {
      return false;
    }
    return true;
  }
  var init_validateSiweMessage = __esm({
    "node_modules/viem/_esm/utils/siwe/validateSiweMessage.js"() {
      init_isAddress();
      init_isAddressEqual();
    }
  });

  // node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
  async function verifySiweMessage(client, parameters) {
    const { address, domain, message, nonce, scheme, signature, time = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
    const parsed = parseSiweMessage(message);
    if (!parsed.address)
      return false;
    const isValid = validateSiweMessage({
      address,
      domain,
      message: parsed,
      nonce,
      scheme,
      time
    });
    if (!isValid)
      return false;
    const hash2 = hashMessage(message);
    return verifyHash2(client, {
      address: parsed.address,
      hash: hash2,
      signature,
      ...callRequest
    });
  }
  var init_verifySiweMessage = __esm({
    "node_modules/viem/_esm/actions/siwe/verifySiweMessage.js"() {
      init_hashMessage();
      init_parseSiweMessage();
      init_validateSiweMessage();
      init_verifyHash2();
    }
  });

  // node_modules/viem/_esm/clients/decorators/public.js
  function publicActions(client) {
    return {
      call: (args) => call(client, args),
      createAccessList: (args) => createAccessList(client, args),
      createBlockFilter: () => createBlockFilter(client),
      createContractEventFilter: (args) => createContractEventFilter(client, args),
      createEventFilter: (args) => createEventFilter(client, args),
      createPendingTransactionFilter: () => createPendingTransactionFilter(client),
      estimateContractGas: (args) => estimateContractGas(client, args),
      estimateGas: (args) => estimateGas(client, args),
      getBalance: (args) => getBalance(client, args),
      getBlobBaseFee: () => getBlobBaseFee(client),
      getBlock: (args) => getBlock(client, args),
      getBlockNumber: (args) => getBlockNumber(client, args),
      getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
      getBytecode: (args) => getCode(client, args),
      getChainId: () => getChainId(client),
      getCode: (args) => getCode(client, args),
      getContractEvents: (args) => getContractEvents(client, args),
      getEip712Domain: (args) => getEip712Domain(client, args),
      getEnsAddress: (args) => getEnsAddress(client, args),
      getEnsAvatar: (args) => getEnsAvatar(client, args),
      getEnsName: (args) => getEnsName(client, args),
      getEnsResolver: (args) => getEnsResolver(client, args),
      getEnsText: (args) => getEnsText(client, args),
      getFeeHistory: (args) => getFeeHistory(client, args),
      estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
      getFilterChanges: (args) => getFilterChanges(client, args),
      getFilterLogs: (args) => getFilterLogs(client, args),
      getGasPrice: () => getGasPrice(client),
      getLogs: (args) => getLogs(client, args),
      getProof: (args) => getProof(client, args),
      estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
      getStorageAt: (args) => getStorageAt(client, args),
      getTransaction: (args) => getTransaction(client, args),
      getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
      getTransactionCount: (args) => getTransactionCount(client, args),
      getTransactionReceipt: (args) => getTransactionReceipt(client, args),
      multicall: (args) => multicall(client, args),
      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
      readContract: (args) => readContract(client, args),
      sendRawTransaction: (args) => sendRawTransaction(client, args),
      simulate: (args) => simulateBlocks(client, args),
      simulateBlocks: (args) => simulateBlocks(client, args),
      simulateCalls: (args) => simulateCalls(client, args),
      simulateContract: (args) => simulateContract(client, args),
      verifyMessage: (args) => verifyMessage2(client, args),
      verifySiweMessage: (args) => verifySiweMessage(client, args),
      verifyTypedData: (args) => verifyTypedData2(client, args),
      uninstallFilter: (args) => uninstallFilter(client, args),
      waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
      watchBlocks: (args) => watchBlocks(client, args),
      watchBlockNumber: (args) => watchBlockNumber(client, args),
      watchContractEvent: (args) => watchContractEvent(client, args),
      watchEvent: (args) => watchEvent(client, args),
      watchPendingTransactions: (args) => watchPendingTransactions(client, args)
    };
  }
  var init_public = __esm({
    "node_modules/viem/_esm/clients/decorators/public.js"() {
      init_getEnsAddress();
      init_getEnsAvatar();
      init_getEnsName();
      init_getEnsResolver();
      init_getEnsText();
      init_call();
      init_createAccessList();
      init_createBlockFilter();
      init_createContractEventFilter();
      init_createEventFilter();
      init_createPendingTransactionFilter();
      init_estimateContractGas();
      init_estimateFeesPerGas();
      init_estimateGas2();
      init_estimateMaxPriorityFeePerGas();
      init_getBalance();
      init_getBlobBaseFee();
      init_getBlock();
      init_getBlockNumber();
      init_getBlockTransactionCount();
      init_getChainId();
      init_getCode();
      init_getContractEvents();
      init_getEip712Domain();
      init_getFeeHistory();
      init_getFilterChanges();
      init_getFilterLogs();
      init_getGasPrice();
      init_getLogs();
      init_getProof();
      init_getStorageAt();
      init_getTransaction();
      init_getTransactionConfirmations();
      init_getTransactionCount();
      init_getTransactionReceipt();
      init_multicall();
      init_readContract();
      init_simulateBlocks();
      init_simulateCalls();
      init_simulateContract();
      init_uninstallFilter();
      init_verifyMessage2();
      init_verifyTypedData2();
      init_waitForTransactionReceipt();
      init_watchBlockNumber();
      init_watchBlocks();
      init_watchContractEvent();
      init_watchEvent();
      init_watchPendingTransactions();
      init_verifySiweMessage();
      init_prepareTransactionRequest();
      init_sendRawTransaction();
    }
  });

  // node_modules/viem/_esm/clients/createPublicClient.js
  function createPublicClient(parameters) {
    const { key = "public", name = "Public Client" } = parameters;
    const client = createClient({
      ...parameters,
      key,
      name,
      type: "publicClient"
    });
    return client.extend(publicActions);
  }
  var init_createPublicClient = __esm({
    "node_modules/viem/_esm/clients/createPublicClient.js"() {
      init_createClient();
      init_public();
    }
  });

  // node_modules/viem/_esm/actions/test/dropTransaction.js
  async function dropTransaction(client, { hash: hash2 }) {
    await client.request({
      method: `${client.mode}_dropTransaction`,
      params: [hash2]
    });
  }
  var init_dropTransaction = __esm({
    "node_modules/viem/_esm/actions/test/dropTransaction.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/dumpState.js
  async function dumpState(client) {
    return client.request({
      method: `${client.mode}_dumpState`
    });
  }
  var init_dumpState = __esm({
    "node_modules/viem/_esm/actions/test/dumpState.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/getAutomine.js
  async function getAutomine(client) {
    if (client.mode === "ganache")
      return await client.request({
        method: "eth_mining"
      });
    return await client.request({
      method: `${client.mode}_getAutomine`
    });
  }
  var init_getAutomine = __esm({
    "node_modules/viem/_esm/actions/test/getAutomine.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/getTxpoolContent.js
  async function getTxpoolContent(client) {
    return await client.request({
      method: "txpool_content"
    });
  }
  var init_getTxpoolContent = __esm({
    "node_modules/viem/_esm/actions/test/getTxpoolContent.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/getTxpoolStatus.js
  async function getTxpoolStatus(client) {
    const { pending, queued } = await client.request({
      method: "txpool_status"
    });
    return {
      pending: hexToNumber2(pending),
      queued: hexToNumber2(queued)
    };
  }
  var init_getTxpoolStatus = __esm({
    "node_modules/viem/_esm/actions/test/getTxpoolStatus.js"() {
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/actions/test/impersonateAccount.js
  async function impersonateAccount(client, { address }) {
    await client.request({
      method: `${client.mode}_impersonateAccount`,
      params: [address]
    });
  }
  var init_impersonateAccount = __esm({
    "node_modules/viem/_esm/actions/test/impersonateAccount.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/increaseTime.js
  async function increaseTime(client, { seconds }) {
    return await client.request({
      method: "evm_increaseTime",
      params: [numberToHex(seconds)]
    });
  }
  var init_increaseTime = __esm({
    "node_modules/viem/_esm/actions/test/increaseTime.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/inspectTxpool.js
  async function inspectTxpool(client) {
    return await client.request({
      method: "txpool_inspect"
    });
  }
  var init_inspectTxpool = __esm({
    "node_modules/viem/_esm/actions/test/inspectTxpool.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/loadState.js
  async function loadState(client, { state }) {
    await client.request({
      method: `${client.mode}_loadState`,
      params: [state]
    });
  }
  var init_loadState = __esm({
    "node_modules/viem/_esm/actions/test/loadState.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/mine.js
  async function mine(client, { blocks, interval }) {
    if (client.mode === "ganache")
      await client.request({
        method: "evm_mine",
        params: [{ blocks: numberToHex(blocks) }]
      });
    else
      await client.request({
        method: `${client.mode}_mine`,
        params: [numberToHex(blocks), numberToHex(interval || 0)]
      });
  }
  var init_mine = __esm({
    "node_modules/viem/_esm/actions/test/mine.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/removeBlockTimestampInterval.js
  async function removeBlockTimestampInterval(client) {
    await client.request({
      method: `${client.mode}_removeBlockTimestampInterval`
    });
  }
  var init_removeBlockTimestampInterval = __esm({
    "node_modules/viem/_esm/actions/test/removeBlockTimestampInterval.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/reset.js
  async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
    await client.request({
      method: `${client.mode}_reset`,
      params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
    });
  }
  var init_reset = __esm({
    "node_modules/viem/_esm/actions/test/reset.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/revert.js
  async function revert(client, { id }) {
    await client.request({
      method: "evm_revert",
      params: [id]
    });
  }
  var init_revert = __esm({
    "node_modules/viem/_esm/actions/test/revert.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/sendUnsignedTransaction.js
  async function sendUnsignedTransaction(client, args) {
    const { accessList, data, from: from5, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      accessList,
      data,
      from: from5,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const hash2 = await client.request({
      method: "eth_sendUnsignedTransaction",
      params: [request2]
    });
    return hash2;
  }
  var init_sendUnsignedTransaction = __esm({
    "node_modules/viem/_esm/actions/test/sendUnsignedTransaction.js"() {
      init_extract();
      init_transactionRequest();
    }
  });

  // node_modules/viem/_esm/actions/test/setAutomine.js
  async function setAutomine(client, enabled) {
    if (client.mode === "ganache") {
      if (enabled)
        await client.request({ method: "miner_start" });
      else
        await client.request({ method: "miner_stop" });
    } else
      await client.request({
        method: "evm_setAutomine",
        params: [enabled]
      });
  }
  var init_setAutomine = __esm({
    "node_modules/viem/_esm/actions/test/setAutomine.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setBalance.js
  async function setBalance(client, { address, value }) {
    if (client.mode === "ganache")
      await client.request({
        method: "evm_setAccountBalance",
        params: [address, numberToHex(value)]
      });
    else
      await client.request({
        method: `${client.mode}_setBalance`,
        params: [address, numberToHex(value)]
      });
  }
  var init_setBalance = __esm({
    "node_modules/viem/_esm/actions/test/setBalance.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setBlockGasLimit.js
  async function setBlockGasLimit(client, { gasLimit }) {
    await client.request({
      method: "evm_setBlockGasLimit",
      params: [numberToHex(gasLimit)]
    });
  }
  var init_setBlockGasLimit = __esm({
    "node_modules/viem/_esm/actions/test/setBlockGasLimit.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setBlockTimestampInterval.js
  async function setBlockTimestampInterval(client, { interval }) {
    const interval_ = (() => {
      if (client.mode === "hardhat")
        return interval * 1e3;
      return interval;
    })();
    await client.request({
      method: `${client.mode}_setBlockTimestampInterval`,
      params: [interval_]
    });
  }
  var init_setBlockTimestampInterval = __esm({
    "node_modules/viem/_esm/actions/test/setBlockTimestampInterval.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setCode.js
  async function setCode(client, { address, bytecode }) {
    if (client.mode === "ganache")
      await client.request({
        method: "evm_setAccountCode",
        params: [address, bytecode]
      });
    else
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
  }
  var init_setCode = __esm({
    "node_modules/viem/_esm/actions/test/setCode.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setCoinbase.js
  async function setCoinbase(client, { address }) {
    await client.request({
      method: `${client.mode}_setCoinbase`,
      params: [address]
    });
  }
  var init_setCoinbase = __esm({
    "node_modules/viem/_esm/actions/test/setCoinbase.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setIntervalMining.js
  async function setIntervalMining(client, { interval }) {
    const interval_ = (() => {
      if (client.mode === "hardhat")
        return interval * 1e3;
      return interval;
    })();
    await client.request({
      method: "evm_setIntervalMining",
      params: [interval_]
    });
  }
  var init_setIntervalMining = __esm({
    "node_modules/viem/_esm/actions/test/setIntervalMining.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setLoggingEnabled.js
  async function setLoggingEnabled(client, enabled) {
    await client.request({
      method: `${client.mode}_setLoggingEnabled`,
      params: [enabled]
    });
  }
  var init_setLoggingEnabled = __esm({
    "node_modules/viem/_esm/actions/test/setLoggingEnabled.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setMinGasPrice.js
  async function setMinGasPrice(client, { gasPrice }) {
    await client.request({
      method: `${client.mode}_setMinGasPrice`,
      params: [numberToHex(gasPrice)]
    });
  }
  var init_setMinGasPrice = __esm({
    "node_modules/viem/_esm/actions/test/setMinGasPrice.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setNextBlockBaseFeePerGas.js
  async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
    await client.request({
      method: `${client.mode}_setNextBlockBaseFeePerGas`,
      params: [numberToHex(baseFeePerGas)]
    });
  }
  var init_setNextBlockBaseFeePerGas = __esm({
    "node_modules/viem/_esm/actions/test/setNextBlockBaseFeePerGas.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setNextBlockTimestamp.js
  async function setNextBlockTimestamp(client, { timestamp }) {
    await client.request({
      method: "evm_setNextBlockTimestamp",
      params: [numberToHex(timestamp)]
    });
  }
  var init_setNextBlockTimestamp = __esm({
    "node_modules/viem/_esm/actions/test/setNextBlockTimestamp.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setNonce.js
  async function setNonce(client, { address, nonce }) {
    await client.request({
      method: `${client.mode}_setNonce`,
      params: [address, numberToHex(nonce)]
    });
  }
  var init_setNonce = __esm({
    "node_modules/viem/_esm/actions/test/setNonce.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/setRpcUrl.js
  async function setRpcUrl(client, jsonRpcUrl) {
    await client.request({
      method: `${client.mode}_setRpcUrl`,
      params: [jsonRpcUrl]
    });
  }
  var init_setRpcUrl = __esm({
    "node_modules/viem/_esm/actions/test/setRpcUrl.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/setStorageAt.js
  async function setStorageAt(client, { address, index: index2, value }) {
    await client.request({
      method: `${client.mode}_setStorageAt`,
      params: [
        address,
        typeof index2 === "number" ? numberToHex(index2) : index2,
        value
      ]
    });
  }
  var init_setStorageAt = __esm({
    "node_modules/viem/_esm/actions/test/setStorageAt.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/test/snapshot.js
  async function snapshot(client) {
    return await client.request({
      method: "evm_snapshot"
    });
  }
  var init_snapshot = __esm({
    "node_modules/viem/_esm/actions/test/snapshot.js"() {
    }
  });

  // node_modules/viem/_esm/actions/test/stopImpersonatingAccount.js
  async function stopImpersonatingAccount(client, { address }) {
    await client.request({
      method: `${client.mode}_stopImpersonatingAccount`,
      params: [address]
    });
  }
  var init_stopImpersonatingAccount = __esm({
    "node_modules/viem/_esm/actions/test/stopImpersonatingAccount.js"() {
    }
  });

  // node_modules/viem/_esm/clients/decorators/test.js
  function testActions({ mode }) {
    return (client_) => {
      const client = client_.extend(() => ({
        mode
      }));
      return {
        dropTransaction: (args) => dropTransaction(client, args),
        dumpState: () => dumpState(client),
        getAutomine: () => getAutomine(client),
        getTxpoolContent: () => getTxpoolContent(client),
        getTxpoolStatus: () => getTxpoolStatus(client),
        impersonateAccount: (args) => impersonateAccount(client, args),
        increaseTime: (args) => increaseTime(client, args),
        inspectTxpool: () => inspectTxpool(client),
        loadState: (args) => loadState(client, args),
        mine: (args) => mine(client, args),
        removeBlockTimestampInterval: () => removeBlockTimestampInterval(client),
        reset: (args) => reset(client, args),
        revert: (args) => revert(client, args),
        sendUnsignedTransaction: (args) => sendUnsignedTransaction(client, args),
        setAutomine: (args) => setAutomine(client, args),
        setBalance: (args) => setBalance(client, args),
        setBlockGasLimit: (args) => setBlockGasLimit(client, args),
        setBlockTimestampInterval: (args) => setBlockTimestampInterval(client, args),
        setCode: (args) => setCode(client, args),
        setCoinbase: (args) => setCoinbase(client, args),
        setIntervalMining: (args) => setIntervalMining(client, args),
        setLoggingEnabled: (args) => setLoggingEnabled(client, args),
        setMinGasPrice: (args) => setMinGasPrice(client, args),
        setNextBlockBaseFeePerGas: (args) => setNextBlockBaseFeePerGas(client, args),
        setNextBlockTimestamp: (args) => setNextBlockTimestamp(client, args),
        setNonce: (args) => setNonce(client, args),
        setRpcUrl: (args) => setRpcUrl(client, args),
        setStorageAt: (args) => setStorageAt(client, args),
        snapshot: () => snapshot(client),
        stopImpersonatingAccount: (args) => stopImpersonatingAccount(client, args)
      };
    };
  }
  var init_test = __esm({
    "node_modules/viem/_esm/clients/decorators/test.js"() {
      init_dropTransaction();
      init_dumpState();
      init_getAutomine();
      init_getTxpoolContent();
      init_getTxpoolStatus();
      init_impersonateAccount();
      init_increaseTime();
      init_inspectTxpool();
      init_loadState();
      init_mine();
      init_removeBlockTimestampInterval();
      init_reset();
      init_revert();
      init_sendUnsignedTransaction();
      init_setAutomine();
      init_setBalance();
      init_setBlockGasLimit();
      init_setBlockTimestampInterval();
      init_setCode();
      init_setCoinbase();
      init_setIntervalMining();
      init_setLoggingEnabled();
      init_setMinGasPrice();
      init_setNextBlockBaseFeePerGas();
      init_setNextBlockTimestamp();
      init_setNonce();
      init_setRpcUrl();
      init_setStorageAt();
      init_snapshot();
      init_stopImpersonatingAccount();
    }
  });

  // node_modules/viem/_esm/clients/createTestClient.js
  function createTestClient(parameters) {
    const { key = "test", name = "Test Client", mode } = parameters;
    const client = createClient({
      ...parameters,
      key,
      name,
      type: "testClient"
    });
    return client.extend((config2) => ({
      mode,
      ...testActions({ mode })(config2)
    }));
  }
  var init_createTestClient = __esm({
    "node_modules/viem/_esm/clients/createTestClient.js"() {
      init_createClient();
      init_test();
    }
  });

  // node_modules/viem/_esm/actions/wallet/addChain.js
  async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: numberToHex(id),
          chainName: name,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
        }
      ]
    }, { dedupe: true, retryCount: 0 });
  }
  var init_addChain = __esm({
    "node_modules/viem/_esm/actions/wallet/addChain.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/deployContract.js
  function deployContract(walletClient, parameters) {
    const { abi: abi2, args, bytecode, ...request2 } = parameters;
    const calldata = encodeDeployData({ abi: abi2, args, bytecode });
    return sendTransaction(walletClient, {
      ...request2,
      ...request2.authorizationList ? { to: null } : {},
      data: calldata
    });
  }
  var init_deployContract = __esm({
    "node_modules/viem/_esm/actions/wallet/deployContract.js"() {
      init_encodeDeployData();
      init_sendTransaction();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getAddresses.js
  async function getAddresses(client) {
    if (client.account?.type === "local")
      return [client.account.address];
    const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
    return addresses.map((address) => checksumAddress(address));
  }
  var init_getAddresses = __esm({
    "node_modules/viem/_esm/actions/wallet/getAddresses.js"() {
      init_getAddress();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getCapabilities.js
  async function getCapabilities(client, parameters = {}) {
    const { account = client.account, chainId } = parameters;
    const account_ = account ? parseAccount(account) : void 0;
    const params = chainId ? [account_?.address, [numberToHex(chainId)]] : [account_?.address];
    const capabilities_raw = await client.request({
      method: "wallet_getCapabilities",
      params
    });
    const capabilities = {};
    for (const [chainId2, capabilities_] of Object.entries(capabilities_raw)) {
      capabilities[Number(chainId2)] = {};
      for (let [key, value] of Object.entries(capabilities_)) {
        if (key === "addSubAccount")
          key = "unstable_addSubAccount";
        capabilities[Number(chainId2)][key] = value;
      }
    }
    return typeof chainId === "number" ? capabilities[chainId] : capabilities;
  }
  var init_getCapabilities = __esm({
    "node_modules/viem/_esm/actions/wallet/getCapabilities.js"() {
      init_parseAccount();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getPermissions.js
  async function getPermissions(client) {
    const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
    return permissions;
  }
  var init_getPermissions = __esm({
    "node_modules/viem/_esm/actions/wallet/getPermissions.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/prepareAuthorization.js
  async function prepareAuthorization(client, parameters) {
    const { account: account_ = client.account, chainId, nonce } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/eip7702/prepareAuthorization"
      });
    const account = parseAccount(account_);
    const executor = (() => {
      if (!parameters.executor)
        return void 0;
      if (parameters.executor === "self")
        return parameters.executor;
      return parseAccount(parameters.executor);
    })();
    const authorization = {
      address: parameters.contractAddress ?? parameters.address,
      chainId,
      nonce
    };
    if (typeof authorization.chainId === "undefined")
      authorization.chainId = client.chain?.id ?? await getAction(client, getChainId, "getChainId")({});
    if (typeof authorization.nonce === "undefined") {
      authorization.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
      if (executor === "self" || executor?.address && isAddressEqual(executor.address, account.address))
        authorization.nonce += 1;
    }
    return authorization;
  }
  var init_prepareAuthorization = __esm({
    "node_modules/viem/_esm/actions/wallet/prepareAuthorization.js"() {
      init_parseAccount();
      init_account();
      init_isAddressEqual();
      init_getAction();
      init_getChainId();
      init_getTransactionCount();
    }
  });

  // node_modules/viem/_esm/actions/wallet/requestAddresses.js
  async function requestAddresses(client) {
    const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
    return addresses.map((address) => getAddress(address));
  }
  var init_requestAddresses = __esm({
    "node_modules/viem/_esm/actions/wallet/requestAddresses.js"() {
      init_getAddress();
    }
  });

  // node_modules/viem/_esm/actions/wallet/requestPermissions.js
  async function requestPermissions(client, permissions) {
    return client.request({
      method: "wallet_requestPermissions",
      params: [permissions]
    }, { retryCount: 0 });
  }
  var init_requestPermissions = __esm({
    "node_modules/viem/_esm/actions/wallet/requestPermissions.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/showCallsStatus.js
  async function showCallsStatus(client, parameters) {
    const { id } = parameters;
    await client.request({
      method: "wallet_showCallsStatus",
      params: [id]
    });
    return;
  }
  var init_showCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/showCallsStatus.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/signAuthorization.js
  async function signAuthorization(client, parameters) {
    const { account: account_ = client.account } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/eip7702/signAuthorization"
      });
    const account = parseAccount(account_);
    if (!account.signAuthorization)
      throw new AccountTypeNotSupportedError({
        docsPath: "/docs/eip7702/signAuthorization",
        metaMessages: [
          "The `signAuthorization` Action does not support JSON-RPC Accounts."
        ],
        type: account.type
      });
    const authorization = await prepareAuthorization(client, parameters);
    return account.signAuthorization(authorization);
  }
  var init_signAuthorization = __esm({
    "node_modules/viem/_esm/actions/wallet/signAuthorization.js"() {
      init_parseAccount();
      init_account();
      init_prepareAuthorization();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signMessage.js
  async function signMessage2(client, { account: account_ = client.account, message }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signMessage"
      });
    const account = parseAccount(account_);
    if (account.signMessage)
      return account.signMessage({ message });
    const message_ = (() => {
      if (typeof message === "string")
        return stringToHex(message);
      if (message.raw instanceof Uint8Array)
        return toHex2(message.raw);
      return message.raw;
    })();
    return client.request({
      method: "personal_sign",
      params: [message_, account.address]
    }, { retryCount: 0 });
  }
  var init_signMessage = __esm({
    "node_modules/viem/_esm/actions/wallet/signMessage.js"() {
      init_parseAccount();
      init_account();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signTransaction.js
  async function signTransaction2(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTransaction"
      });
    const account = parseAccount(account_);
    assertRequest({
      account,
      ...parameters
    });
    const chainId = await getAction(client, getChainId, "getChainId")({});
    if (chain !== null)
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    const formatters = chain?.formatters || client.chain?.formatters;
    const format = formatters?.transactionRequest?.format || formatTransactionRequest;
    if (account.signTransaction)
      return account.signTransaction({
        ...transaction,
        chainId
      }, { serializer: client.chain?.serializers?.transaction });
    return await client.request({
      method: "eth_signTransaction",
      params: [
        {
          ...format(transaction),
          chainId: numberToHex(chainId),
          from: account.address
        }
      ]
    }, { retryCount: 0 });
  }
  var init_signTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/signTransaction.js"() {
      init_parseAccount();
      init_account();
      init_assertCurrentChain();
      init_toHex();
      init_transactionRequest();
      init_getAction();
      init_assertRequest();
      init_getChainId();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signTypedData.js
  async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, message, primaryType } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTypedData"
      });
    const account = parseAccount(account_);
    const types = {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
      ...parameters.types
    };
    validateTypedData({ domain, message, primaryType, types });
    if (account.signTypedData)
      return account.signTypedData({ domain, message, primaryType, types });
    const typedData = serializeTypedData({ domain, message, primaryType, types });
    return client.request({
      method: "eth_signTypedData_v4",
      params: [account.address, typedData]
    }, { retryCount: 0 });
  }
  var init_signTypedData = __esm({
    "node_modules/viem/_esm/actions/wallet/signTypedData.js"() {
      init_parseAccount();
      init_account();
      init_typedData2();
    }
  });

  // node_modules/viem/_esm/actions/wallet/switchChain.js
  async function switchChain(client, { id }) {
    await client.request({
      method: "wallet_switchEthereumChain",
      params: [
        {
          chainId: numberToHex(id)
        }
      ]
    }, { retryCount: 0 });
  }
  var init_switchChain = __esm({
    "node_modules/viem/_esm/actions/wallet/switchChain.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/watchAsset.js
  async function watchAsset(client, params) {
    const added = await client.request({
      method: "wallet_watchAsset",
      params
    }, { retryCount: 0 });
    return added;
  }
  var init_watchAsset = __esm({
    "node_modules/viem/_esm/actions/wallet/watchAsset.js"() {
    }
  });

  // node_modules/viem/_esm/clients/decorators/wallet.js
  function walletActions(client) {
    return {
      addChain: (args) => addChain(client, args),
      deployContract: (args) => deployContract(client, args),
      getAddresses: () => getAddresses(client),
      getCallsStatus: (args) => getCallsStatus(client, args),
      getCapabilities: (args) => getCapabilities(client, args),
      getChainId: () => getChainId(client),
      getPermissions: () => getPermissions(client),
      prepareAuthorization: (args) => prepareAuthorization(client, args),
      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
      requestAddresses: () => requestAddresses(client),
      requestPermissions: (args) => requestPermissions(client, args),
      sendCalls: (args) => sendCalls(client, args),
      sendRawTransaction: (args) => sendRawTransaction(client, args),
      sendTransaction: (args) => sendTransaction(client, args),
      showCallsStatus: (args) => showCallsStatus(client, args),
      signAuthorization: (args) => signAuthorization(client, args),
      signMessage: (args) => signMessage2(client, args),
      signTransaction: (args) => signTransaction2(client, args),
      signTypedData: (args) => signTypedData(client, args),
      switchChain: (args) => switchChain(client, args),
      waitForCallsStatus: (args) => waitForCallsStatus(client, args),
      watchAsset: (args) => watchAsset(client, args),
      writeContract: (args) => writeContract(client, args)
    };
  }
  var init_wallet = __esm({
    "node_modules/viem/_esm/clients/decorators/wallet.js"() {
      init_getChainId();
      init_addChain();
      init_deployContract();
      init_getAddresses();
      init_getCallsStatus();
      init_getCapabilities();
      init_getPermissions();
      init_prepareAuthorization();
      init_prepareTransactionRequest();
      init_requestAddresses();
      init_requestPermissions();
      init_sendCalls();
      init_sendRawTransaction();
      init_sendTransaction();
      init_showCallsStatus();
      init_signAuthorization();
      init_signMessage();
      init_signTransaction();
      init_signTypedData();
      init_switchChain();
      init_waitForCallsStatus();
      init_watchAsset();
      init_writeContract();
    }
  });

  // node_modules/viem/_esm/clients/createWalletClient.js
  function createWalletClient(parameters) {
    const { key = "wallet", name = "Wallet Client", transport } = parameters;
    const client = createClient({
      ...parameters,
      key,
      name,
      transport,
      type: "walletClient"
    });
    return client.extend(walletActions);
  }
  var init_createWalletClient = __esm({
    "node_modules/viem/_esm/clients/createWalletClient.js"() {
      init_createClient();
      init_wallet();
    }
  });

  // node_modules/viem/_esm/clients/transports/webSocket.js
  function webSocket(url, config2 = {}) {
    const { keepAlive, key = "webSocket", methods, name = "WebSocket JSON-RPC", reconnect, retryDelay } = config2;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
      const wsRpcClientOpts = { keepAlive, reconnect };
      if (!url_)
        throw new UrlRequiredError();
      return createTransport({
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts);
          const { error, result } = await rpcClient.requestAsync({
            body,
            timeout
          });
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "webSocket"
      }, {
        getSocket() {
          return getSocket(url_);
        },
        getRpcClient() {
          return getWebSocketRpcClient(url_, wsRpcClientOpts);
        },
        async subscribe({ params, onData, onError }) {
          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts);
          const { result: subscriptionId } = await new Promise((resolve, reject) => rpcClient.request({
            body: {
              method: "eth_subscribe",
              params
            },
            onError(error) {
              reject(error);
              onError?.(error);
              return;
            },
            onResponse(response) {
              if (response.error) {
                reject(response.error);
                onError?.(response.error);
                return;
              }
              if (typeof response.id === "number") {
                resolve(response);
                return;
              }
              if (response.method !== "eth_subscription")
                return;
              onData(response.params);
            }
          }));
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise((resolve) => rpcClient.request({
                body: {
                  method: "eth_unsubscribe",
                  params: [subscriptionId]
                },
                onResponse: resolve
              }));
            }
          };
        }
      });
    };
  }
  var init_webSocket2 = __esm({
    "node_modules/viem/_esm/clients/transports/webSocket.js"() {
      init_request();
      init_transport();
      init_compat();
      init_webSocket();
      init_createTransport();
    }
  });

  // node_modules/viem/_esm/types/eip1193.js
  var ProviderRpcError2;
  var init_eip1193 = __esm({
    "node_modules/viem/_esm/types/eip1193.js"() {
      ProviderRpcError2 = class extends Error {
        constructor(code, message) {
          super(message);
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = code;
          this.details = message;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeDeployData.js
  function decodeDeployData(parameters) {
    const { abi: abi2, bytecode, data } = parameters;
    if (data === bytecode)
      return { bytecode };
    const description = abi2.find((x) => "type" in x && x.type === "constructor");
    if (!description)
      throw new AbiConstructorNotFoundError({ docsPath: docsPath8 });
    if (!("inputs" in description))
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath8 });
    if (!description.inputs || description.inputs.length === 0)
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath8 });
    const args = decodeAbiParameters(description.inputs, `0x${data.replace(bytecode, "")}`);
    return { args, bytecode };
  }
  var docsPath8;
  var init_decodeDeployData = __esm({
    "node_modules/viem/_esm/utils/abi/decodeDeployData.js"() {
      init_abi();
      init_decodeAbiParameters();
      docsPath8 = "/docs/contract/decodeDeployData";
    }
  });

  // node_modules/viem/_esm/utils/signature/compactSignatureToSignature.js
  function compactSignatureToSignature({ r, yParityAndS }) {
    const yParityAndS_bytes = hexToBytes3(yParityAndS);
    const yParity = yParityAndS_bytes[0] & 128 ? 1 : 0;
    const s = yParityAndS_bytes;
    if (yParity === 1)
      s[0] &= 127;
    return { r, s: bytesToHex3(s), yParity };
  }
  var init_compactSignatureToSignature = __esm({
    "node_modules/viem/_esm/utils/signature/compactSignatureToSignature.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/parseCompactSignature.js
  function parseCompactSignature(signatureHex) {
    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    return {
      r: numberToHex(r, { size: 32 }),
      yParityAndS: numberToHex(s, { size: 32 })
    };
  }
  var init_parseCompactSignature = __esm({
    "node_modules/viem/_esm/utils/signature/parseCompactSignature.js"() {
      init_secp256k1();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/parseSignature.js
  function parseSignature2(signatureHex) {
    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
    const [v, yParity] = (() => {
      if (yParityOrV === 0 || yParityOrV === 1)
        return [void 0, yParityOrV];
      if (yParityOrV === 27)
        return [BigInt(yParityOrV), 0];
      if (yParityOrV === 28)
        return [BigInt(yParityOrV), 1];
      throw new Error("Invalid yParityOrV value");
    })();
    if (typeof v !== "undefined")
      return {
        r: numberToHex(r, { size: 32 }),
        s: numberToHex(s, { size: 32 }),
        v,
        yParity
      };
    return {
      r: numberToHex(r, { size: 32 }),
      s: numberToHex(s, { size: 32 }),
      yParity
    };
  }
  var init_parseSignature = __esm({
    "node_modules/viem/_esm/utils/signature/parseSignature.js"() {
      init_secp256k1();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverTransactionAddress.js
  async function recoverTransactionAddress(parameters) {
    const { serializedTransaction, signature: signature_ } = parameters;
    const transaction = parseTransaction(serializedTransaction);
    const signature = signature_ ?? {
      r: transaction.r,
      s: transaction.s,
      v: transaction.v,
      yParity: transaction.yParity
    };
    const serialized = serializeTransaction({
      ...transaction,
      r: void 0,
      s: void 0,
      v: void 0,
      yParity: void 0,
      sidecars: void 0
    });
    return await recoverAddress({
      hash: keccak256(serialized),
      signature
    });
  }
  var init_recoverTransactionAddress = __esm({
    "node_modules/viem/_esm/utils/signature/recoverTransactionAddress.js"() {
      init_keccak256();
      init_parseTransaction();
      init_serializeTransaction();
      init_recoverAddress();
    }
  });

  // node_modules/viem/_esm/utils/signature/signatureToCompactSignature.js
  function signatureToCompactSignature(signature) {
    const { r, s, v, yParity } = signature;
    const yParity_ = Number(yParity ?? v - 27n);
    let yParityAndS = s;
    if (yParity_ === 1) {
      const bytes = hexToBytes3(s);
      bytes[0] |= 128;
      yParityAndS = bytesToHex3(bytes);
    }
    return { r, yParityAndS };
  }
  var init_signatureToCompactSignature = __esm({
    "node_modules/viem/_esm/utils/signature/signatureToCompactSignature.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/serializeCompactSignature.js
  function serializeCompactSignature({ r, yParityAndS }) {
    return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(yParityAndS)).toCompactHex()}`;
  }
  var init_serializeCompactSignature = __esm({
    "node_modules/viem/_esm/utils/signature/serializeCompactSignature.js"() {
      init_secp256k1();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/sidecarsToVersionedHashes.js
  function sidecarsToVersionedHashes(parameters) {
    const { sidecars, version: version4 } = parameters;
    const to = parameters.to ?? (typeof sidecars[0].blob === "string" ? "hex" : "bytes");
    const hashes = [];
    for (const { commitment } of sidecars) {
      hashes.push(commitmentToVersionedHash({
        commitment,
        to,
        version: version4
      }));
    }
    return hashes;
  }
  var init_sidecarsToVersionedHashes = __esm({
    "node_modules/viem/_esm/utils/blob/sidecarsToVersionedHashes.js"() {
      init_commitmentToVersionedHash();
    }
  });

  // node_modules/viem/_esm/utils/blob/fromBlobs.js
  function fromBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes3(x)) : parameters.blobs;
    const length = blobs.reduce((length2, blob) => length2 + blob.length, 0);
    const data = createCursor(new Uint8Array(length));
    let active = true;
    for (const blob of blobs) {
      const cursor = createCursor(blob);
      while (active && cursor.position < blob.length) {
        cursor.incrementPosition(1);
        let consume = 31;
        if (blob.length - cursor.position < 31)
          consume = blob.length - cursor.position;
        for (const _ in Array.from({ length: consume })) {
          const byte = cursor.readByte();
          const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
          if (isTerminator) {
            active = false;
            break;
          }
          data.pushByte(byte);
        }
      }
    }
    const trimmedData = data.bytes.slice(0, data.position);
    return to === "hex" ? bytesToHex3(trimmedData) : trimmedData;
  }
  var init_fromBlobs = __esm({
    "node_modules/viem/_esm/utils/blob/fromBlobs.js"() {
      init_cursor2();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/kzg/defineKzg.js
  function defineKzg({ blobToKzgCommitment, computeBlobKzgProof }) {
    return {
      blobToKzgCommitment,
      computeBlobKzgProof
    };
  }
  var init_defineKzg = __esm({
    "node_modules/viem/_esm/utils/kzg/defineKzg.js"() {
    }
  });

  // node_modules/viem/_esm/utils/kzg/setupKzg.js
  function setupKzg(parameters, path) {
    try {
      parameters.loadTrustedSetup(path);
    } catch (e) {
      const error = e;
      if (!error.message.includes("trusted setup is already loaded"))
        throw error;
    }
    return defineKzg(parameters);
  }
  var init_setupKzg = __esm({
    "node_modules/viem/_esm/utils/kzg/setupKzg.js"() {
      init_defineKzg();
    }
  });

  // node_modules/viem/_esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    AbiConstructorNotFoundError: () => AbiConstructorNotFoundError,
    AbiConstructorParamsNotFoundError: () => AbiConstructorParamsNotFoundError,
    AbiDecodingDataSizeInvalidError: () => AbiDecodingDataSizeInvalidError,
    AbiDecodingDataSizeTooSmallError: () => AbiDecodingDataSizeTooSmallError,
    AbiDecodingZeroDataError: () => AbiDecodingZeroDataError,
    AbiEncodingArrayLengthMismatchError: () => AbiEncodingArrayLengthMismatchError,
    AbiEncodingBytesSizeMismatchError: () => AbiEncodingBytesSizeMismatchError,
    AbiEncodingLengthMismatchError: () => AbiEncodingLengthMismatchError,
    AbiErrorInputsNotFoundError: () => AbiErrorInputsNotFoundError,
    AbiErrorNotFoundError: () => AbiErrorNotFoundError,
    AbiErrorSignatureNotFoundError: () => AbiErrorSignatureNotFoundError,
    AbiEventNotFoundError: () => AbiEventNotFoundError,
    AbiEventSignatureEmptyTopicsError: () => AbiEventSignatureEmptyTopicsError,
    AbiEventSignatureNotFoundError: () => AbiEventSignatureNotFoundError,
    AbiFunctionNotFoundError: () => AbiFunctionNotFoundError,
    AbiFunctionOutputsNotFoundError: () => AbiFunctionOutputsNotFoundError,
    AbiFunctionSignatureNotFoundError: () => AbiFunctionSignatureNotFoundError,
    AccountStateConflictError: () => AccountStateConflictError,
    AtomicReadyWalletRejectedUpgradeError: () => AtomicReadyWalletRejectedUpgradeError,
    AtomicityNotSupportedError: () => AtomicityNotSupportedError,
    BaseError: () => BaseError2,
    BaseFeeScalarError: () => BaseFeeScalarError,
    BlockNotFoundError: () => BlockNotFoundError,
    BundleTooLargeError: () => BundleTooLargeError,
    BytesSizeMismatchError: () => BytesSizeMismatchError,
    CallExecutionError: () => CallExecutionError,
    ChainDisconnectedError: () => ChainDisconnectedError,
    ChainDoesNotSupportContract: () => ChainDoesNotSupportContract,
    ChainMismatchError: () => ChainMismatchError,
    ChainNotFoundError: () => ChainNotFoundError,
    CircularReferenceError: () => CircularReferenceError,
    ClientChainNotConfiguredError: () => ClientChainNotConfiguredError,
    ContractFunctionExecutionError: () => ContractFunctionExecutionError,
    ContractFunctionRevertedError: () => ContractFunctionRevertedError,
    ContractFunctionZeroDataError: () => ContractFunctionZeroDataError,
    CounterfactualDeploymentFailedError: () => CounterfactualDeploymentFailedError,
    DecodeLogDataMismatch: () => DecodeLogDataMismatch,
    DecodeLogTopicsMismatch: () => DecodeLogTopicsMismatch,
    DuplicateIdError: () => DuplicateIdError,
    EIP1193ProviderRpcError: () => ProviderRpcError2,
    Eip1559FeesNotSupportedError: () => Eip1559FeesNotSupportedError,
    EnsAvatarInvalidNftUriError: () => EnsAvatarInvalidNftUriError,
    EnsAvatarUnsupportedNamespaceError: () => EnsAvatarUnsupportedNamespaceError,
    EnsAvatarUriResolutionError: () => EnsAvatarUriResolutionError,
    EstimateGasExecutionError: () => EstimateGasExecutionError,
    ExecutionRevertedError: () => ExecutionRevertedError,
    FeeCapTooHighError: () => FeeCapTooHighError,
    FeeCapTooLowError: () => FeeCapTooLowError,
    FeeConflictError: () => FeeConflictError,
    FilterTypeNotSupportedError: () => FilterTypeNotSupportedError,
    HttpRequestError: () => HttpRequestError,
    InsufficientFundsError: () => InsufficientFundsError,
    IntegerOutOfRangeError: () => IntegerOutOfRangeError,
    InternalRpcError: () => InternalRpcError,
    IntrinsicGasTooHighError: () => IntrinsicGasTooHighError,
    IntrinsicGasTooLowError: () => IntrinsicGasTooLowError,
    InvalidAbiDecodingTypeError: () => InvalidAbiDecodingTypeError,
    InvalidAbiEncodingTypeError: () => InvalidAbiEncodingTypeError,
    InvalidAbiItemError: () => InvalidAbiItemError,
    InvalidAbiParameterError: () => InvalidAbiParameterError,
    InvalidAbiParametersError: () => InvalidAbiParametersError,
    InvalidAbiTypeParameterError: () => InvalidAbiTypeParameterError,
    InvalidAddressError: () => InvalidAddressError,
    InvalidArrayError: () => InvalidArrayError,
    InvalidBytesBooleanError: () => InvalidBytesBooleanError,
    InvalidChainIdError: () => InvalidChainIdError,
    InvalidDecimalNumberError: () => InvalidDecimalNumberError,
    InvalidDefinitionTypeError: () => InvalidDefinitionTypeError,
    InvalidDomainError: () => InvalidDomainError,
    InvalidFunctionModifierError: () => InvalidFunctionModifierError,
    InvalidHexBooleanError: () => InvalidHexBooleanError,
    InvalidHexValueError: () => InvalidHexValueError,
    InvalidInputRpcError: () => InvalidInputRpcError,
    InvalidLegacyVError: () => InvalidLegacyVError,
    InvalidModifierError: () => InvalidModifierError,
    InvalidParameterError: () => InvalidParameterError,
    InvalidParamsRpcError: () => InvalidParamsRpcError,
    InvalidParenthesisError: () => InvalidParenthesisError,
    InvalidPrimaryTypeError: () => InvalidPrimaryTypeError,
    InvalidRequestRpcError: () => InvalidRequestRpcError,
    InvalidSerializableTransactionError: () => InvalidSerializableTransactionError,
    InvalidSerializedTransactionError: () => InvalidSerializedTransactionError,
    InvalidSerializedTransactionTypeError: () => InvalidSerializedTransactionTypeError,
    InvalidSignatureError: () => InvalidSignatureError,
    InvalidStorageKeySizeError: () => InvalidStorageKeySizeError,
    InvalidStructSignatureError: () => InvalidStructSignatureError,
    InvalidStructTypeError: () => InvalidStructTypeError,
    JsonRpcVersionUnsupportedError: () => JsonRpcVersionUnsupportedError,
    LimitExceededRpcError: () => LimitExceededRpcError,
    MaxFeePerGasTooLowError: () => MaxFeePerGasTooLowError,
    MethodNotFoundRpcError: () => MethodNotFoundRpcError,
    MethodNotSupportedRpcError: () => MethodNotSupportedRpcError,
    NonceMaxValueError: () => NonceMaxValueError,
    NonceTooHighError: () => NonceTooHighError,
    NonceTooLowError: () => NonceTooLowError,
    ParseRpcError: () => ParseRpcError,
    ProviderDisconnectedError: () => ProviderDisconnectedError,
    ProviderRpcError: () => ProviderRpcError,
    RawContractError: () => RawContractError,
    ResourceNotFoundRpcError: () => ResourceNotFoundRpcError,
    ResourceUnavailableRpcError: () => ResourceUnavailableRpcError,
    RpcError: () => RpcError,
    RpcRequestError: () => RpcRequestError,
    SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError,
    SizeOverflowError: () => SizeOverflowError,
    SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError,
    SocketClosedError: () => SocketClosedError,
    SolidityProtectedKeywordError: () => SolidityProtectedKeywordError,
    StateAssignmentConflictError: () => StateAssignmentConflictError,
    SwitchChainError: () => SwitchChainError,
    TimeoutError: () => TimeoutError,
    TipAboveFeeCapError: () => TipAboveFeeCapError,
    TransactionExecutionError: () => TransactionExecutionError,
    TransactionNotFoundError: () => TransactionNotFoundError,
    TransactionReceiptNotFoundError: () => TransactionReceiptNotFoundError,
    TransactionRejectedRpcError: () => TransactionRejectedRpcError,
    TransactionTypeNotSupportedError: () => TransactionTypeNotSupportedError,
    UnauthorizedProviderError: () => UnauthorizedProviderError,
    UnknownBundleIdError: () => UnknownBundleIdError,
    UnknownNodeError: () => UnknownNodeError,
    UnknownRpcError: () => UnknownRpcError,
    UnknownSignatureError: () => UnknownSignatureError,
    UnknownTypeError: () => UnknownTypeError,
    UnsupportedChainIdError: () => UnsupportedChainIdError,
    UnsupportedNonOptionalCapabilityError: () => UnsupportedNonOptionalCapabilityError,
    UnsupportedPackedAbiType: () => UnsupportedPackedAbiType,
    UnsupportedProviderMethodError: () => UnsupportedProviderMethodError,
    UrlRequiredError: () => UrlRequiredError,
    UserRejectedRequestError: () => UserRejectedRequestError,
    WaitForCallsStatusTimeoutError: () => WaitForCallsStatusTimeoutError,
    WaitForTransactionReceiptTimeoutError: () => WaitForTransactionReceiptTimeoutError,
    WebSocketRequestError: () => WebSocketRequestError,
    assertCurrentChain: () => assertCurrentChain,
    assertRequest: () => assertRequest,
    assertTransactionEIP1559: () => assertTransactionEIP1559,
    assertTransactionEIP2930: () => assertTransactionEIP2930,
    assertTransactionLegacy: () => assertTransactionLegacy,
    blobsToCommitments: () => blobsToCommitments,
    blobsToProofs: () => blobsToProofs,
    boolToBytes: () => boolToBytes,
    boolToHex: () => boolToHex,
    bytesToBigInt: () => bytesToBigInt,
    bytesToBool: () => bytesToBool,
    bytesToHex: () => bytesToHex3,
    bytesToNumber: () => bytesToNumber,
    bytesToRlp: () => bytesToRlp,
    bytesToString: () => bytesToString,
    ccipFetch: () => ccipRequest,
    ccipRequest: () => ccipRequest,
    checksumAddress: () => checksumAddress,
    commitmentToVersionedHash: () => commitmentToVersionedHash,
    commitmentsToVersionedHashes: () => commitmentsToVersionedHashes,
    compactSignatureToHex: () => serializeCompactSignature,
    compactSignatureToSignature: () => compactSignatureToSignature,
    concat: () => concat,
    concatBytes: () => concatBytes3,
    concatHex: () => concatHex,
    createClient: () => createClient,
    createNonceManager: () => createNonceManager,
    createPublicClient: () => createPublicClient,
    createTestClient: () => createTestClient,
    createTransport: () => createTransport,
    createWalletClient: () => createWalletClient,
    custom: () => custom,
    decodeAbiParameters: () => decodeAbiParameters,
    decodeDeployData: () => decodeDeployData,
    decodeErrorResult: () => decodeErrorResult,
    decodeEventLog: () => decodeEventLog,
    decodeFunctionData: () => decodeFunctionData,
    decodeFunctionResult: () => decodeFunctionResult,
    defineBlock: () => defineBlock,
    defineChain: () => defineChain,
    defineKzg: () => defineKzg,
    defineTransaction: () => defineTransaction,
    defineTransactionReceipt: () => defineTransactionReceipt,
    defineTransactionRequest: () => defineTransactionRequest,
    deploylessCallViaBytecodeBytecode: () => deploylessCallViaBytecodeBytecode,
    deploylessCallViaFactoryBytecode: () => deploylessCallViaFactoryBytecode,
    domainSeparator: () => domainSeparator,
    encodeAbiParameters: () => encodeAbiParameters,
    encodeDeployData: () => encodeDeployData,
    encodeErrorResult: () => encodeErrorResult,
    encodeEventTopics: () => encodeEventTopics,
    encodeFunctionData: () => encodeFunctionData,
    encodeFunctionResult: () => encodeFunctionResult,
    encodePacked: () => encodePacked,
    erc1155Abi: () => erc1155Abi,
    erc20Abi: () => erc20Abi,
    erc20Abi_bytes32: () => erc20Abi_bytes32,
    erc4626Abi: () => erc4626Abi,
    erc721Abi: () => erc721Abi,
    ethAddress: () => ethAddress,
    etherUnits: () => etherUnits,
    extractChain: () => extractChain,
    fallback: () => fallback,
    formatBlock: () => formatBlock,
    formatEther: () => formatEther,
    formatGwei: () => formatGwei,
    formatLog: () => formatLog,
    formatTransaction: () => formatTransaction,
    formatTransactionReceipt: () => formatTransactionReceipt,
    formatTransactionRequest: () => formatTransactionRequest,
    formatUnits: () => formatUnits,
    fromBlobs: () => fromBlobs,
    fromBytes: () => fromBytes,
    fromHex: () => fromHex2,
    fromRlp: () => fromRlp,
    getAbiItem: () => getAbiItem,
    getAddress: () => getAddress,
    getChainContractAddress: () => getChainContractAddress,
    getContract: () => getContract,
    getContractAddress: () => getContractAddress2,
    getContractError: () => getContractError,
    getCreate2Address: () => getCreate2Address,
    getCreateAddress: () => getCreateAddress,
    getEventSelector: () => toEventSelector,
    getEventSignature: () => toSignature,
    getFunctionSelector: () => toFunctionSelector,
    getFunctionSignature: () => toSignature,
    getSerializedTransactionType: () => getSerializedTransactionType,
    getTransactionType: () => getTransactionType,
    getTypesForEIP712Domain: () => getTypesForEIP712Domain,
    gweiUnits: () => gweiUnits,
    hashDomain: () => hashDomain,
    hashMessage: () => hashMessage,
    hashStruct: () => hashStruct,
    hashTypedData: () => hashTypedData,
    hexToBigInt: () => hexToBigInt,
    hexToBool: () => hexToBool,
    hexToBytes: () => hexToBytes3,
    hexToCompactSignature: () => parseCompactSignature,
    hexToNumber: () => hexToNumber2,
    hexToRlp: () => hexToRlp,
    hexToSignature: () => parseSignature2,
    hexToString: () => hexToString,
    http: () => http,
    isAddress: () => isAddress,
    isAddressEqual: () => isAddressEqual,
    isBytes: () => isBytes3,
    isErc6492Signature: () => isErc6492Signature,
    isHash: () => isHash2,
    isHex: () => isHex,
    keccak256: () => keccak256,
    labelhash: () => labelhash,
    maxInt104: () => maxInt104,
    maxInt112: () => maxInt112,
    maxInt120: () => maxInt120,
    maxInt128: () => maxInt128,
    maxInt136: () => maxInt136,
    maxInt144: () => maxInt144,
    maxInt152: () => maxInt152,
    maxInt16: () => maxInt16,
    maxInt160: () => maxInt160,
    maxInt168: () => maxInt168,
    maxInt176: () => maxInt176,
    maxInt184: () => maxInt184,
    maxInt192: () => maxInt192,
    maxInt200: () => maxInt200,
    maxInt208: () => maxInt208,
    maxInt216: () => maxInt216,
    maxInt224: () => maxInt224,
    maxInt232: () => maxInt232,
    maxInt24: () => maxInt24,
    maxInt240: () => maxInt240,
    maxInt248: () => maxInt248,
    maxInt256: () => maxInt256,
    maxInt32: () => maxInt32,
    maxInt40: () => maxInt40,
    maxInt48: () => maxInt48,
    maxInt56: () => maxInt56,
    maxInt64: () => maxInt64,
    maxInt72: () => maxInt72,
    maxInt8: () => maxInt8,
    maxInt80: () => maxInt80,
    maxInt88: () => maxInt88,
    maxInt96: () => maxInt96,
    maxUint104: () => maxUint104,
    maxUint112: () => maxUint112,
    maxUint120: () => maxUint120,
    maxUint128: () => maxUint128,
    maxUint136: () => maxUint136,
    maxUint144: () => maxUint144,
    maxUint152: () => maxUint152,
    maxUint16: () => maxUint16,
    maxUint160: () => maxUint160,
    maxUint168: () => maxUint168,
    maxUint176: () => maxUint176,
    maxUint184: () => maxUint184,
    maxUint192: () => maxUint192,
    maxUint200: () => maxUint200,
    maxUint208: () => maxUint208,
    maxUint216: () => maxUint216,
    maxUint224: () => maxUint224,
    maxUint232: () => maxUint232,
    maxUint24: () => maxUint24,
    maxUint240: () => maxUint240,
    maxUint248: () => maxUint248,
    maxUint256: () => maxUint256,
    maxUint32: () => maxUint32,
    maxUint40: () => maxUint40,
    maxUint48: () => maxUint48,
    maxUint56: () => maxUint56,
    maxUint64: () => maxUint64,
    maxUint72: () => maxUint72,
    maxUint8: () => maxUint8,
    maxUint80: () => maxUint80,
    maxUint88: () => maxUint88,
    maxUint96: () => maxUint96,
    minInt104: () => minInt104,
    minInt112: () => minInt112,
    minInt120: () => minInt120,
    minInt128: () => minInt128,
    minInt136: () => minInt136,
    minInt144: () => minInt144,
    minInt152: () => minInt152,
    minInt16: () => minInt16,
    minInt160: () => minInt160,
    minInt168: () => minInt168,
    minInt176: () => minInt176,
    minInt184: () => minInt184,
    minInt192: () => minInt192,
    minInt200: () => minInt200,
    minInt208: () => minInt208,
    minInt216: () => minInt216,
    minInt224: () => minInt224,
    minInt232: () => minInt232,
    minInt24: () => minInt24,
    minInt240: () => minInt240,
    minInt248: () => minInt248,
    minInt256: () => minInt256,
    minInt32: () => minInt32,
    minInt40: () => minInt40,
    minInt48: () => minInt48,
    minInt56: () => minInt56,
    minInt64: () => minInt64,
    minInt72: () => minInt72,
    minInt8: () => minInt8,
    minInt80: () => minInt80,
    minInt88: () => minInt88,
    minInt96: () => minInt96,
    multicall3Abi: () => multicall3Abi,
    namehash: () => namehash,
    nonceManager: () => nonceManager,
    numberToBytes: () => numberToBytes,
    numberToHex: () => numberToHex,
    offchainLookup: () => offchainLookup,
    offchainLookupAbiItem: () => offchainLookupAbiItem,
    offchainLookupSignature: () => offchainLookupSignature,
    pad: () => pad,
    padBytes: () => padBytes,
    padHex: () => padHex,
    parseAbi: () => parseAbi,
    parseAbiItem: () => parseAbiItem,
    parseAbiParameter: () => parseAbiParameter2,
    parseAbiParameters: () => parseAbiParameters,
    parseCompactSignature: () => parseCompactSignature,
    parseErc6492Signature: () => parseErc6492Signature,
    parseEther: () => parseEther,
    parseEventLogs: () => parseEventLogs,
    parseGwei: () => parseGwei,
    parseSignature: () => parseSignature2,
    parseTransaction: () => parseTransaction,
    parseUnits: () => parseUnits,
    prepareEncodeFunctionData: () => prepareEncodeFunctionData,
    presignMessagePrefix: () => presignMessagePrefix,
    publicActions: () => publicActions,
    recoverAddress: () => recoverAddress,
    recoverMessageAddress: () => recoverMessageAddress,
    recoverPublicKey: () => recoverPublicKey,
    recoverTransactionAddress: () => recoverTransactionAddress,
    recoverTypedDataAddress: () => recoverTypedDataAddress,
    ripemd160: () => ripemd1603,
    rpcSchema: () => rpcSchema,
    rpcTransactionType: () => rpcTransactionType,
    serializeAccessList: () => serializeAccessList,
    serializeCompactSignature: () => serializeCompactSignature,
    serializeErc6492Signature: () => serializeErc6492Signature,
    serializeSignature: () => serializeSignature,
    serializeTransaction: () => serializeTransaction,
    serializeTypedData: () => serializeTypedData,
    setErrorConfig: () => setErrorConfig,
    setupKzg: () => setupKzg,
    sha256: () => sha2563,
    shouldThrow: () => shouldThrow,
    sidecarsToVersionedHashes: () => sidecarsToVersionedHashes,
    signatureToCompactSignature: () => signatureToCompactSignature,
    signatureToHex: () => serializeSignature,
    size: () => size,
    slice: () => slice,
    sliceBytes: () => sliceBytes,
    sliceHex: () => sliceHex,
    stringToBytes: () => stringToBytes,
    stringToHex: () => stringToHex,
    stringify: () => stringify,
    testActions: () => testActions,
    toBlobSidecars: () => toBlobSidecars,
    toBlobs: () => toBlobs,
    toBytes: () => toBytes2,
    toEventHash: () => toSignatureHash,
    toEventSelector: () => toEventSelector,
    toEventSignature: () => toSignature,
    toFunctionHash: () => toSignatureHash,
    toFunctionSelector: () => toFunctionSelector,
    toFunctionSignature: () => toSignature,
    toHex: () => toHex2,
    toPrefixedMessage: () => toPrefixedMessage,
    toRlp: () => toRlp,
    transactionType: () => transactionType,
    trim: () => trim,
    universalSignatureValidatorAbi: () => universalSignatureValidatorAbi,
    universalSignatureValidatorByteCode: () => universalSignatureValidatorByteCode,
    validateTypedData: () => validateTypedData,
    verifyHash: () => verifyHash,
    verifyMessage: () => verifyMessage,
    verifyTypedData: () => verifyTypedData,
    walletActions: () => walletActions,
    webSocket: () => webSocket,
    weiUnits: () => weiUnits,
    withCache: () => withCache,
    withRetry: () => withRetry,
    withTimeout: () => withTimeout,
    zeroAddress: () => zeroAddress,
    zeroHash: () => zeroHash
  });
  var init_esm = __esm({
    "node_modules/viem/_esm/index.js"() {
      init_exports();
      init_getContract();
      init_waitForCallsStatus();
      init_createClient();
      init_custom();
      init_fallback();
      init_http2();
      init_createPublicClient();
      init_createTestClient();
      init_public();
      init_test();
      init_wallet();
      init_createTransport();
      init_createWalletClient();
      init_webSocket2();
      init_abis();
      init_address2();
      init_contracts();
      init_unit();
      init_number();
      init_bytes3();
      init_strings();
      init_abi();
      init_base2();
      init_block();
      init_contract();
      init_fee();
      init_rpc();
      init_chain();
      init_encoding();
      init_ens();
      init_unit2();
      init_estimateGas();
      init_node();
      init_log();
      init_request();
      init_address();
      init_transaction();
      init_data();
      init_transport();
      init_stateOverride();
      init_typedData();
      init_eip1193();
      init_labelhash();
      init_namehash();
      init_block2();
      init_log2();
      init_decodeAbiParameters();
      init_decodeDeployData();
      init_decodeErrorResult();
      init_decodeEventLog();
      init_decodeFunctionData();
      init_decodeFunctionResult();
      init_encodeAbiParameters();
      init_encodeDeployData();
      init_encodeErrorResult();
      init_encodeEventTopics();
      init_encodeFunctionData();
      init_prepareEncodeFunctionData();
      init_encodeFunctionResult();
      init_parseEventLogs();
      init_transaction2();
      init_transactionReceipt();
      init_transactionRequest();
      init_getAbiItem();
      init_getContractAddress();
      init_getSerializedTransactionType();
      init_getTransactionType();
      init_hashTypedData();
      init_compactSignatureToSignature();
      init_parseCompactSignature();
      init_parseSignature();
      init_recoverAddress();
      init_recoverMessageAddress();
      init_recoverPublicKey();
      init_recoverTransactionAddress();
      init_recoverTypedDataAddress();
      init_signatureToCompactSignature();
      init_serializeCompactSignature();
      init_serializeSignature();
      init_toRlp();
      init_verifyHash();
      init_verifyMessage();
      init_verifyTypedData();
      init_parseErc6492Signature();
      init_isErc6492Signature();
      init_serializeErc6492Signature();
      init_assertRequest();
      init_assertTransaction();
      init_toBytes();
      init_toHex();
      init_fromBytes();
      init_ccip2();
      init_blobsToCommitments();
      init_commitmentToVersionedHash();
      init_commitmentsToVersionedHashes();
      init_sidecarsToVersionedHashes();
      init_blobsToProofs();
      init_fromBlobs();
      init_toBlobSidecars();
      init_toBlobs();
      init_defineKzg();
      init_setupKzg();
      init_concat();
      init_assertCurrentChain();
      init_defineChain();
      init_extractChain();
      init_getChainContractAddress();
      init_encodePacked();
      init_withCache();
      init_withRetry();
      init_withTimeout();
      init_formatEther();
      init_formatGwei();
      init_formatUnits();
      init_fromHex();
      init_fromRlp();
      init_getAddress();
      init_getContractError();
      init_toEventSelector();
      init_toFunctionSelector();
      init_toEventSignature();
      init_toFunctionSignature();
      init_toEventHash();
      init_toFunctionHash();
      init_hashMessage();
      init_toPrefixedMessage();
      init_isAddress();
      init_isAddressEqual();
      init_isBytes();
      init_isHash();
      init_isHex();
      init_keccak256();
      init_sha2562();
      init_ripemd1602();
      init_pad();
      init_parseEther();
      init_parseGwei();
      init_parseTransaction();
      init_parseUnits();
      init_serializeAccessList();
      init_serializeTransaction();
      init_size();
      init_slice();
      init_stringify();
      init_trim();
      init_typedData2();
      init_nonceManager();
    }
  });

  // node_modules/@noble/hashes/esm/hkdf.js
  function extract2(hash2, ikm, salt) {
    ahash(hash2);
    if (salt === void 0)
      salt = new Uint8Array(hash2.outputLen);
    return hmac(hash2, toBytes(salt), toBytes(ikm));
  }
  function expand(hash2, prk, info, length = 32) {
    ahash(hash2);
    anumber(length);
    const olen = hash2.outputLen;
    if (length > 255 * olen)
      throw new Error("Length should be <= 255*HashLen");
    const blocks = Math.ceil(length / olen);
    if (info === void 0)
      info = EMPTY_BUFFER;
    const okm = new Uint8Array(blocks * olen);
    const HMAC2 = hmac.create(hash2, prk);
    const HMACTmp = HMAC2._cloneInto();
    const T = new Uint8Array(HMAC2.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, olen * counter);
      HMAC2._cloneInto(HMACTmp);
    }
    HMAC2.destroy();
    HMACTmp.destroy();
    clean(T, HKDF_COUNTER);
    return okm.slice(0, length);
  }
  var HKDF_COUNTER, EMPTY_BUFFER;
  var init_hkdf = __esm({
    "node_modules/@noble/hashes/esm/hkdf.js"() {
      init_hmac();
      init_utils2();
      HKDF_COUNTER = /* @__PURE__ */ Uint8Array.from([0]);
      EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
    }
  });

  // node_modules/@noble/ciphers/esm/utils.js
  function isBytes4(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool3(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function abytes3(b, ...lengths) {
    if (!isBytes4(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes3(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u322(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    else if (isBytes4(data))
      data = copyBytes(data);
    else
      throw new Error("Uint8Array expected, got " + typeof data);
    return data;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function setBigUint642(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  function u64Lengths(dataLength, aadLength, isLE3) {
    abool3(isLE3);
    const num2 = new Uint8Array(16);
    const view = createView2(num2);
    setBigUint642(view, 0, BigInt(aadLength), isLE3);
    setBigUint642(view, 8, BigInt(dataLength), isLE3);
    return num2;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }
  var isLE2, wrapCipher;
  var init_utils10 = __esm({
    "node_modules/@noble/ciphers/esm/utils.js"() {
      isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
        function wrappedCipher(key, ...args) {
          abytes3(key);
          if (!isLE2)
            throw new Error("Non little-endian hardware is not yet supported");
          if (params.nonceLength !== void 0) {
            const nonce = args[0];
            if (!nonce)
              throw new Error("nonce / iv required");
            if (params.varSizeNonce)
              abytes3(nonce);
            else
              abytes3(nonce, params.nonceLength);
          }
          const tagl = params.tagLength;
          if (tagl && args[1] !== void 0) {
            abytes3(args[1]);
          }
          const cipher = constructor(key, ...args);
          const checkOutput = (fnLength, output) => {
            if (output !== void 0) {
              if (fnLength !== 2)
                throw new Error("cipher output not supported");
              abytes3(output);
            }
          };
          let called = false;
          const wrCipher = {
            encrypt(data, output) {
              if (called)
                throw new Error("cannot encrypt() twice with same key + nonce");
              called = true;
              abytes3(data);
              checkOutput(cipher.encrypt.length, output);
              return cipher.encrypt(data, output);
            },
            decrypt(data, output) {
              abytes3(data);
              if (tagl && data.length < tagl)
                throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
              checkOutput(cipher.decrypt.length, output);
              return cipher.decrypt(data, output);
            }
          };
          return wrCipher;
        }
        Object.assign(wrappedCipher, params);
        return wrappedCipher;
      };
    }
  });

  // node_modules/@noble/ciphers/esm/_polyval.js
  function _toGHASHKey(k) {
    k.reverse();
    const hiBit = k[15] & 1;
    let carry = 0;
    for (let i = 0; i < k.length; i++) {
      const t = k[i];
      k[i] = t >>> 1 | carry;
      carry = (t & 1) << 7;
    }
    k[0] ^= -hiBit & 225;
    return k;
  }
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes3(msg)).digest();
    const tmp = hashCons(new Uint8Array(16), 0);
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
    return hashC;
  }
  var BLOCK_SIZE, ZEROS16, ZEROS32, POLY, mul2, swapLE2, estimateWindow, GHASH, Polyval, ghash, polyval;
  var init_polyval = __esm({
    "node_modules/@noble/ciphers/esm/_polyval.js"() {
      init_utils10();
      BLOCK_SIZE = 16;
      ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
      ZEROS32 = u322(ZEROS16);
      POLY = 225;
      mul2 = (s0, s1, s2, s3) => {
        const hiBit = s3 & 1;
        return {
          s3: s2 << 31 | s3 >>> 1,
          s2: s1 << 31 | s2 >>> 1,
          s1: s0 << 31 | s1 >>> 1,
          s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
          // reduce % poly
        };
      };
      swapLE2 = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
      estimateWindow = (bytes) => {
        if (bytes > 64 * 1024)
          return 8;
        if (bytes > 1024)
          return 4;
        return 2;
      };
      GHASH = class {
        // We select bits per window adaptively based on expectedLength
        constructor(key, expectedLength) {
          this.blockLen = BLOCK_SIZE;
          this.outputLen = BLOCK_SIZE;
          this.s0 = 0;
          this.s1 = 0;
          this.s2 = 0;
          this.s3 = 0;
          this.finished = false;
          key = toBytes3(key);
          abytes3(key, 16);
          const kView = createView2(key);
          let k0 = kView.getUint32(0, false);
          let k1 = kView.getUint32(4, false);
          let k2 = kView.getUint32(8, false);
          let k3 = kView.getUint32(12, false);
          const doubles = [];
          for (let i = 0; i < 128; i++) {
            doubles.push({ s0: swapLE2(k0), s1: swapLE2(k1), s2: swapLE2(k2), s3: swapLE2(k3) });
            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
          }
          const W2 = estimateWindow(expectedLength || 1024);
          if (![1, 2, 4, 8].includes(W2))
            throw new Error("ghash: invalid window size, expected 2, 4 or 8");
          this.W = W2;
          const bits = 128;
          const windows = bits / W2;
          const windowSize = this.windowSize = 2 ** W2;
          const items = [];
          for (let w = 0; w < windows; w++) {
            for (let byte = 0; byte < windowSize; byte++) {
              let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
              for (let j = 0; j < W2; j++) {
                const bit = byte >>> W2 - j - 1 & 1;
                if (!bit)
                  continue;
                const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W2 * w + j];
                s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
              }
              items.push({ s0, s1, s2, s3 });
            }
          }
          this.t = items;
        }
        _updateBlock(s0, s1, s2, s3) {
          s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
          const { W: W2, t, windowSize } = this;
          let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
          const mask = (1 << W2) - 1;
          let w = 0;
          for (const num2 of [s0, s1, s2, s3]) {
            for (let bytePos = 0; bytePos < 4; bytePos++) {
              const byte = num2 >>> 8 * bytePos & 255;
              for (let bitPos = 8 / W2 - 1; bitPos >= 0; bitPos--) {
                const bit = byte >>> W2 * bitPos & mask;
                const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
                o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
                w += 1;
              }
            }
          }
          this.s0 = o0;
          this.s1 = o1;
          this.s2 = o2;
          this.s3 = o3;
        }
        update(data) {
          aexists2(this);
          data = toBytes3(data);
          abytes3(data);
          const b32 = u322(data);
          const blocks = Math.floor(data.length / BLOCK_SIZE);
          const left = data.length % BLOCK_SIZE;
          for (let i = 0; i < blocks; i++) {
            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);
          }
          if (left) {
            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
            clean2(ZEROS32);
          }
          return this;
        }
        destroy() {
          const { t } = this;
          for (const elm of t) {
            elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
          }
        }
        digestInto(out) {
          aexists2(this);
          aoutput2(out, this);
          this.finished = true;
          const { s0, s1, s2, s3 } = this;
          const o32 = u322(out);
          o32[0] = s0;
          o32[1] = s1;
          o32[2] = s2;
          o32[3] = s3;
          return out;
        }
        digest() {
          const res = new Uint8Array(BLOCK_SIZE);
          this.digestInto(res);
          this.destroy();
          return res;
        }
      };
      Polyval = class extends GHASH {
        constructor(key, expectedLength) {
          key = toBytes3(key);
          abytes3(key);
          const ghKey = _toGHASHKey(copyBytes(key));
          super(ghKey, expectedLength);
          clean2(ghKey);
        }
        update(data) {
          data = toBytes3(data);
          aexists2(this);
          const b32 = u322(data);
          const left = data.length % BLOCK_SIZE;
          const blocks = Math.floor(data.length / BLOCK_SIZE);
          for (let i = 0; i < blocks; i++) {
            this._updateBlock(swapLE2(b32[i * 4 + 3]), swapLE2(b32[i * 4 + 2]), swapLE2(b32[i * 4 + 1]), swapLE2(b32[i * 4 + 0]));
          }
          if (left) {
            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
            this._updateBlock(swapLE2(ZEROS32[3]), swapLE2(ZEROS32[2]), swapLE2(ZEROS32[1]), swapLE2(ZEROS32[0]));
            clean2(ZEROS32);
          }
          return this;
        }
        digestInto(out) {
          aexists2(this);
          aoutput2(out, this);
          this.finished = true;
          const { s0, s1, s2, s3 } = this;
          const o32 = u322(out);
          o32[0] = s0;
          o32[1] = s1;
          o32[2] = s2;
          o32[3] = s3;
          return out.reverse();
        }
      };
      ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
      polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));
    }
  });

  // node_modules/@noble/ciphers/esm/aes.js
  function mul22(n) {
    return n << 1 ^ POLY2 & -(n >> 7);
  }
  function mul(a, b) {
    let res = 0;
    for (; b > 0; b >>= 1) {
      res ^= a & -(b & 1);
      a = mul22(a);
    }
    return res;
  }
  function genTtable(sbox2, fn) {
    if (sbox2.length !== 256)
      throw new Error("Wrong sbox length");
    const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
    const T1 = T0.map(rotl32_8);
    const T2 = T1.map(rotl32_8);
    const T3 = T2.map(rotl32_8);
    const T01 = new Uint32Array(256 * 256);
    const T23 = new Uint32Array(256 * 256);
    const sbox22 = new Uint16Array(256 * 256);
    for (let i = 0; i < 256; i++) {
      for (let j = 0; j < 256; j++) {
        const idx = i * 256 + j;
        T01[idx] = T0[i] ^ T1[j];
        T23[idx] = T2[i] ^ T3[j];
        sbox22[idx] = sbox2[i] << 8 | sbox2[j];
      }
    }
    return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
  }
  function expandKeyLE(key) {
    abytes3(key);
    const len = key.length;
    if (![16, 24, 32].includes(len))
      throw new Error("aes: invalid key size, should be 16, 24 or 32, got " + len);
    const { sbox2 } = tableEncoding;
    const toClean = [];
    if (!isAligned32(key))
      toClean.push(key = copyBytes(key));
    const k32 = u322(key);
    const Nk = k32.length;
    const subByte = (n) => applySbox(sbox2, n, n, n, n);
    const xk = new Uint32Array(len + 28);
    xk.set(k32);
    for (let i = Nk; i < xk.length; i++) {
      let t = xk[i - 1];
      if (i % Nk === 0)
        t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
      else if (Nk > 6 && i % Nk === 4)
        t = subByte(t);
      xk[i] = xk[i - Nk] ^ t;
    }
    clean2(...toClean);
    return xk;
  }
  function apply0123(T01, T23, s0, s1, s2, s3) {
    return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
  }
  function applySbox(sbox2, s0, s1, s2, s3) {
    return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
  }
  function encrypt(xk, s0, s1, s2, s3) {
    const { sbox2, T01, T23 } = tableEncoding;
    let k = 0;
    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
    const rounds = xk.length / 4 - 2;
    for (let i = 0; i < rounds; i++) {
      const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
      const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
      const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
      const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
      s0 = t02, s1 = t12, s2 = t22, s3 = t32;
    }
    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
    return { s0: t0, s1: t1, s2: t2, s3: t3 };
  }
  function ctr32(xk, isLE3, nonce, src, dst) {
    abytes3(nonce, BLOCK_SIZE2);
    abytes3(src);
    dst = getOutput(src.length, dst);
    const ctr = nonce;
    const c32 = u322(ctr);
    const view = createView2(ctr);
    const src32 = u322(src);
    const dst32 = u322(dst);
    const ctrPos = isLE3 ? 0 : 12;
    const srcLen = src.length;
    let ctrNum = view.getUint32(ctrPos, isLE3);
    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
    for (let i = 0; i + 4 <= src32.length; i += 4) {
      dst32[i + 0] = src32[i + 0] ^ s0;
      dst32[i + 1] = src32[i + 1] ^ s1;
      dst32[i + 2] = src32[i + 2] ^ s2;
      dst32[i + 3] = src32[i + 3] ^ s3;
      ctrNum = ctrNum + 1 >>> 0;
      view.setUint32(ctrPos, ctrNum, isLE3);
      ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      const b32 = new Uint32Array([s0, s1, s2, s3]);
      const buf = u8(b32);
      for (let i = start, pos = 0; i < srcLen; i++, pos++)
        dst[i] = src[i] ^ buf[pos];
      clean2(b32);
    }
    return dst;
  }
  function computeTag(fn, isLE3, key, data, AAD) {
    const aadLength = AAD ? AAD.length : 0;
    const h = fn.create(key, data.length + aadLength);
    if (AAD)
      h.update(AAD);
    const num2 = u64Lengths(8 * data.length, 8 * aadLength, isLE3);
    h.update(data);
    h.update(num2);
    const res = h.digest();
    clean2(num2);
    return res;
  }
  var BLOCK_SIZE2, BLOCK_SIZE32, EMPTY_BLOCK, POLY2, sbox, rotr32_8, rotl32_8, tableEncoding, xPowers, gcm;
  var init_aes = __esm({
    "node_modules/@noble/ciphers/esm/aes.js"() {
      init_polyval();
      init_utils10();
      BLOCK_SIZE2 = 16;
      BLOCK_SIZE32 = 4;
      EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE2);
      POLY2 = 283;
      sbox = /* @__PURE__ */ (() => {
        const t = new Uint8Array(256);
        for (let i = 0, x = 1; i < 256; i++, x ^= mul22(x))
          t[i] = x;
        const box = new Uint8Array(256);
        box[0] = 99;
        for (let i = 0; i < 255; i++) {
          let x = t[255 - i];
          x |= x << 8;
          box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
        }
        clean2(t);
        return box;
      })();
      rotr32_8 = (n) => n << 24 | n >>> 8;
      rotl32_8 = (n) => n << 8 | n >>> 24;
      tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
      xPowers = /* @__PURE__ */ (() => {
        const p = new Uint8Array(16);
        for (let i = 0, x = 1; i < 16; i++, x = mul22(x))
          p[i] = x;
        return p;
      })();
      gcm = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {
        if (nonce.length < 8)
          throw new Error("aes/gcm: invalid nonce length");
        const tagLength = 16;
        function _computeTag(authKey, tagMask, data) {
          const tag = computeTag(ghash, false, authKey, data, AAD);
          for (let i = 0; i < tagMask.length; i++)
            tag[i] ^= tagMask[i];
          return tag;
        }
        function deriveKeys() {
          const xk = expandKeyLE(key);
          const authKey = EMPTY_BLOCK.slice();
          const counter = EMPTY_BLOCK.slice();
          ctr32(xk, false, counter, counter, authKey);
          if (nonce.length === 12) {
            counter.set(nonce);
          } else {
            const nonceLen = EMPTY_BLOCK.slice();
            const view = createView2(nonceLen);
            setBigUint642(view, 8, BigInt(nonce.length * 8), false);
            const g = ghash.create(authKey).update(nonce).update(nonceLen);
            g.digestInto(counter);
            g.destroy();
          }
          const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
          return { xk, authKey, counter, tagMask };
        }
        return {
          encrypt(plaintext) {
            const { xk, authKey, counter, tagMask } = deriveKeys();
            const out = new Uint8Array(plaintext.length + tagLength);
            const toClean = [xk, authKey, counter, tagMask];
            if (!isAligned32(plaintext))
              toClean.push(plaintext = copyBytes(plaintext));
            ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));
            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
            toClean.push(tag);
            out.set(tag, plaintext.length);
            clean2(...toClean);
            return out;
          },
          decrypt(ciphertext) {
            const { xk, authKey, counter, tagMask } = deriveKeys();
            const toClean = [xk, authKey, tagMask, counter];
            if (!isAligned32(ciphertext))
              toClean.push(ciphertext = copyBytes(ciphertext));
            const data = ciphertext.subarray(0, -tagLength);
            const passedTag = ciphertext.subarray(-tagLength);
            const tag = _computeTag(authKey, tagMask, data);
            toClean.push(tag);
            if (!equalBytes(tag, passedTag))
              throw new Error("aes/gcm: invalid ghash tag");
            const out = ctr32(xk, false, counter, data);
            clean2(...toClean);
            return out;
          }
        };
      });
    }
  });

  // node_modules/@turnkey/crypto/dist/math.mjs
  var modSqrt2, testBit2, modPow2;
  var init_math = __esm({
    "node_modules/@turnkey/crypto/dist/math.mjs"() {
      modSqrt2 = (x, p) => {
        if (p <= BigInt(0)) {
          throw new Error("p must be positive");
        }
        const base2 = x % p;
        if (testBit2(p, 0) && testBit2(p, 1)) {
          const q = p + BigInt(1) >> BigInt(2);
          const squareRoot = modPow2(base2, q, p);
          if (squareRoot * squareRoot % p !== base2) {
            throw new Error("could not find a modular square root");
          }
          return squareRoot;
        }
        throw new Error("unsupported modulus value");
      };
      testBit2 = (n, i) => {
        const m = BigInt(1) << BigInt(i);
        return (n & m) !== BigInt(0);
      };
      modPow2 = (b, exp, p) => {
        if (exp === BigInt(0)) {
          return BigInt(1);
        }
        let result = b % p;
        const exponentBitString = exp.toString(2);
        for (let i = 1; i < exponentBitString.length; ++i) {
          result = result * result % p;
          if (exponentBitString[i] === "1") {
            result = result * b % p;
          }
        }
        return result;
      };
    }
  });

  // node_modules/@turnkey/crypto/dist/constants.mjs
  var SUITE_ID_1, SUITE_ID_2, HPKE_VERSION, LABEL_SECRET, LABEL_EAE_PRK, LABEL_SHARED_SECRET, AES_KEY_INFO, IV_INFO, PRODUCTION_SIGNER_PUBLIC_KEY, PRODUCTION_NOTARIZER_PUBLIC_KEY;
  var init_constants2 = __esm({
    "node_modules/@turnkey/crypto/dist/constants.mjs"() {
      SUITE_ID_1 = new Uint8Array([75, 69, 77, 0, 16]);
      SUITE_ID_2 = new Uint8Array([72, 80, 75, 69, 0, 16, 0, 1, 0, 2]);
      HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);
      LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);
      LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);
      LABEL_SHARED_SECRET = new Uint8Array([
        115,
        104,
        97,
        114,
        101,
        100,
        95,
        115,
        101,
        99,
        114,
        101,
        116
      ]);
      AES_KEY_INFO = new Uint8Array([
        0,
        32,
        72,
        80,
        75,
        69,
        45,
        118,
        49,
        72,
        80,
        75,
        69,
        0,
        16,
        0,
        1,
        0,
        2,
        107,
        101,
        121,
        0,
        143,
        195,
        174,
        184,
        50,
        73,
        10,
        75,
        90,
        179,
        228,
        32,
        35,
        40,
        125,
        178,
        154,
        31,
        75,
        199,
        194,
        34,
        192,
        223,
        34,
        135,
        39,
        183,
        10,
        64,
        33,
        18,
        47,
        63,
        4,
        233,
        32,
        108,
        209,
        36,
        19,
        80,
        53,
        41,
        180,
        122,
        198,
        166,
        48,
        185,
        46,
        196,
        207,
        125,
        35,
        69,
        8,
        208,
        175,
        151,
        113,
        201,
        158,
        80
      ]);
      IV_INFO = new Uint8Array([
        0,
        12,
        72,
        80,
        75,
        69,
        45,
        118,
        49,
        72,
        80,
        75,
        69,
        0,
        16,
        0,
        1,
        0,
        2,
        98,
        97,
        115,
        101,
        95,
        110,
        111,
        110,
        99,
        101,
        0,
        143,
        195,
        174,
        184,
        50,
        73,
        10,
        75,
        90,
        179,
        228,
        32,
        35,
        40,
        125,
        178,
        154,
        31,
        75,
        199,
        194,
        34,
        192,
        223,
        34,
        135,
        39,
        183,
        10,
        64,
        33,
        18,
        47,
        63,
        4,
        233,
        32,
        108,
        209,
        36,
        19,
        80,
        53,
        41,
        180,
        122,
        198,
        166,
        48,
        185,
        46,
        196,
        207,
        125,
        35,
        69,
        8,
        208,
        175,
        151,
        113,
        201,
        158,
        80
      ]);
      PRODUCTION_SIGNER_PUBLIC_KEY = "04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569";
      PRODUCTION_NOTARIZER_PUBLIC_KEY = "04d498aa87ac3bf982ac2b5dd9604d0074905cfbda5d62727c5a237b895e6749205e9f7cd566909c4387f6ca25c308445c60884b788560b785f4a96ac33702a469";
    }
  });

  // node_modules/@turnkey/crypto/dist/crypto.mjs
  var getPublicKey, hpkeEncrypt, hpkeAuthEncrypt, formatHpkeBuf, hpkeDecrypt, generateP256KeyPair, buildAdditionalAssociatedData, extractPrivateKeyFromPKCS8Bytes, compressRawPublicKey, uncompressRawPublicKey, buildLabeledIkm, buildLabeledInfo, extractAndExpand, deriveSS, aesGcmEncrypt, aesGcmDecrypt, getKemContext, bigIntToHex, fromDerSignature, toDerSignature;
  var init_crypto2 = __esm({
    "node_modules/@turnkey/crypto/dist/crypto.mjs"() {
      init_p256();
      init_hkdf();
      init_sha256();
      init_aes();
      init_utils2();
      init_dist();
      init_math();
      init_constants2();
      getPublicKey = (privateKey, isCompressed = true) => {
        return p2562.getPublicKey(privateKey, isCompressed);
      };
      hpkeEncrypt = ({ plainTextBuf, targetKeyBuf }) => {
        try {
          const ephemeralKeyPair = generateP256KeyPair();
          const senderPrivBuf = uint8ArrayFromHexString(ephemeralKeyPair.privateKey);
          const senderPubBuf = uint8ArrayFromHexString(ephemeralKeyPair.publicKeyUncompressed);
          const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);
          const ss = deriveSS(targetKeyBuf, uint8ArrayToHexString(senderPrivBuf));
          const kemContext = getKemContext(senderPubBuf, uint8ArrayToHexString(targetKeyBuf));
          let ikm = buildLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);
          let info = buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, SUITE_ID_1, 32);
          const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
          ikm = buildLabeledIkm(LABEL_SECRET, new Uint8Array([]), SUITE_ID_2);
          info = AES_KEY_INFO;
          const key = extractAndExpand(sharedSecret, ikm, info, 32);
          info = IV_INFO;
          const iv = extractAndExpand(sharedSecret, ikm, info, 12);
          const encryptedData = aesGcmEncrypt(plainTextBuf, key, iv, aad);
          const compressedSenderBuf = compressRawPublicKey(senderPubBuf);
          const result = new Uint8Array(compressedSenderBuf.length + encryptedData.length);
          result.set(compressedSenderBuf, 0);
          result.set(encryptedData, compressedSenderBuf.length);
          return result;
        } catch (error) {
          throw new Error(`Unable to perform hpkeEncrypt: ${error}`);
        }
      };
      hpkeAuthEncrypt = ({ plainTextBuf, targetKeyBuf, senderPriv }) => {
        try {
          const senderPrivBuf = uint8ArrayFromHexString(senderPriv);
          const senderPubBuf = getPublicKey(senderPriv, false);
          const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);
          const ss = deriveSS(targetKeyBuf, uint8ArrayToHexString(senderPrivBuf));
          const kemContext = getKemContext(senderPubBuf, uint8ArrayToHexString(targetKeyBuf));
          let ikm = buildLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);
          let info = buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, SUITE_ID_1, 32);
          const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
          ikm = buildLabeledIkm(LABEL_SECRET, new Uint8Array([]), SUITE_ID_2);
          info = AES_KEY_INFO;
          const key = extractAndExpand(sharedSecret, ikm, info, 32);
          info = IV_INFO;
          const iv = extractAndExpand(sharedSecret, ikm, info, 12);
          const encryptedData = aesGcmEncrypt(plainTextBuf, key, iv, aad);
          const compressedSenderBuf = compressRawPublicKey(senderPubBuf);
          const result = new Uint8Array(compressedSenderBuf.length + encryptedData.length);
          result.set(compressedSenderBuf, 0);
          result.set(encryptedData, compressedSenderBuf.length);
          return result;
        } catch (error) {
          throw new Error(`Unable to perform hpkeEncrypt: ${error}`);
        }
      };
      formatHpkeBuf = (encryptedBuf) => {
        const compressedSenderBuf = encryptedBuf.slice(0, 33);
        const encryptedData = encryptedBuf.slice(33);
        const encappedKeyBufHex = uint8ArrayToHexString(uncompressRawPublicKey(compressedSenderBuf));
        const ciphertextHex = uint8ArrayToHexString(encryptedData);
        return JSON.stringify({
          encappedPublic: encappedKeyBufHex,
          ciphertext: ciphertextHex
        });
      };
      hpkeDecrypt = ({ ciphertextBuf, encappedKeyBuf, receiverPriv }) => {
        try {
          let ikm;
          let info;
          const receiverPubBuf = getPublicKey(uint8ArrayFromHexString(receiverPriv), false);
          const aad = buildAdditionalAssociatedData(encappedKeyBuf, receiverPubBuf);
          const ss = deriveSS(encappedKeyBuf, receiverPriv);
          const kemContext = getKemContext(encappedKeyBuf, uint8ArrayToHexString(receiverPubBuf));
          ikm = buildLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);
          info = buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, SUITE_ID_1, 32);
          const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
          ikm = buildLabeledIkm(LABEL_SECRET, new Uint8Array([]), SUITE_ID_2);
          info = AES_KEY_INFO;
          const key = extractAndExpand(sharedSecret, ikm, info, 32);
          info = IV_INFO;
          const iv = extractAndExpand(sharedSecret, ikm, info, 12);
          const decryptedData = aesGcmDecrypt(ciphertextBuf, key, iv, aad);
          return decryptedData;
        } catch (error) {
          throw new Error(`Unable to perform hpkeDecrypt: ${error} `);
        }
      };
      generateP256KeyPair = () => {
        const privateKey = randomBytes(32);
        const publicKey = getPublicKey(privateKey, true);
        const publicKeyUncompressed = uint8ArrayToHexString(uncompressRawPublicKey(publicKey));
        return {
          privateKey: uint8ArrayToHexString(privateKey),
          publicKey: uint8ArrayToHexString(publicKey),
          publicKeyUncompressed
        };
      };
      buildAdditionalAssociatedData = (senderPubBuf, receiverPubBuf) => {
        return new Uint8Array([
          ...Array.from(senderPubBuf),
          ...Array.from(receiverPubBuf)
        ]);
      };
      extractPrivateKeyFromPKCS8Bytes = (privateKey) => {
        return privateKey.slice(36, 36 + 32);
      };
      compressRawPublicKey = (rawPublicKey) => {
        const len = rawPublicKey.byteLength;
        var compressedBytes = rawPublicKey.slice(0, 1 + len >>> 1);
        compressedBytes[0] = 2 | rawPublicKey[len - 1] & 1;
        return compressedBytes;
      };
      uncompressRawPublicKey = (rawPublicKey) => {
        if (rawPublicKey.length !== 33) {
          throw new Error("failed to uncompress raw public key: invalid length");
        }
        if (!(rawPublicKey[0] === 2 || rawPublicKey[0] === 3)) {
          throw new Error("failed to uncompress raw public key: invalid prefix");
        }
        const lsb = rawPublicKey[0] === 3;
        const x = BigInt("0x" + uint8ArrayToHexString(rawPublicKey.subarray(1)));
        const p = BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951");
        const b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b ");
        const a = p - BigInt(3);
        const rhs = ((x * x + a) * x + b) % p;
        let y = modSqrt2(rhs, p);
        if (lsb !== testBit2(y, 0)) {
          y = (p - y) % p;
        }
        if (x < BigInt(0) || x >= p) {
          throw new Error("x is out of range");
        }
        if (y < BigInt(0) || y >= p) {
          throw new Error("y is out of range");
        }
        var uncompressedHexString = "04" + bigIntToHex(x, 64) + bigIntToHex(y, 64);
        return uint8ArrayFromHexString(uncompressedHexString);
      };
      buildLabeledIkm = (label, ikm, suiteId) => {
        const combinedLength = HPKE_VERSION.length + suiteId.length + label.length + ikm.length;
        const ret = new Uint8Array(combinedLength);
        let offset = 0;
        ret.set(HPKE_VERSION, offset);
        offset += HPKE_VERSION.length;
        ret.set(suiteId, offset);
        offset += suiteId.length;
        ret.set(label, offset);
        offset += label.length;
        ret.set(ikm, offset);
        return ret;
      };
      buildLabeledInfo = (label, info, suiteId, len) => {
        const suiteIdStartIndex = 9;
        const ret = new Uint8Array(suiteIdStartIndex + suiteId.byteLength + label.byteLength + info.byteLength);
        ret.set(new Uint8Array([0, len]), 0);
        ret.set(HPKE_VERSION, 2);
        ret.set(suiteId, suiteIdStartIndex);
        ret.set(label, suiteIdStartIndex + suiteId.byteLength);
        ret.set(info, suiteIdStartIndex + suiteId.byteLength + label.byteLength);
        return ret;
      };
      extractAndExpand = (sharedSecret, ikm, info, len) => {
        const prk = extract2(sha2562, ikm, sharedSecret);
        const resp = expand(sha2562, prk, info, len);
        return new Uint8Array(resp);
      };
      deriveSS = (encappedKeyBuf, priv) => {
        const ss = p2562.getSharedSecret(uint8ArrayFromHexString(priv), encappedKeyBuf);
        return ss.slice(1);
      };
      aesGcmEncrypt = (plainTextData, key, iv, aad) => {
        const aes = gcm(key, iv, aad);
        const data = aes.encrypt(plainTextData);
        return data;
      };
      aesGcmDecrypt = (encryptedData, key, iv, aad) => {
        const aes = gcm(key, iv, aad);
        const data = aes.decrypt(encryptedData);
        return data;
      };
      getKemContext = (encappedKeyBuf, publicKey) => {
        const encappedKeyArray = new Uint8Array(encappedKeyBuf);
        const publicKeyArray = uint8ArrayFromHexString(publicKey);
        const kemContext = new Uint8Array(encappedKeyArray.length + publicKeyArray.length);
        kemContext.set(encappedKeyArray);
        kemContext.set(publicKeyArray, encappedKeyArray.length);
        return kemContext;
      };
      bigIntToHex = (num2, length) => {
        const hexString = num2.toString(16);
        if (hexString.length > length) {
          throw new Error(`number cannot fit in a hex string of ${length} characters`);
        }
        return hexString.padStart(length, "0");
      };
      fromDerSignature = (derSignature) => {
        const derSignatureBuf = uint8ArrayFromHexString(derSignature);
        if (derSignatureBuf.length < 2) {
          throw new Error("failed to convert DER-encoded signature: insufficient length");
        }
        if (derSignatureBuf[0] !== 48) {
          throw new Error("failed to convert DER-encoded signature: invalid format (missing SEQUENCE tag)");
        }
        let index2 = 1;
        const lengthByte = derSignatureBuf[index2];
        if (lengthByte <= 127) {
          if (derSignatureBuf.length < 1 + 1 + lengthByte) {
            throw new Error("failed to convert DER-encoded signature: inconsistent message length header");
          }
          index2 += 1;
        } else {
          throw new Error("failed to convert DER-encoded signature: unexpectedly large or invalid signature length");
        }
        if (derSignatureBuf[index2] !== 2) {
          throw new Error("failed to convert DER-encoded signature: invalid tag for r");
        }
        index2++;
        const rLength = derSignatureBuf[index2];
        if (rLength > 33) {
          throw new Error("failed to convert DER-encoded signature: unexpected length for r");
        }
        index2++;
        const r = derSignatureBuf.slice(index2, index2 + rLength);
        index2 += rLength;
        if (derSignatureBuf[index2] !== 2) {
          throw new Error("failed to convert DER-encoded signature: invalid tag for s");
        }
        index2++;
        const sLength = derSignatureBuf[index2];
        if (sLength > 33) {
          throw new Error("failed to convert DER-encoded signature: unexpected length for s");
        }
        index2++;
        const s = derSignatureBuf.slice(index2, index2 + sLength);
        const rPadded = normalizePadding(r, 32);
        const sPadded = normalizePadding(s, 32);
        return new Uint8Array([...rPadded, ...sPadded]);
      };
      toDerSignature = (rawSignature) => {
        const rawSignatureBuf = uint8ArrayFromHexString(rawSignature);
        const r = rawSignatureBuf.slice(0, 32);
        const s = rawSignatureBuf.slice(32, 64);
        const encodeDerInteger = (integer) => {
          if (integer === void 0 || integer.length === 0 || integer[0] === void 0) {
            throw new Error("Invalid integer: input is undefined or empty.");
          }
          const needsPadding = integer[0] & 128;
          const paddedInteger = needsPadding ? new Uint8Array([0, ...integer]) : integer;
          return new Uint8Array([2, paddedInteger.length, ...paddedInteger]);
        };
        const rEncoded = encodeDerInteger(r);
        const sEncoded = encodeDerInteger(s);
        const derSignature = new Uint8Array([
          48,
          rEncoded.length + sEncoded.length,
          ...rEncoded,
          ...sEncoded
        ]);
        return uint8ArrayToHexString(derSignature);
      };
    }
  });

  // node_modules/base-x/src/esm/index.js
  function base(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    const BASE_MAP = new Uint8Array(256);
    for (let j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (let i = 0; i < ALPHABET2.length; i++) {
      const x = ALPHABET2.charAt(i);
      const xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    const BASE = ALPHABET2.length;
    const LEADER = ALPHABET2.charAt(0);
    const FACTOR = Math.log(BASE) / Math.log(256);
    const iFACTOR = Math.log(256) / Math.log(BASE);
    function encode5(source) {
      if (source instanceof Uint8Array) {
      } else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      let zeroes = 0;
      let length = 0;
      let pbegin = 0;
      const pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      const size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
      const b58 = new Uint8Array(size5);
      while (pbegin !== pend) {
        let carry = source[pbegin];
        let i = 0;
        for (let it1 = size5 - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i;
        pbegin++;
      }
      let it2 = size5 - length;
      while (it2 !== size5 && b58[it2] === 0) {
        it2++;
      }
      let str = LEADER.repeat(zeroes);
      for (; it2 < size5; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      let psz = 0;
      let zeroes = 0;
      let length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      const size5 = (source.length - psz) * FACTOR + 1 >>> 0;
      const b256 = new Uint8Array(size5);
      while (psz < source.length) {
        const charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        let carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        let i = 0;
        for (let it3 = size5 - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i;
        psz++;
      }
      let it4 = size5 - length;
      while (it4 !== size5 && b256[it4] === 0) {
        it4++;
      }
      const vch = new Uint8Array(zeroes + (size5 - it4));
      let j = zeroes;
      while (it4 !== size5) {
        vch[j++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string) {
      const buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode: encode5,
      decodeUnsafe,
      decode: decode2
    };
  }
  var esm_default;
  var init_esm2 = __esm({
    "node_modules/base-x/src/esm/index.js"() {
      esm_default = base;
    }
  });

  // node_modules/bs58/src/esm/index.js
  var esm_exports2 = {};
  __export(esm_exports2, {
    default: () => esm_default2
  });
  var ALPHABET, esm_default2;
  var init_esm3 = __esm({
    "node_modules/bs58/src/esm/index.js"() {
      init_esm2();
      ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      esm_default2 = esm_default(ALPHABET);
    }
  });

  // node_modules/bs58check/src/esm/base.js
  function base_default(checksumFn) {
    function encode5(payload) {
      var payloadU8 = Uint8Array.from(payload);
      var checksum3 = checksumFn(payloadU8);
      var length = payloadU8.length + 4;
      var both = new Uint8Array(length);
      both.set(payloadU8, 0);
      both.set(checksum3.subarray(0, 4), payloadU8.length);
      return esm_default2.encode(both);
    }
    function decodeRaw(buffer2) {
      var payload = buffer2.slice(0, -4);
      var checksum3 = buffer2.slice(-4);
      var newChecksum = checksumFn(payload);
      if (checksum3[0] ^ newChecksum[0] | checksum3[1] ^ newChecksum[1] | checksum3[2] ^ newChecksum[2] | checksum3[3] ^ newChecksum[3])
        return;
      return payload;
    }
    function decodeUnsafe(str) {
      var buffer2 = esm_default2.decodeUnsafe(str);
      if (buffer2 == null)
        return;
      return decodeRaw(buffer2);
    }
    function decode2(str) {
      var buffer2 = esm_default2.decode(str);
      var payload = decodeRaw(buffer2);
      if (payload == null)
        throw new Error("Invalid checksum");
      return payload;
    }
    return {
      encode: encode5,
      decode: decode2,
      decodeUnsafe
    };
  }
  var init_base3 = __esm({
    "node_modules/bs58check/src/esm/base.js"() {
      "use strict";
      init_esm3();
    }
  });

  // node_modules/bs58check/src/esm/index.js
  var esm_exports3 = {};
  __export(esm_exports3, {
    default: () => esm_default3
  });
  function sha256x2(buffer2) {
    return sha2562(sha2562(buffer2));
  }
  var esm_default3;
  var init_esm4 = __esm({
    "node_modules/bs58check/src/esm/index.js"() {
      "use strict";
      init_sha256();
      init_base3();
      esm_default3 = base_default(sha256x2);
    }
  });

  // node_modules/@turnkey/crypto/dist/bs58check.mjs
  function unwrap(obj) {
    let cur = obj;
    while (cur && !(cur.encode && cur.decode && cur.decodeUnsafe) && cur.default) {
      cur = cur.default;
    }
    return cur;
  }
  var bs58check;
  var init_bs58check = __esm({
    "node_modules/@turnkey/crypto/dist/bs58check.mjs"() {
      init_esm4();
      bs58check = unwrap(esm_exports3);
    }
  });

  // node_modules/@turnkey/crypto/dist/bs58.mjs
  function unwrap2(obj) {
    let cur = obj;
    while (cur && !(cur.encode && cur.decode && cur.decodeUnsafe) && cur.default) {
      cur = cur.default;
    }
    return cur;
  }
  var bs58;
  var init_bs58 = __esm({
    "node_modules/@turnkey/crypto/dist/bs58.mjs"() {
      init_esm3();
      bs58 = unwrap2(esm_exports2);
    }
  });

  // node_modules/@noble/curves/esm/abstract/edwards.js
  function validateOpts2(curve) {
    const opts = validateBasic(curve);
    validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards(curveDef) {
    const CURVE = validateOpts2(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n7 << BigInt(nByteLength * 8) - _1n11;
    const modP2 = Fp2.create;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    const uvRatio2 = CURVE.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n11 };
      }
    });
    const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      abool("phflag", phflag);
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function aCoordinate(title, n, banZero = false) {
      const min = banZero ? _1n11 : _0n11;
      aInRange("coordinate " + title, n, min, MASK);
    }
    function aextpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { ex: x, ey: y, ez: z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n3 : Fp2.inv(z);
      const ax = modP2(x * iz);
      const ay = modP2(y * iz);
      const zz = modP2(z * iz);
      if (is0)
        return { x: _0n11, y: _1n11 };
      if (zz !== _1n11)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      const { a, d } = CURVE;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = p;
      const X2 = modP2(X * X);
      const Y2 = modP2(Y * Y);
      const Z2 = modP2(Z * Z);
      const Z4 = modP2(Z2 * Z2);
      const aX2 = modP2(X2 * a);
      const left = modP2(Z2 * modP2(aX2 + Y2));
      const right = modP2(Z4 + modP2(d * modP2(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP2(X * Y);
      const ZT = modP2(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point2 {
      constructor(ex, ey, ez, et) {
        aCoordinate("x", ex);
        aCoordinate("y", ey);
        aCoordinate("z", ez, true);
        aCoordinate("t", et);
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        aCoordinate("x", x);
        aCoordinate("y", y);
        return new Point2(x, y, _1n11, modP2(x * y));
      }
      static normalizeZ(points) {
        const toInv = FpInvertBatch(Fp2, points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point2, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // Not required for fromHex(), which always creates valid points.
      // Could be useful for fromAffine().
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aextpoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP2(X1 * Z2);
        const X2Z1 = modP2(X2 * Z1);
        const Y1Z2 = modP2(Y1 * Z2);
        const Y2Z1 = modP2(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP2(-this.ex), this.ey, this.ez, modP2(-this.et));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP2(X1 * X1);
        const B = modP2(Y1 * Y1);
        const C = modP2(_2n7 * modP2(Z1 * Z1));
        const D = modP2(a * A);
        const x1y1 = X1 + Y1;
        const E = modP2(modP2(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP2(E * F);
        const Y3 = modP2(G2 * H);
        const T3 = modP2(E * H);
        const Z3 = modP2(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aextpoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        const A = modP2(X1 * X2);
        const B = modP2(Y1 * Y2);
        const C = modP2(T1 * d * T2);
        const D = modP2(Z1 * Z2);
        const E = modP2((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP2(B - a * A);
        const X3 = modP2(E * F);
        const Y3 = modP2(G2 * H);
        const T3 = modP2(E * H);
        const Z3 = modP2(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point2.normalizeZ);
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const n = scalar;
        aInRange("scalar", n, _1n11, CURVE_ORDER);
        const { p, f } = this.wNAF(n);
        return Point2.normalizeZ([p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point2.ZERO) {
        const n = scalar;
        aInRange("scalar", n, _0n11, CURVE_ORDER);
        if (n === _0n11)
          return I;
        if (this.is0() || n === _1n11)
          return this;
        return wnaf.wNAFCachedUnsafe(this, n, Point2.normalizeZ, acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n11)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      // Converts hash string or Uint8Array to Point.
      // Uses algo from RFC8032 5.1.3.
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp2.BYTES;
        hex = ensureBytes("pointHex", hex, len);
        abool("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE(normed);
        const max = zip215 ? MASK : Fp2.ORDER;
        aInRange("pointHex.y", y, _0n11, max);
        const y2 = modP2(y * y);
        const u = modP2(y2 - _1n11);
        const v = modP2(d * y2 - a);
        let { isValid, value: x } = uvRatio2(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n11) === _1n11;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n11 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP2(-x);
        return Point2.fromAffine({ x, y });
      }
      static fromPrivateKey(privKey) {
        const { scalar } = getPrivateScalar(privKey);
        return G.multiply(scalar);
      }
      toRawBytes() {
        const { x, y } = this.toAffine();
        const bytes = numberToBytesLE(y, Fp2.BYTES);
        bytes[bytes.length - 1] |= x & _1n11 ? 128 : 0;
        return bytes;
      }
      toHex() {
        return bytesToHex2(this.toRawBytes());
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n11, modP2(CURVE.Gx * CURVE.Gy));
    Point2.ZERO = new Point2(_0n11, _1n11, _1n11, _0n11);
    const { BASE: G, ZERO: I } = Point2;
    const wnaf = wNAF(Point2, nByteLength * 8);
    function modN2(a) {
      return mod(a, CURVE_ORDER);
    }
    function modN_LE(hash2) {
      return modN2(bytesToNumberLE(hash2));
    }
    function getPrivateScalar(key) {
      const len = Fp2.BYTES;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(key) {
      const { head, prefix, scalar } = getPrivateScalar(key);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey2(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN2(r + k * scalar);
      aInRange("signature.s", s, _0n11, CURVE_ORDER);
      const res = concatBytes2(R, numberToBytesLE(s, Fp2.BYTES));
      return ensureBytes("result", res, Fp2.BYTES * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp2.BYTES;
      sig = ensureBytes("signature", sig, 2 * len);
      msg = ensureBytes("message", msg);
      publicKey = ensureBytes("publicKey", publicKey, len);
      if (zip215 !== void 0)
        abool("zip215", zip215);
      if (prehash)
        msg = prehash(msg);
      const s = bytesToNumberLE(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point2.fromHex(publicKey, zip215);
        R = Point2.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
    }
    G._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
      randomPrivateKey: () => randomBytes2(Fp2.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey: getPublicKey2,
      sign,
      verify,
      ExtendedPoint: Point2,
      utils
    };
  }
  var _0n11, _1n11, _2n7, _8n3, VERIFY_DEFAULT;
  var init_edwards = __esm({
    "node_modules/@noble/curves/esm/abstract/edwards.js"() {
      init_curve();
      init_modular();
      init_utils3();
      _0n11 = BigInt(0);
      _1n11 = BigInt(1);
      _2n7 = BigInt(2);
      _8n3 = BigInt(8);
      VERIFY_DEFAULT = { zip215: true };
    }
  });

  // node_modules/@noble/curves/esm/ed25519.js
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n8, P) * b2 % P;
    const b5 = pow2(b4, _1n12, P) * x % P;
    const b10 = pow2(b5, _5n3, P) * b5 % P;
    const b20 = pow2(b10, _10n, P) * b10 % P;
    const b40 = pow2(b20, _20n, P) * b20 % P;
    const b80 = pow2(b40, _40n, P) * b40 % P;
    const b160 = pow2(b80, _80n, P) * b80 % P;
    const b240 = pow2(b160, _80n, P) * b80 % P;
    const b250 = pow2(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n8, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }
  function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = mod(v * v * v, P);
    const v7 = mod(v3 * v3 * v, P);
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow, P);
    const vx2 = mod(v * x * x, P);
    const root1 = x;
    const root2 = mod(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u, P);
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var ED25519_P, ED25519_SQRT_M1, _0n12, _1n12, _2n8, _3n5, _5n3, _8n4, Fp, ed25519Defaults, ed25519;
  var init_ed25519 = __esm({
    "node_modules/@noble/curves/esm/ed25519.js"() {
      init_sha2();
      init_utils2();
      init_edwards();
      init_modular();
      ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      _0n12 = BigInt(0);
      _1n12 = BigInt(1);
      _2n8 = BigInt(2);
      _3n5 = BigInt(3);
      _5n3 = BigInt(5);
      _8n4 = BigInt(8);
      Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
      ed25519Defaults = /* @__PURE__ */ (() => ({
        // Removing Fp.create() will still work, and is 10% faster on sign
        a: Fp.create(BigInt(-1)),
        // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field 2n**255n - 19n
        Fp,
        // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        h: _8n4,
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512,
        randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
      }))();
      ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
    }
  });

  // node_modules/@turnkey/crypto/dist/turnkey.mjs
  var decryptCredentialBundle, decryptExportBundle, verifyStampSignature, verifyEnclaveSignature, loadPublicKey, decodeKey, encryptPrivateKeyToBundle, encryptWalletToBundle, verifySessionJwtSignature;
  var init_turnkey = __esm({
    "node_modules/@turnkey/crypto/dist/turnkey.mjs"() {
      init_bs58check();
      init_bs58();
      init_dist();
      init_constants2();
      init_crypto2();
      init_p256();
      init_ed25519();
      init_sha256();
      decryptCredentialBundle = (credentialBundle, embeddedKey) => {
        try {
          const bundleBytes = bs58check.decode(credentialBundle);
          if (bundleBytes.byteLength <= 33) {
            throw new Error(`Bundle size ${bundleBytes.byteLength} is too low. Expecting a compressed public key (33 bytes) and an encrypted credential.`);
          }
          const compressedEncappedKeyBuf = bundleBytes.slice(0, 33);
          const ciphertextBuf = bundleBytes.slice(33);
          const encappedKeyBuf = uncompressRawPublicKey(compressedEncappedKeyBuf);
          const decryptedData = hpkeDecrypt({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey
          });
          return uint8ArrayToHexString(decryptedData);
        } catch (error) {
          throw new Error(`"Error decrypting bundle:", ${error}`);
        }
      };
      decryptExportBundle = async ({ exportBundle, embeddedKey, organizationId, dangerouslyOverrideSignerPublicKey, keyFormat, returnMnemonic }) => {
        try {
          const parsedExportBundle = JSON.parse(exportBundle);
          const verified = await verifyEnclaveSignature(parsedExportBundle.enclaveQuorumPublic, parsedExportBundle.dataSignature, parsedExportBundle.data, dangerouslyOverrideSignerPublicKey);
          if (!verified) {
            throw new Error(`failed to verify enclave signature: ${parsedExportBundle}`);
          }
          const signedData = JSON.parse(new TextDecoder().decode(uint8ArrayFromHexString(parsedExportBundle.data)));
          if (!signedData.organizationId || signedData.organizationId !== organizationId) {
            throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
          }
          if (!signedData.encappedPublic) {
            throw new Error('missing "encappedPublic" in bundle signed data');
          }
          const encappedKeyBuf = uint8ArrayFromHexString(signedData.encappedPublic);
          const ciphertextBuf = uint8ArrayFromHexString(signedData.ciphertext);
          const decryptedData = hpkeDecrypt({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey
          });
          if (keyFormat === "SOLANA" && !returnMnemonic) {
            if (decryptedData.length !== 32) {
              throw new Error(`invalid private key length. Expected 32 bytes. Got ${decryptedData.length}.`);
            }
            const publicKeyBytes = ed25519.getPublicKey(decryptedData);
            if (publicKeyBytes.length !== 32) {
              throw new Error(`invalid public key length. Expected 32 bytes. Got ${publicKeyBytes.length}.`);
            }
            const concatenatedBytes = new Uint8Array(64);
            concatenatedBytes.set(decryptedData, 0);
            concatenatedBytes.set(publicKeyBytes, 32);
            return bs58.encode(concatenatedBytes);
          }
          const decryptedDataHex = uint8ArrayToHexString(decryptedData);
          return returnMnemonic ? hexToAscii(decryptedDataHex) : decryptedDataHex;
        } catch (error) {
          throw new Error(`Error decrypting bundle: ${error}`);
        }
      };
      verifyStampSignature = async (publicKey, signature, signedData) => {
        const publicKeyBuffer = uint8ArrayFromHexString(publicKey);
        const loadedPublicKey = loadPublicKey(publicKeyBuffer);
        if (!loadedPublicKey) {
          throw new Error("failed to load public key");
        }
        const publicSignatureBuf = fromDerSignature(signature);
        const signedDataBuf = new TextEncoder().encode(signedData);
        const hashedData = sha2562(signedDataBuf);
        return p2562.verify(publicSignatureBuf, hashedData, loadedPublicKey.toHex());
      };
      verifyEnclaveSignature = async (enclaveQuorumPublic, publicSignature, signedData, dangerouslyOverrideSignerPublicKey) => {
        const expectedSignerPublicKey = dangerouslyOverrideSignerPublicKey || PRODUCTION_SIGNER_PUBLIC_KEY;
        if (enclaveQuorumPublic != expectedSignerPublicKey) {
          throw new Error(`expected signer key ${dangerouslyOverrideSignerPublicKey ?? PRODUCTION_SIGNER_PUBLIC_KEY} does not match signer key from bundle: ${enclaveQuorumPublic}`);
        }
        const encryptionQuorumPublicBuf = new Uint8Array(uint8ArrayFromHexString(enclaveQuorumPublic));
        const quorumKey = loadPublicKey(encryptionQuorumPublicBuf);
        if (!quorumKey) {
          throw new Error("failed to load quorum key");
        }
        const publicSignatureBuf = fromDerSignature(publicSignature);
        const signedDataBuf = uint8ArrayFromHexString(signedData);
        const hashedData = sha2562(signedDataBuf);
        return p2562.verify(publicSignatureBuf, hashedData, quorumKey.toHex());
      };
      loadPublicKey = (publicKey) => {
        return p2562.ProjectivePoint.fromHex(uint8ArrayToHexString(publicKey));
      };
      decodeKey = (privateKey, keyFormat) => {
        switch (keyFormat) {
          case "SOLANA":
            const decodedKeyBytes = bs58.decode(privateKey);
            if (decodedKeyBytes.length !== 64) {
              throw new Error(`invalid key length. Expected 64 bytes. Got ${decodedKeyBytes.length}.`);
            }
            return decodedKeyBytes.subarray(0, 32);
          case "HEXADECIMAL":
            if (privateKey.startsWith("0x")) {
              return uint8ArrayFromHexString(privateKey.slice(2));
            }
            return uint8ArrayFromHexString(privateKey);
          default:
            console.warn(`invalid key format: ${keyFormat}. Defaulting to HEXADECIMAL.`);
            if (privateKey.startsWith("0x")) {
              return uint8ArrayFromHexString(privateKey.slice(2));
            }
            return uint8ArrayFromHexString(privateKey);
        }
      };
      encryptPrivateKeyToBundle = async ({ privateKey, keyFormat, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey }) => {
        const parsedImportBundle = JSON.parse(importBundle);
        const plainTextBuf = decodeKey(privateKey, keyFormat);
        const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
        if (!verified) {
          throw new Error(`failed to verify enclave signature: ${importBundle}`);
        }
        const signedData = JSON.parse(new TextDecoder().decode(uint8ArrayFromHexString(parsedImportBundle.data)));
        if (!signedData.organizationId || signedData.organizationId !== organizationId) {
          throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
        }
        if (!signedData.userId || signedData.userId !== userId) {
          throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
        }
        if (!signedData.targetPublic) {
          throw new Error('missing "targetPublic" in bundle signed data');
        }
        const targetKeyBuf = uint8ArrayFromHexString(signedData.targetPublic);
        const privateKeyBundle = hpkeEncrypt({ plainTextBuf, targetKeyBuf });
        return formatHpkeBuf(privateKeyBundle);
      };
      encryptWalletToBundle = async ({ mnemonic, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey }) => {
        const parsedImportBundle = JSON.parse(importBundle);
        const plainTextBuf = new TextEncoder().encode(mnemonic);
        const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
        if (!verified) {
          throw new Error(`failed to verify enclave signature: ${importBundle}`);
        }
        const signedData = JSON.parse(new TextDecoder().decode(uint8ArrayFromHexString(parsedImportBundle.data)));
        if (!signedData.organizationId || signedData.organizationId !== organizationId) {
          throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
        }
        if (!signedData.userId || signedData.userId !== userId) {
          throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
        }
        if (!signedData.targetPublic) {
          throw new Error('missing "targetPublic" in bundle signed data');
        }
        const targetKeyBuf = uint8ArrayFromHexString(signedData.targetPublic);
        const privateKeyBundle = hpkeEncrypt({ plainTextBuf, targetKeyBuf });
        return formatHpkeBuf(privateKeyBundle);
      };
      verifySessionJwtSignature = async (jwt, dangerouslyOverrideNotarizerPublicKey) => {
        const notarizerKeyHex = dangerouslyOverrideNotarizerPublicKey ?? PRODUCTION_NOTARIZER_PUBLIC_KEY;
        const [headerB64, payloadB64, signatureB64] = jwt.split(".");
        if (!signatureB64)
          throw new Error("invalid JWT: need 3 parts");
        const signingInput = `${headerB64}.${payloadB64}`;
        const h1 = sha2562(new TextEncoder().encode(signingInput));
        const msgDigest = sha2562(h1);
        const toB64 = (u) => (u = u.replace(/-/g, "+").replace(/_/g, "/")).padEnd(u.length + (4 - u.length % 4) % 4, "=");
        const signature = Uint8Array.from(atob(toB64(signatureB64)).split("").map((c) => c.charCodeAt(0)));
        const publicKey = uint8ArrayFromHexString(notarizerKeyHex);
        return p2562.verify(signature, msgDigest, publicKey);
      };
    }
  });

  // node_modules/@turnkey/crypto/dist/index.mjs
  var dist_exports3 = {};
  __export(dist_exports3, {
    buildAdditionalAssociatedData: () => buildAdditionalAssociatedData,
    compressRawPublicKey: () => compressRawPublicKey,
    decryptCredentialBundle: () => decryptCredentialBundle,
    decryptExportBundle: () => decryptExportBundle,
    encryptPrivateKeyToBundle: () => encryptPrivateKeyToBundle,
    encryptWalletToBundle: () => encryptWalletToBundle,
    extractPrivateKeyFromPKCS8Bytes: () => extractPrivateKeyFromPKCS8Bytes,
    formatHpkeBuf: () => formatHpkeBuf,
    fromDerSignature: () => fromDerSignature,
    generateP256KeyPair: () => generateP256KeyPair,
    getPublicKey: () => getPublicKey,
    hpkeAuthEncrypt: () => hpkeAuthEncrypt,
    hpkeDecrypt: () => hpkeDecrypt,
    hpkeEncrypt: () => hpkeEncrypt,
    toDerSignature: () => toDerSignature,
    uncompressRawPublicKey: () => uncompressRawPublicKey,
    verifySessionJwtSignature: () => verifySessionJwtSignature,
    verifyStampSignature: () => verifyStampSignature
  });
  var init_dist6 = __esm({
    "node_modules/@turnkey/crypto/dist/index.mjs"() {
      init_crypto2();
      init_turnkey();
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/stamper.mjs
  var WalletStamper;
  var init_stamper = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/stamper.mjs"() {
      init_dist();
      init_errors();
      init_types();
      init_constants();
      WalletStamper = class {
        constructor(wallet) {
          this.wallet = wallet;
        }
        async stamp(payload) {
          let signature;
          try {
            signature = await this.wallet.signMessage(payload);
          } catch (error) {
            throw new WalletStamperError("Failed to sign the message", error);
          }
          const scheme = this.wallet.type === WalletType.Solana ? SIGNATURE_SCHEME_TK_API_ED25519 : SIGNATURE_SCHEME_TK_API_SECP256K1_EIP191;
          let publicKey;
          try {
            if (this.wallet.type === WalletType.Ethereum) {
              const { recoverPublicKey: recoverPublicKey2, hashMessage: hashMessage2 } = await Promise.resolve().then(() => (init_esm(), esm_exports));
              const { compressRawPublicKey: compressRawPublicKey2, toDerSignature: toDerSignature2 } = await Promise.resolve().then(() => (init_dist6(), dist_exports3));
              const secp256k1PublicKey = await recoverPublicKey2({
                hash: hashMessage2(payload),
                signature
              });
              publicKey = secp256k1PublicKey.replace("0x", "");
              const publicKeyBytes = Uint8Array.from(Buffer.from(publicKey, "hex"));
              publicKey = Buffer.from(compressRawPublicKey2(publicKeyBytes)).toString("hex");
              signature = toDerSignature2(signature.replace("0x", ""));
            } else {
              publicKey = await this.wallet.getPublicKey();
            }
          } catch (error) {
            throw new WalletStamperError("Failed to recover public key", error);
          }
          const stamp = {
            publicKey,
            scheme,
            signature
          };
          return {
            stampHeaderName: STAMP_HEADER_NAME,
            stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
          };
        }
      };
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/ethereum.mjs
  var init_ethereum = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/ethereum.mjs"() {
      init_types();
      init_errors();
      init_dist6();
    }
  });

  // node_modules/@turnkey/wallet-stamper/dist/index.mjs
  var init_dist7 = __esm({
    "node_modules/@turnkey/wallet-stamper/dist/index.mjs"() {
      init_constants();
      init_errors();
      init_types();
      init_stamper();
      init_ethereum();
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__polyfills__/window.mjs
  var loadWindow, WindowWrapper;
  var init_window = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__polyfills__/window.mjs"() {
      loadWindow = () => {
        if (typeof window !== "undefined") {
          return window;
        } else {
          return {
            localStorage: {
              getItem: (_key) => {
                return null;
              },
              setItem: (_key, _value) => {
              },
              removeItem: (_key) => {
              },
              clear: () => {
              },
              key: (_index) => {
                return null;
              },
              length: 0
            },
            location: {
              hostname: ""
            }
          };
        }
      };
      WindowWrapper = loadWindow();
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__types__/base.mjs
  var MethodType, TurnkeyRequestError2, AuthClient;
  var init_base4 = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__types__/base.mjs"() {
      (function(MethodType2) {
        MethodType2[MethodType2["Get"] = 0] = "Get";
        MethodType2[MethodType2["List"] = 1] = "List";
        MethodType2[MethodType2["Command"] = 2] = "Command";
      })(MethodType || (MethodType = {}));
      TurnkeyRequestError2 = class extends Error {
        constructor(input) {
          let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
          if (input.details != null) {
            turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
          }
          super(turnkeyErrorMessage);
          this.name = "TurnkeyRequestError";
          this.details = input.details ?? null;
          this.code = input.code;
        }
      };
      (function(AuthClient2) {
        AuthClient2["Passkey"] = "passkey";
        AuthClient2["Wallet"] = "wallet";
        AuthClient2["Iframe"] = "iframe";
        AuthClient2["IndexedDb"] = "indexed-db";
      })(AuthClient || (AuthClient = {}));
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/storage.mjs
  var StorageKeys, StorageLocation, STORAGE_VALUE_LOCATIONS, STORAGE_LOCATIONS, getStorageValue, setStorageValue, removeStorageValue, storeSession;
  var init_storage = __esm({
    "node_modules/@turnkey/sdk-browser/dist/storage.mjs"() {
      init_window();
      (function(StorageKeys2) {
        StorageKeys2["Session"] = "@turnkey/session/v2";
        StorageKeys2["Client"] = "@turnkey/client";
      })(StorageKeys || (StorageKeys = {}));
      (function(StorageLocation2) {
        StorageLocation2["Local"] = "local";
        StorageLocation2["Secure"] = "secure";
        StorageLocation2["Session"] = "session";
      })(StorageLocation || (StorageLocation = {}));
      STORAGE_VALUE_LOCATIONS = {
        [StorageKeys.Session]: StorageLocation.Session,
        [StorageKeys.Client]: StorageLocation.Session
      };
      STORAGE_LOCATIONS = {
        [StorageLocation.Local]: WindowWrapper.localStorage,
        [StorageLocation.Secure]: WindowWrapper.localStorage,
        [StorageLocation.Session]: WindowWrapper.localStorage
      };
      getStorageValue = async (storageKey) => {
        const storageLocation = STORAGE_VALUE_LOCATIONS[storageKey];
        const browserStorageLocation = STORAGE_LOCATIONS[storageLocation];
        const storageItem = browserStorageLocation.getItem(storageKey);
        return storageItem ? JSON.parse(storageItem) : void 0;
      };
      setStorageValue = async (storageKey, storageValue) => {
        const storageLocation = STORAGE_VALUE_LOCATIONS[storageKey];
        const browserStorageLocation = STORAGE_LOCATIONS[storageLocation];
        browserStorageLocation.setItem(storageKey, JSON.stringify(storageValue));
      };
      removeStorageValue = async (storageKey) => {
        const storageLocation = STORAGE_VALUE_LOCATIONS[storageKey];
        const browserStorageLocation = STORAGE_LOCATIONS[storageLocation];
        browserStorageLocation.removeItem(storageKey);
      };
      storeSession = async (session, client) => {
        await setStorageValue(StorageKeys.Session, session);
        if (client) {
          await setStorageValue(StorageKeys.Client, client);
        }
      };
    }
  });

  // node_modules/@turnkey/sdk-types/dist/index.mjs
  var SessionType, FiatOnRampProvider, FiatOnRampCryptoCurrency;
  var init_dist8 = __esm({
    "node_modules/@turnkey/sdk-types/dist/index.mjs"() {
      (function(SessionType2) {
        SessionType2["READ_ONLY"] = "SESSION_TYPE_READ_ONLY";
        SessionType2["READ_WRITE"] = "SESSION_TYPE_READ_WRITE";
      })(SessionType || (SessionType = {}));
      (function(FiatOnRampProvider2) {
        FiatOnRampProvider2["COINBASE"] = "FIAT_ON_RAMP_PROVIDER_COINBASE";
        FiatOnRampProvider2["MOONPAY"] = "FIAT_ON_RAMP_PROVIDER_MOONPAY";
      })(FiatOnRampProvider || (FiatOnRampProvider = {}));
      (function(FiatOnRampCryptoCurrency2) {
        FiatOnRampCryptoCurrency2["BITCOIN"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC";
        FiatOnRampCryptoCurrency2["ETHEREUM"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH";
        FiatOnRampCryptoCurrency2["SOLANA"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL";
        FiatOnRampCryptoCurrency2["USDC"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";
      })(FiatOnRampCryptoCurrency || (FiatOnRampCryptoCurrency = {}));
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__generated__/version.mjs
  var VERSION2;
  var init_version5 = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__generated__/version.mjs"() {
      VERSION2 = "@turnkey/sdk-browser@5.3.4";
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num2) {
        return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer2, offset, isLE3, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE3 ? nBytes - 1 : 0;
        var d = isLE3 ? -1 : 1;
        var s = buffer2[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer2, value, offset, isLE3, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE3 ? 0 : nBytes - 1;
        var d = isLE3 ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer2[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from5(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from5(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString3(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from5(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize4(size5) {
        if (typeof size5 !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size5 < 0) {
          throw new RangeError('The value "' + size5 + '" is invalid for option "size"');
        }
      }
      function alloc(size5, fill, encoding) {
        assertSize4(size5);
        if (size5 <= 0) {
          return createBuffer(size5);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size5).fill(fill, encoding) : createBuffer(size5).fill(fill);
        }
        return createBuffer(size5);
      }
      Buffer3.alloc = function(size5, fill, encoding) {
        return alloc(size5, fill, encoding);
      };
      function allocUnsafe(size5) {
        assertSize4(size5);
        return createBuffer(size5 < 0 ? 0 : checked(size5) | 0);
      }
      Buffer3.allocUnsafe = function(size5) {
        return allocUnsafe(size5);
      };
      Buffer3.allocUnsafeSlow = function(size5) {
        return allocUnsafe(size5);
      };
      function fromString3(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat4(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer2 = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength(string, encoding) {
        if (Buffer3.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes3(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes3(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap322() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir) return -1;
          else byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes3(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice3(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul3 = 1;
        let i = 0;
        while (++i < byteLength2 && (mul3 *= 256)) {
          val += this[offset + i] * mul3;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul3 = 1;
        while (byteLength2 > 0 && (mul3 *= 256)) {
          val += this[offset + --byteLength2] * mul3;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul3 = 1;
        let i = 0;
        while (++i < byteLength2 && (mul3 *= 256)) {
          val += this[offset + i] * mul3;
        }
        mul3 *= 128;
        if (val >= mul3) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul3 = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul3 *= 256)) {
          val += this[offset + --i] * mul3;
        }
        mul3 *= 128;
        if (val >= mul3) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul3 = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul3 *= 256)) {
          this[offset + i] = value / mul3 & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul3 = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul3 *= 256)) {
          this[offset + i] = value / mul3 & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul3 = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul3 *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul3 >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul3 = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul3 *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul3 >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes3(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/@hpke/common/esm/src/errors.js
  var init_errors5 = __esm({
    "node_modules/@hpke/common/esm/src/errors.js"() {
    }
  });

  // node_modules/@hpke/common/esm/_dnt.shims.js
  function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
      get(_target, prop, _receiver) {
        if (prop in extObj) {
          return extObj[prop];
        } else {
          return baseObj[prop];
        }
      },
      set(_target, prop, value) {
        if (prop in extObj) {
          delete extObj[prop];
        }
        baseObj[prop] = value;
        return true;
      },
      deleteProperty(_target, prop) {
        let success = false;
        if (prop in extObj) {
          delete extObj[prop];
          success = true;
        }
        if (prop in baseObj) {
          delete baseObj[prop];
          success = true;
        }
        return success;
      },
      ownKeys(_target) {
        const baseKeys = Reflect.ownKeys(baseObj);
        const extKeys = Reflect.ownKeys(extObj);
        const extKeysSet = new Set(extKeys);
        return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
      },
      defineProperty(_target, prop, desc) {
        if (prop in extObj) {
          delete extObj[prop];
        }
        Reflect.defineProperty(baseObj, prop, desc);
        return true;
      },
      getOwnPropertyDescriptor(_target, prop) {
        if (prop in extObj) {
          return Reflect.getOwnPropertyDescriptor(extObj, prop);
        } else {
          return Reflect.getOwnPropertyDescriptor(baseObj, prop);
        }
      },
      has(_target, prop) {
        return prop in extObj || prop in baseObj;
      }
    });
  }
  var dntGlobals, dntGlobalThis;
  var init_dnt_shims = __esm({
    "node_modules/@hpke/common/esm/_dnt.shims.js"() {
      dntGlobals = {};
      dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
    }
  });

  // node_modules/@hpke/common/esm/src/algorithm.js
  var init_algorithm = __esm({
    "node_modules/@hpke/common/esm/src/algorithm.js"() {
      init_dnt_shims();
      init_errors5();
    }
  });

  // node_modules/@hpke/common/esm/src/identifiers.js
  var init_identifiers = __esm({
    "node_modules/@hpke/common/esm/src/identifiers.js"() {
    }
  });

  // node_modules/@hpke/common/esm/src/consts.js
  var EMPTY;
  var init_consts = __esm({
    "node_modules/@hpke/common/esm/src/consts.js"() {
      EMPTY = new Uint8Array(0);
    }
  });

  // node_modules/@hpke/common/esm/src/interfaces/kemInterface.js
  var SUITE_ID_HEADER_KEM;
  var init_kemInterface = __esm({
    "node_modules/@hpke/common/esm/src/interfaces/kemInterface.js"() {
      SUITE_ID_HEADER_KEM = new Uint8Array([
        75,
        69,
        77,
        0,
        0
      ]);
    }
  });

  // node_modules/@hpke/common/esm/src/utils/misc.js
  var init_misc = __esm({
    "node_modules/@hpke/common/esm/src/utils/misc.js"() {
      init_dnt_shims();
      init_identifiers();
    }
  });

  // node_modules/@hpke/common/esm/src/kems/dhkem.js
  var LABEL_EAE_PRK2, LABEL_SHARED_SECRET2;
  var init_dhkem = __esm({
    "node_modules/@hpke/common/esm/src/kems/dhkem.js"() {
      init_consts();
      init_errors5();
      init_kemInterface();
      init_misc();
      LABEL_EAE_PRK2 = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);
      LABEL_SHARED_SECRET2 = new Uint8Array([
        115,
        104,
        97,
        114,
        101,
        100,
        95,
        115,
        101,
        99,
        114,
        101,
        116
      ]);
    }
  });

  // node_modules/@hpke/common/esm/src/interfaces/dhkemPrimitives.js
  var LABEL_DKP_PRK, LABEL_SK;
  var init_dhkemPrimitives = __esm({
    "node_modules/@hpke/common/esm/src/interfaces/dhkemPrimitives.js"() {
      LABEL_DKP_PRK = new Uint8Array([
        100,
        107,
        112,
        95,
        112,
        114,
        107
      ]);
      LABEL_SK = new Uint8Array([115, 107]);
    }
  });

  // node_modules/@hpke/common/esm/src/utils/bignum.js
  var init_bignum = __esm({
    "node_modules/@hpke/common/esm/src/utils/bignum.js"() {
    }
  });

  // node_modules/@hpke/common/esm/src/kems/dhkemPrimitives/ec.js
  var LABEL_CANDIDATE, ORDER_P_256, ORDER_P_384, ORDER_P_521, PKCS8_ALG_ID_P_256, PKCS8_ALG_ID_P_384, PKCS8_ALG_ID_P_521;
  var init_ec = __esm({
    "node_modules/@hpke/common/esm/src/kems/dhkemPrimitives/ec.js"() {
      init_algorithm();
      init_consts();
      init_errors5();
      init_identifiers();
      init_dhkemPrimitives();
      init_bignum();
      init_misc();
      LABEL_CANDIDATE = new Uint8Array([
        99,
        97,
        110,
        100,
        105,
        100,
        97,
        116,
        101
      ]);
      ORDER_P_256 = new Uint8Array([
        255,
        255,
        255,
        255,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        188,
        230,
        250,
        173,
        167,
        23,
        158,
        132,
        243,
        185,
        202,
        194,
        252,
        99,
        37,
        81
      ]);
      ORDER_P_384 = new Uint8Array([
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        199,
        99,
        77,
        129,
        244,
        55,
        45,
        223,
        88,
        26,
        13,
        178,
        72,
        176,
        167,
        122,
        236,
        236,
        25,
        106,
        204,
        197,
        41,
        115
      ]);
      ORDER_P_521 = new Uint8Array([
        1,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        250,
        81,
        134,
        135,
        131,
        191,
        47,
        150,
        107,
        127,
        204,
        1,
        72,
        247,
        9,
        165,
        208,
        59,
        181,
        201,
        184,
        137,
        156,
        71,
        174,
        187,
        111,
        183,
        30,
        145,
        56,
        100,
        9
      ]);
      PKCS8_ALG_ID_P_256 = new Uint8Array([
        48,
        65,
        2,
        1,
        0,
        48,
        19,
        6,
        7,
        42,
        134,
        72,
        206,
        61,
        2,
        1,
        6,
        8,
        42,
        134,
        72,
        206,
        61,
        3,
        1,
        7,
        4,
        39,
        48,
        37,
        2,
        1,
        1,
        4,
        32
      ]);
      PKCS8_ALG_ID_P_384 = new Uint8Array([
        48,
        78,
        2,
        1,
        0,
        48,
        16,
        6,
        7,
        42,
        134,
        72,
        206,
        61,
        2,
        1,
        6,
        5,
        43,
        129,
        4,
        0,
        34,
        4,
        55,
        48,
        53,
        2,
        1,
        1,
        4,
        48
      ]);
      PKCS8_ALG_ID_P_521 = new Uint8Array([
        48,
        96,
        2,
        1,
        0,
        48,
        16,
        6,
        7,
        42,
        134,
        72,
        206,
        61,
        2,
        1,
        6,
        5,
        43,
        129,
        4,
        0,
        35,
        4,
        73,
        48,
        71,
        2,
        1,
        1,
        4,
        66
      ]);
    }
  });

  // node_modules/@hpke/common/esm/src/xCryptoKey.js
  var init_xCryptoKey = __esm({
    "node_modules/@hpke/common/esm/src/xCryptoKey.js"() {
    }
  });

  // node_modules/@hpke/common/esm/src/kems/hybridkem.js
  var init_hybridkem = __esm({
    "node_modules/@hpke/common/esm/src/kems/hybridkem.js"() {
      init_consts();
      init_errors5();
      init_identifiers();
      init_dhkemPrimitives();
      init_kemInterface();
      init_misc();
      init_xCryptoKey();
    }
  });

  // node_modules/@hpke/common/esm/src/kdfs/hkdf.js
  var HPKE_VERSION2;
  var init_hkdf2 = __esm({
    "node_modules/@hpke/common/esm/src/kdfs/hkdf.js"() {
      init_consts();
      init_errors5();
      init_identifiers();
      init_algorithm();
      HPKE_VERSION2 = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);
    }
  });

  // node_modules/@hpke/common/esm/src/interfaces/aeadEncryptionContext.js
  var init_aeadEncryptionContext = __esm({
    "node_modules/@hpke/common/esm/src/interfaces/aeadEncryptionContext.js"() {
    }
  });

  // node_modules/@hpke/common/esm/mod.js
  var init_mod = __esm({
    "node_modules/@hpke/common/esm/mod.js"() {
      init_errors5();
      init_algorithm();
      init_identifiers();
      init_dhkem();
      init_ec();
      init_hybridkem();
      init_xCryptoKey();
      init_hkdf2();
      init_aeadEncryptionContext();
      init_dhkemPrimitives();
      init_dhkemPrimitives();
      init_kemInterface();
      init_consts();
      init_misc();
    }
  });

  // node_modules/@hpke/core/esm/src/aeads/aesGcm.js
  var init_aesGcm = __esm({
    "node_modules/@hpke/core/esm/src/aeads/aesGcm.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/core/esm/src/aeads/exportOnly.js
  var init_exportOnly = __esm({
    "node_modules/@hpke/core/esm/src/aeads/exportOnly.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/core/esm/src/utils/emitNotSupported.js
  var init_emitNotSupported = __esm({
    "node_modules/@hpke/core/esm/src/utils/emitNotSupported.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/core/esm/src/exporterContext.js
  var LABEL_SEC;
  var init_exporterContext = __esm({
    "node_modules/@hpke/core/esm/src/exporterContext.js"() {
      init_mod();
      init_emitNotSupported();
      LABEL_SEC = new Uint8Array([115, 101, 99]);
    }
  });

  // node_modules/@hpke/core/esm/src/encryptionContext.js
  var init_encryptionContext = __esm({
    "node_modules/@hpke/core/esm/src/encryptionContext.js"() {
      init_mod();
      init_exporterContext();
    }
  });

  // node_modules/@hpke/core/esm/src/recipientContext.js
  var init_recipientContext = __esm({
    "node_modules/@hpke/core/esm/src/recipientContext.js"() {
      init_mod();
      init_encryptionContext();
    }
  });

  // node_modules/@hpke/core/esm/src/senderContext.js
  var init_senderContext = __esm({
    "node_modules/@hpke/core/esm/src/senderContext.js"() {
      init_mod();
      init_encryptionContext();
    }
  });

  // node_modules/@hpke/core/esm/src/cipherSuiteNative.js
  var LABEL_BASE_NONCE, LABEL_EXP, LABEL_INFO_HASH, LABEL_KEY, LABEL_PSK_ID_HASH, LABEL_SECRET2, SUITE_ID_HEADER_HPKE;
  var init_cipherSuiteNative = __esm({
    "node_modules/@hpke/core/esm/src/cipherSuiteNative.js"() {
      init_mod();
      init_exporterContext();
      init_recipientContext();
      init_senderContext();
      LABEL_BASE_NONCE = new Uint8Array([
        98,
        97,
        115,
        101,
        95,
        110,
        111,
        110,
        99,
        101
      ]);
      LABEL_EXP = new Uint8Array([101, 120, 112]);
      LABEL_INFO_HASH = new Uint8Array([
        105,
        110,
        102,
        111,
        95,
        104,
        97,
        115,
        104
      ]);
      LABEL_KEY = new Uint8Array([107, 101, 121]);
      LABEL_PSK_ID_HASH = new Uint8Array([
        112,
        115,
        107,
        95,
        105,
        100,
        95,
        104,
        97,
        115,
        104
      ]);
      LABEL_SECRET2 = new Uint8Array([115, 101, 99, 114, 101, 116]);
      SUITE_ID_HEADER_HPKE = new Uint8Array([
        72,
        80,
        75,
        69,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
    }
  });

  // node_modules/@hpke/core/esm/src/kems/dhkemNative.js
  var init_dhkemNative = __esm({
    "node_modules/@hpke/core/esm/src/kems/dhkemNative.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/core/esm/src/native.js
  var init_native2 = __esm({
    "node_modules/@hpke/core/esm/src/native.js"() {
      init_mod();
      init_cipherSuiteNative();
      init_dhkemNative();
    }
  });

  // node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x25519.js
  var PKCS8_ALG_ID_X25519;
  var init_x25519 = __esm({
    "node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x25519.js"() {
      init_mod();
      PKCS8_ALG_ID_X25519 = new Uint8Array([
        48,
        46,
        2,
        1,
        0,
        48,
        5,
        6,
        3,
        43,
        101,
        110,
        4,
        34,
        4,
        32
      ]);
    }
  });

  // node_modules/@hpke/core/esm/src/kems/dhkemX25519.js
  var init_dhkemX25519 = __esm({
    "node_modules/@hpke/core/esm/src/kems/dhkemX25519.js"() {
      init_mod();
      init_x25519();
    }
  });

  // node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x448.js
  var PKCS8_ALG_ID_X448;
  var init_x448 = __esm({
    "node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x448.js"() {
      init_mod();
      PKCS8_ALG_ID_X448 = new Uint8Array([
        48,
        70,
        2,
        1,
        0,
        48,
        5,
        6,
        3,
        43,
        101,
        111,
        4,
        58,
        4,
        56
      ]);
    }
  });

  // node_modules/@hpke/core/esm/src/kems/dhkemX448.js
  var init_dhkemX448 = __esm({
    "node_modules/@hpke/core/esm/src/kems/dhkemX448.js"() {
      init_mod();
      init_x448();
    }
  });

  // node_modules/@hpke/core/esm/mod.js
  var init_mod2 = __esm({
    "node_modules/@hpke/core/esm/mod.js"() {
      init_mod();
      init_aesGcm();
      init_exportOnly();
      init_native2();
      init_dhkemX25519();
      init_dhkemX448();
    }
  });

  // node_modules/hpke-js/esm/src/identifiers.js
  var init_identifiers2 = __esm({
    "node_modules/hpke-js/esm/src/identifiers.js"() {
    }
  });

  // node_modules/@hpke/chacha20poly1305/esm/src/chacha20Poly1305.js
  var init_chacha20Poly1305 = __esm({
    "node_modules/@hpke/chacha20poly1305/esm/src/chacha20Poly1305.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/chacha20poly1305/esm/mod.js
  var init_mod3 = __esm({
    "node_modules/@hpke/chacha20poly1305/esm/mod.js"() {
      init_chacha20Poly1305();
    }
  });

  // node_modules/@hpke/dhkem-x25519/esm/src/hkdfSha256.js
  var init_hkdfSha256 = __esm({
    "node_modules/@hpke/dhkem-x25519/esm/src/hkdfSha256.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/dhkem-x25519/esm/src/x25519.js
  var init_x255192 = __esm({
    "node_modules/@hpke/dhkem-x25519/esm/src/x25519.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/dhkem-x25519/esm/src/dhkemX25519.js
  var init_dhkemX255192 = __esm({
    "node_modules/@hpke/dhkem-x25519/esm/src/dhkemX25519.js"() {
      init_mod();
      init_hkdfSha256();
      init_x255192();
    }
  });

  // node_modules/@hpke/dhkem-x25519/esm/mod.js
  var init_mod4 = __esm({
    "node_modules/@hpke/dhkem-x25519/esm/mod.js"() {
      init_dhkemX255192();
      init_hkdfSha256();
      init_x255192();
    }
  });

  // node_modules/@hpke/dhkem-x448/esm/src/hkdfSha512.js
  var init_hkdfSha512 = __esm({
    "node_modules/@hpke/dhkem-x448/esm/src/hkdfSha512.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/dhkem-x448/esm/src/x448.js
  var init_x4482 = __esm({
    "node_modules/@hpke/dhkem-x448/esm/src/x448.js"() {
      init_mod();
    }
  });

  // node_modules/@hpke/dhkem-x448/esm/src/dhkemX448.js
  var init_dhkemX4482 = __esm({
    "node_modules/@hpke/dhkem-x448/esm/src/dhkemX448.js"() {
      init_mod();
      init_hkdfSha512();
      init_x4482();
    }
  });

  // node_modules/@hpke/dhkem-x448/esm/mod.js
  var init_mod5 = __esm({
    "node_modules/@hpke/dhkem-x448/esm/mod.js"() {
      init_dhkemX4482();
      init_hkdfSha512();
      init_x4482();
    }
  });

  // node_modules/hpke-js/esm/src/kdfs/hkdfSha384.js
  var init_hkdfSha384 = __esm({
    "node_modules/hpke-js/esm/src/kdfs/hkdfSha384.js"() {
      init_mod();
    }
  });

  // node_modules/hpke-js/esm/src/kems/dhkemP256.js
  var init_dhkemP256 = __esm({
    "node_modules/hpke-js/esm/src/kems/dhkemP256.js"() {
      init_mod();
      init_mod4();
    }
  });

  // node_modules/hpke-js/esm/src/kems/dhkemP384.js
  var init_dhkemP384 = __esm({
    "node_modules/hpke-js/esm/src/kems/dhkemP384.js"() {
      init_mod();
      init_hkdfSha384();
    }
  });

  // node_modules/hpke-js/esm/src/kems/dhkemP521.js
  var init_dhkemP521 = __esm({
    "node_modules/hpke-js/esm/src/kems/dhkemP521.js"() {
      init_mod();
      init_mod5();
    }
  });

  // node_modules/hpke-js/esm/src/cipherSuite.js
  var init_cipherSuite = __esm({
    "node_modules/hpke-js/esm/src/cipherSuite.js"() {
      init_mod2();
      init_mod3();
      init_mod4();
      init_mod5();
      init_hkdfSha384();
      init_dhkemP256();
      init_dhkemP384();
      init_dhkemP521();
    }
  });

  // node_modules/hpke-js/esm/mod.js
  var init_mod6 = __esm({
    "node_modules/hpke-js/esm/mod.js"() {
      init_mod2();
      init_identifiers2();
      init_cipherSuite();
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/utils.mjs
  function parseSession(token) {
    if (typeof token !== "string") {
      return token;
    }
    const [, payload] = token.split(".");
    if (!payload) {
      throw new Error("Invalid JWT: Missing payload");
    }
    const decoded = JSON.parse(atob(payload));
    const { exp, public_key: publicKey, session_type: sessionType, user_id: userId, organization_id: organizationId } = decoded;
    if (!exp || !publicKey || !sessionType || !userId || !organizationId) {
      throw new Error("JWT payload missing required fields");
    }
    return {
      sessionType,
      userId,
      organizationId,
      expiry: exp,
      token: publicKey
    };
  }
  var import_buffer, generateRandomBuffer, base64UrlEncode;
  var init_utils11 = __esm({
    "node_modules/@turnkey/sdk-browser/dist/utils.mjs"() {
      init_dist();
      init_dist6();
      import_buffer = __toESM(require_buffer(), 1);
      init_esm4();
      init_mod6();
      init_dist2();
      generateRandomBuffer = () => {
        const arr = new Uint8Array(32);
        crypto.getRandomValues(arr);
        return arr.buffer;
      };
      base64UrlEncode = (challenge2) => {
        return import_buffer.Buffer.from(challenge2).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      };
      Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__generated__/sdk-client-base.mjs
  var TurnkeySDKClientBase;
  var init_sdk_client_base = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__generated__/sdk-client-base.mjs"() {
      init_dist3();
      init_base4();
      init_version5();
      init_storage();
      init_utils11();
      TurnkeySDKClientBase = class {
        constructor(config2) {
          this.getActivity = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_activity", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetActivity = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getApiKey = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_api_key", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetApiKey = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getApiKeys = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_api_keys", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetApiKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAttestationDocument = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_attestation", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetAttestationDocument = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_attestation";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAuthenticator = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_authenticator", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetAuthenticator = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_authenticator";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getAuthenticators = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_authenticators", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetAuthenticators = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOauthProviders = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_oauth_providers", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetOauthProviders = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOrganization = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_organization", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetOrganization = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getOrganizationConfigs = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_organization_configs", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetOrganizationConfigs = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_organization_configs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPolicy = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_policy", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetPolicy = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPrivateKey = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_private_key", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetPrivateKey = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSmartContractInterface = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_smart_contract_interface", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetSmartContractInterface = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getUser = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_user", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetUser = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWallet = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_wallet", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWalletAccount = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/get_wallet_account", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetWalletAccount = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_wallet_account";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getActivities = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_activities", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetActivities = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_activities";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPolicies = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_policies", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetPolicies = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_policies";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.listPrivateKeyTags = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_private_key_tags", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampListPrivateKeyTags = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_private_key_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getPrivateKeys = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_private_keys", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetPrivateKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSmartContractInterfaces = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_smart_contract_interfaces", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetSmartContractInterfaces = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_smart_contract_interfaces";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getSubOrgIds = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_suborgs", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetSubOrgIds = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_suborgs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.listUserTags = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_user_tags", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampListUserTags = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_user_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getUsers = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_users", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetUsers = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getVerifiedSubOrgIds = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_verified_suborgs", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetVerifiedSubOrgIds = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_verified_suborgs";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWalletAccounts = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_wallet_accounts", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetWalletAccounts = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_wallet_accounts";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWallets = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/list_wallets", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetWallets = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_wallets";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.getWhoami = async (input = {}) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/public/v1/query/whoami", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampGetWhoami = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/whoami";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.approveActivity = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.activityDecision("/public/v1/submit/approve_activity", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_APPROVE_ACTIVITY"
            });
          };
          this.stampApproveActivity = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/approve_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createApiKeys = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_api_keys", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
            }, "createApiKeysResult");
          };
          this.stampCreateApiKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createApiOnlyUsers = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_api_only_users", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
            }, "createApiOnlyUsersResult");
          };
          this.stampCreateApiOnlyUsers = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_api_only_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createAuthenticators = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_authenticators", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
            }, "createAuthenticatorsResult");
          };
          this.stampCreateAuthenticators = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createInvitations = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_invitations", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_INVITATIONS"
            }, "createInvitationsResult");
          };
          this.stampCreateInvitations = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_invitations";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createOauthProviders = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_oauth_providers", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
            }, "createOauthProvidersResult");
          };
          this.stampCreateOauthProviders = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPolicies = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_policies", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_POLICIES"
            }, "createPoliciesResult");
          };
          this.stampCreatePolicies = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_policies";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPolicy = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_policy", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_POLICY_V3"
            }, "createPolicyResult");
          };
          this.stampCreatePolicy = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPrivateKeyTag = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_private_key_tag", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
            }, "createPrivateKeyTagResult");
          };
          this.stampCreatePrivateKeyTag = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_private_key_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createPrivateKeys = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_private_keys", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
            }, "createPrivateKeysResultV2");
          };
          this.stampCreatePrivateKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createReadOnlySession = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_read_only_session", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
            }, "createReadOnlySessionResult");
          };
          this.stampCreateReadOnlySession = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_read_only_session";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createReadWriteSession = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_read_write_session", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
            }, "createReadWriteSessionResultV2");
          };
          this.stampCreateReadWriteSession = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_read_write_session";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createSmartContractInterface = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_smart_contract_interface", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
            }, "createSmartContractInterfaceResult");
          };
          this.stampCreateSmartContractInterface = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createSubOrganization = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_sub_organization", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
            }, "createSubOrganizationResultV7");
          };
          this.stampCreateSubOrganization = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_sub_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createUserTag = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_user_tag", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_USER_TAG"
            }, "createUserTagResult");
          };
          this.stampCreateUserTag = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_user_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createUsers = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_users", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_USERS_V3"
            }, "createUsersResult");
          };
          this.stampCreateUsers = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createWallet = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_wallet", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_WALLET"
            }, "createWalletResult");
          };
          this.stampCreateWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.createWalletAccounts = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/create_wallet_accounts", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
            }, "createWalletAccountsResult");
          };
          this.stampCreateWalletAccounts = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_wallet_accounts";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteApiKeys = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_api_keys", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_API_KEYS"
            }, "deleteApiKeysResult");
          };
          this.stampDeleteApiKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_api_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteAuthenticators = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_authenticators", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
            }, "deleteAuthenticatorsResult");
          };
          this.stampDeleteAuthenticators = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_authenticators";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteInvitation = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_invitation", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_INVITATION"
            }, "deleteInvitationResult");
          };
          this.stampDeleteInvitation = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_invitation";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteOauthProviders = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_oauth_providers", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
            }, "deleteOauthProvidersResult");
          };
          this.stampDeleteOauthProviders = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_oauth_providers";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePolicy = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_policy", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_POLICY"
            }, "deletePolicyResult");
          };
          this.stampDeletePolicy = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePrivateKeyTags = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_private_key_tags", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
            }, "deletePrivateKeyTagsResult");
          };
          this.stampDeletePrivateKeyTags = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_private_key_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deletePrivateKeys = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_private_keys", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
            }, "deletePrivateKeysResult");
          };
          this.stampDeletePrivateKeys = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_private_keys";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteSmartContractInterface = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_smart_contract_interface", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
            }, "deleteSmartContractInterfaceResult");
          };
          this.stampDeleteSmartContractInterface = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_smart_contract_interface";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteSubOrganization = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_sub_organization", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
            }, "deleteSubOrganizationResult");
          };
          this.stampDeleteSubOrganization = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_sub_organization";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteUserTags = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_user_tags", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_USER_TAGS"
            }, "deleteUserTagsResult");
          };
          this.stampDeleteUserTags = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_user_tags";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteUsers = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_users", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_USERS"
            }, "deleteUsersResult");
          };
          this.stampDeleteUsers = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_users";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.deleteWallets = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/delete_wallets", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_DELETE_WALLETS"
            }, "deleteWalletsResult");
          };
          this.stampDeleteWallets = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_wallets";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.emailAuth = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/email_auth", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_EMAIL_AUTH_V2"
            }, "emailAuthResult");
          };
          this.stampEmailAuth = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/email_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportPrivateKey = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/export_private_key", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
            }, "exportPrivateKeyResult");
          };
          this.stampExportPrivateKey = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportWallet = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/export_wallet", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_EXPORT_WALLET"
            }, "exportWalletResult");
          };
          this.stampExportWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.exportWalletAccount = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/export_wallet_account", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
            }, "exportWalletAccountResult");
          };
          this.stampExportWalletAccount = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_wallet_account";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.importPrivateKey = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/import_private_key", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
            }, "importPrivateKeyResult");
          };
          this.stampImportPrivateKey = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/import_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.importWallet = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/import_wallet", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_IMPORT_WALLET"
            }, "importWalletResult");
          };
          this.stampImportWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/import_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initFiatOnRamp = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_fiat_on_ramp", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
            }, "initFiatOnRampResult");
          };
          this.stampInitFiatOnRamp = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_fiat_on_ramp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initImportPrivateKey = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_import_private_key", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
            }, "initImportPrivateKeyResult");
          };
          this.stampInitImportPrivateKey = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_import_private_key";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initImportWallet = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_import_wallet", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
            }, "initImportWalletResult");
          };
          this.stampInitImportWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_import_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initOtp = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_otp", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_OTP"
            }, "initOtpResult");
          };
          this.stampInitOtp = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initOtpAuth = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_otp_auth", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
            }, "initOtpAuthResultV2");
          };
          this.stampInitOtpAuth = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.initUserEmailRecovery = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/init_user_email_recovery", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
            }, "initUserEmailRecoveryResult");
          };
          this.stampInitUserEmailRecovery = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_user_email_recovery";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.oauth = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/oauth", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_OAUTH"
            }, "oauthResult");
          };
          this.stampOauth = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.oauthLogin = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/oauth_login", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_OAUTH_LOGIN"
            }, "oauthLoginResult");
          };
          this.stampOauthLogin = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.otpAuth = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/otp_auth", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_OTP_AUTH"
            }, "otpAuthResult");
          };
          this.stampOtpAuth = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_auth";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.otpLogin = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/otp_login", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_OTP_LOGIN"
            }, "otpLoginResult");
          };
          this.stampOtpLogin = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.recoverUser = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/recover_user", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_RECOVER_USER"
            }, "recoverUserResult");
          };
          this.stampRecoverUser = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/recover_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.rejectActivity = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.activityDecision("/public/v1/submit/reject_activity", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_REJECT_ACTIVITY"
            });
          };
          this.stampRejectActivity = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/reject_activity";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.removeOrganizationFeature = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/remove_organization_feature", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
            }, "removeOrganizationFeatureResult");
          };
          this.stampRemoveOrganizationFeature = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/remove_organization_feature";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.setOrganizationFeature = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/set_organization_feature", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
            }, "setOrganizationFeatureResult");
          };
          this.stampSetOrganizationFeature = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/set_organization_feature";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signRawPayload = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/sign_raw_payload", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
            }, "signRawPayloadResult");
          };
          this.stampSignRawPayload = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payload";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signRawPayloads = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/sign_raw_payloads", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
            }, "signRawPayloadsResult");
          };
          this.stampSignRawPayloads = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payloads";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.signTransaction = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/sign_transaction", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
            }, "signTransactionResult");
          };
          this.stampSignTransaction = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_transaction";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.stampLogin = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/stamp_login", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_STAMP_LOGIN"
            }, "stampLoginResult");
          };
          this.stampStampLogin = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/stamp_login";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updatePolicy = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_policy", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_POLICY_V2"
            }, "updatePolicyResultV2");
          };
          this.stampUpdatePolicy = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_policy";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updatePrivateKeyTag = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_private_key_tag", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
            }, "updatePrivateKeyTagResult");
          };
          this.stampUpdatePrivateKeyTag = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_private_key_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateRootQuorum = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_root_quorum", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
            }, "updateRootQuorumResult");
          };
          this.stampUpdateRootQuorum = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_root_quorum";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUser = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_user", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_USER"
            }, "updateUserResult");
          };
          this.stampUpdateUser = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserEmail = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_user_email", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
            }, "updateUserEmailResult");
          };
          this.stampUpdateUserEmail = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_email";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserName = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_user_name", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_USER_NAME"
            }, "updateUserNameResult");
          };
          this.stampUpdateUserName = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_name";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserPhoneNumber = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_user_phone_number", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
            }, "updateUserPhoneNumberResult");
          };
          this.stampUpdateUserPhoneNumber = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_phone_number";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateUserTag = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_user_tag", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_USER_TAG"
            }, "updateUserTagResult");
          };
          this.stampUpdateUserTag = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_tag";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.updateWallet = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/update_wallet", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_UPDATE_WALLET"
            }, "updateWalletResult");
          };
          this.stampUpdateWallet = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_wallet";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.verifyOtp = async (input) => {
            const { organizationId, timestampMs, ...rest } = input;
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.command("/public/v1/submit/verify_otp", {
              parameters: rest,
              organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
              timestampMs: timestampMs ?? String(Date.now()),
              type: "ACTIVITY_TYPE_VERIFY_OTP"
            }, "verifyOtpResult");
          };
          this.stampVerifyOtp = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/verify_otp";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.testRateLimits = async (input) => {
            let session = await getStorageValue(StorageKeys.Session);
            session = parseSession(session);
            return this.request("/tkhq/api/v1/test_rate_limits", {
              ...input,
              organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            });
          };
          this.stampTestRateLimits = async (input) => {
            if (!this.stamper) {
              return void 0;
            }
            const fullUrl = this.config.apiBaseUrl + "/tkhq/api/v1/test_rate_limits";
            const body = JSON.stringify(input);
            const stamp = await this.stamper.stamp(body);
            return {
              body,
              stamp,
              url: fullUrl
            };
          };
          this.config = config2;
          if (config2.stamper) {
            this.stamper = config2.stamper;
          }
        }
        async request(url, body) {
          const fullUrl = this.config.apiBaseUrl + url;
          const stringifiedBody = JSON.stringify(body);
          var headers = {
            "X-Client-Version": VERSION2
          };
          if (this.stamper) {
            const stamp = await this.stamper.stamp(stringifiedBody);
            headers[stamp.stampHeaderName] = stamp.stampHeaderValue;
          }
          if (this.config.readOnlySession) {
            headers["X-Session"] = this.config.readOnlySession;
          }
          const response = await fetch(fullUrl, {
            method: "POST",
            headers,
            body: stringifiedBody,
            redirect: "follow"
          });
          if (!response.ok) {
            let res;
            try {
              res = await response.json();
            } catch (_) {
              throw new Error(`${response.status} ${response.statusText}`);
            }
            throw new TurnkeyRequestError2(res);
          }
          const data = await response.json();
          return data;
        }
        async command(url, body, resultKey) {
          const pollingDuration = this.config.activityPoller?.intervalMs ?? 1e3;
          const maxRetries = this.config.activityPoller?.numRetries ?? 3;
          const sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
          const handleResponse = (activityData) => {
            const { result, status } = activityData.activity;
            if (status === "ACTIVITY_STATUS_COMPLETED") {
              return {
                ...result[`${resultKey}`],
                ...activityData
              };
            }
            return activityData;
          };
          let attempts = 0;
          const pollStatus = async (activityId) => {
            const pollBody = { activityId };
            const pollData = await this.getActivity(pollBody);
            if (attempts > maxRetries) {
              return handleResponse(pollData);
            }
            attempts += 1;
            if (!TERMINAL_ACTIVITY_STATUSES.includes(pollData.activity.status)) {
              await sleep2(pollingDuration);
              return pollStatus(activityId);
            }
            return handleResponse(pollData);
          };
          const responseData = await this.request(url, body);
          if (!TERMINAL_ACTIVITY_STATUSES.includes(responseData.activity.status)) {
            return pollStatus(responseData.activity.id);
          }
          return handleResponse(responseData);
        }
        async activityDecision(url, body) {
          const activityData = await this.request(url, body);
          return {
            ...activityData["activity"]["result"],
            ...activityData
          };
        }
      };
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__clients__/base-client.mjs
  var TurnkeyBaseClient;
  var init_base_client = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__clients__/base-client.mjs"() {
      init_sdk_client_base();
      TurnkeyBaseClient = class extends TurnkeySDKClientBase {
        constructor(config2, authClient) {
          super(config2);
          this.authClient = authClient;
        }
      };
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/constants.mjs
  var DEFAULT_SESSION_EXPIRATION_IN_SECONDS;
  var init_constants3 = __esm({
    "node_modules/@turnkey/sdk-browser/dist/constants.mjs"() {
      DEFAULT_SESSION_EXPIRATION_IN_SECONDS = "900";
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/__clients__/browser-clients.mjs
  var TurnkeyBrowserClient, TurnkeyPasskeyClient, TurnkeyIframeClient, TurnkeyWalletClient, TurnkeyIndexedDbClient;
  var init_browser_clients = __esm({
    "node_modules/@turnkey/sdk-browser/dist/__clients__/browser-clients.mjs"() {
      init_dist3();
      init_dist8();
      init_base_client();
      init_base4();
      init_utils11();
      init_storage();
      init_constants3();
      init_dist();
      TurnkeyBrowserClient = class extends TurnkeyBaseClient {
        constructor(config2, authClient) {
          super(config2, authClient);
          this.login = async (config3) => {
            const readOnlySessionResult = await this.createReadOnlySession(config3 || {});
            const session = {
              sessionType: SessionType.READ_ONLY,
              userId: readOnlySessionResult.userId,
              organizationId: readOnlySessionResult.organizationId,
              expiry: Number(readOnlySessionResult.sessionExpiry),
              token: readOnlySessionResult.session
            };
            await storeSession(session, this.authClient);
            return readOnlySessionResult;
          };
          this.refreshSession = async ({ sessionType = SessionType.READ_WRITE, expirationSeconds = DEFAULT_SESSION_EXPIRATION_IN_SECONDS, invalidateExisting = false, publicKey } = {}) => {
            try {
              switch (sessionType) {
                case SessionType.READ_ONLY: {
                  if (!(this instanceof TurnkeyPasskeyClient)) {
                    throw new Error("You must use a passkey client to refresh a read-only session.");
                  }
                  const result = await this.createReadOnlySession({});
                  const session = {
                    sessionType: SessionType.READ_ONLY,
                    userId: result.userId,
                    organizationId: result.organizationId,
                    expiry: Number(result.sessionExpiry),
                    token: result.session
                  };
                  await storeSession(session, AuthClient.Passkey);
                  return;
                }
                case SessionType.READ_WRITE: {
                  if (this instanceof TurnkeyIndexedDbClient) {
                    let keyPair = void 0;
                    let compressedHex = publicKey;
                    if (!publicKey) {
                      keyPair = await crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, false, ["sign", "verify"]);
                      const rawPubKey = new Uint8Array(await crypto.subtle.exportKey("raw", keyPair.publicKey));
                      compressedHex = uint8ArrayToHexString(pointEncode(rawPubKey));
                    }
                    const result = await this.stampLogin({
                      publicKey: compressedHex,
                      expirationSeconds,
                      invalidateExisting
                    });
                    await this.resetKeyPair(keyPair);
                    await storeSession(result.session, AuthClient.IndexedDb);
                    return;
                  }
                  if (this instanceof TurnkeyIframeClient) {
                    const targetPublicKey = publicKey ?? await this.getEmbeddedPublicKey();
                    if (!targetPublicKey) {
                      throw new Error("Unable to refresh session: missing target public key.");
                    }
                    const result = await this.createReadWriteSession({
                      targetPublicKey,
                      expirationSeconds,
                      invalidateExisting
                    });
                    const session = {
                      sessionType: SessionType.READ_WRITE,
                      userId: result.userId,
                      organizationId: result.organizationId,
                      expiry: Date.now() + Number(expirationSeconds) * 1e3,
                      token: result.credentialBundle
                    };
                    await this.injectCredentialBundle(session.token);
                    await storeSession(session, AuthClient.Iframe);
                    return;
                  }
                  throw new Error("Unsupported client type for read-write session refresh.");
                }
                default:
                  throw new Error(`Invalid session type passed: ${sessionType}`);
              }
            } catch (error) {
              throw new Error(`Unable to refresh session: ${error}`);
            }
          };
          this.loginWithBundle = async (params) => {
            const { bundle, expirationSeconds = DEFAULT_SESSION_EXPIRATION_IN_SECONDS } = params;
            if (this instanceof TurnkeyIframeClient) {
              await this.injectCredentialBundle(bundle);
            } else {
              throw new Error("You must use an iframe client to log in with a session.");
            }
            const whoAmI = await this.getWhoami();
            const session = {
              sessionType: SessionType.READ_WRITE,
              userId: whoAmI.userId,
              organizationId: whoAmI.organizationId,
              expiry: Date.now() + Number(expirationSeconds) * 1e3,
              token: bundle
            };
            await storeSession(session, AuthClient.Iframe);
          };
          this.loginWithSession = async (session) => {
            if (this instanceof TurnkeyIndexedDbClient) {
              await storeSession(session, AuthClient.IndexedDb);
            } else {
              throw new Error("You must use an indexedDb client to log in with a session.");
            }
          };
          this.loginWithPasskey = async (params) => {
            try {
              const { sessionType = SessionType.READ_WRITE, publicKey, expirationSeconds = DEFAULT_SESSION_EXPIRATION_IN_SECONDS } = params;
              if (sessionType === SessionType.READ_ONLY) {
                const readOnlySessionResult = await this.createReadOnlySession({});
                const session = {
                  sessionType: SessionType.READ_ONLY,
                  userId: readOnlySessionResult.userId,
                  organizationId: readOnlySessionResult.organizationId,
                  expiry: Number(readOnlySessionResult.sessionExpiry),
                  token: readOnlySessionResult.session
                  // Once we have api key session scopes this can change
                };
                await storeSession(session, AuthClient.Passkey);
              } else if (sessionType === SessionType.READ_WRITE) {
                if (!publicKey) {
                  throw new Error("You must provide a publicKey to create a passkey read write session.");
                }
                const sessionResponse = await this.stampLogin({
                  publicKey,
                  expirationSeconds
                });
                await storeSession(sessionResponse.session, AuthClient.IndexedDb);
              } else {
                throw new Error(`Invalid session type passed: ${sessionType}`);
              }
            } catch (error) {
              throw new Error(`Unable to log in with the provided passkey: ${error}`);
            }
          };
          this.loginWithWallet = async (params) => {
            try {
              const { sessionType = SessionType.READ_WRITE, publicKey, expirationSeconds = DEFAULT_SESSION_EXPIRATION_IN_SECONDS } = params;
              if (sessionType === SessionType.READ_ONLY) {
                const readOnlySessionResult = await this.createReadOnlySession({});
                const session = {
                  sessionType: SessionType.READ_ONLY,
                  userId: readOnlySessionResult.userId,
                  organizationId: readOnlySessionResult.organizationId,
                  expiry: Number(readOnlySessionResult.sessionExpiry),
                  token: readOnlySessionResult.session
                };
                await storeSession(session, AuthClient.Wallet);
              } else if (sessionType === SessionType.READ_WRITE) {
                if (!publicKey) {
                  throw new Error("You must provide a publicKey to create a read-write session.");
                }
                const sessionResponse = await this.stampLogin({
                  publicKey,
                  expirationSeconds
                });
                await storeSession(sessionResponse.session, AuthClient.IndexedDb);
              } else {
                throw new Error(`Invalid session type passed: ${sessionType}`);
              }
            } catch (error) {
              throw new Error(`Unable to log in with the provided wallet: ${error}`);
            }
          };
          this.deleteUserAuth = async (params) => {
            try {
              const { userId, phoneNumber, email, authenticatorIds, oauthProviderIds, apiKeyIds } = params;
              const promises = [];
              if (phoneNumber) {
                promises.push(this.updateUser({ userId, userPhoneNumber: "", userTagIds: [] }));
              }
              if (email) {
                promises.push(this.updateUser({ userId, userEmail: "", userTagIds: [] }));
              }
              if (authenticatorIds && authenticatorIds.length > 0) {
                promises.push(this.deleteAuthenticators({ userId, authenticatorIds }));
              }
              if (oauthProviderIds && oauthProviderIds.length > 0) {
                promises.push(this.deleteOauthProviders({ userId, providerIds: oauthProviderIds }));
              }
              if (apiKeyIds && apiKeyIds.length > 0) {
                promises.push(this.deleteApiKeys({ userId, apiKeyIds }));
              }
              return await Promise.all(promises);
            } catch (error) {
              throw error;
            }
          };
          this.addUserAuth = async (params) => {
            try {
              const { userId, phoneNumber, email, authenticators, oauthProviders, apiKeys } = params;
              const promises = [];
              if (phoneNumber) {
                promises.push(this.updateUser({
                  userId,
                  userPhoneNumber: phoneNumber,
                  userTagIds: []
                }));
              }
              if (email) {
                promises.push(this.updateUser({ userId, userEmail: email, userTagIds: [] }));
              }
              if (authenticators && authenticators.length > 0) {
                promises.push(this.createAuthenticators({ userId, authenticators }));
              }
              if (oauthProviders && oauthProviders.length > 0) {
                promises.push(this.createOauthProviders({ userId, oauthProviders }));
              }
              if (apiKeys && apiKeys.length > 0) {
                promises.push(this.createApiKeys({ userId, apiKeys }));
              }
              return await Promise.all(promises);
            } catch (error) {
              throw error;
            }
          };
        }
        /**
         * Comprehensive authentication update for an end user.
         * Combines add/update and delete operations into a single call.
         *
         * The behavior is driven by whether values are set to:
         * - A string/array (to create or update)
         * - `null` or an array of IDs (to remove)
         *
         * All operations are executed in parallel where applicable.
         *
         * @param params - A structured object containing all the update parameters
         *   @param params.userId - Unique identifier of the user
         *   @param params.phoneNumber - String to set (new phone) or `null` to remove
         *   @param params.email - String to set (new email) or `null` to remove
         *   @param params.authenticators - Object describing authenticators to add or remove
         *   @param params.oauthProviders - Object describing OAuth providers to add or remove
         *   @param params.apiKeys - Object describing API keys to add or remove
         *
         * @returns A promise that resolves to a boolean indicating overall success
         */
        async updateUserAuth(params) {
          try {
            const { userId, phoneNumber, email, authenticators, oauthProviders, apiKeys } = params;
            const promises = [];
            const userUpdates = {};
            if (phoneNumber !== void 0) {
              userUpdates.userPhoneNumber = phoneNumber === null ? "" : phoneNumber;
            }
            if (email !== void 0) {
              userUpdates.userEmail = email === null ? "" : email;
            }
            if (Object.keys(userUpdates).length > 0) {
              promises.push(this.updateUser({ userId, ...userUpdates, userTagIds: [] }));
            }
            if (authenticators) {
              if (authenticators.add?.length) {
                promises.push(this.createAuthenticators({
                  userId,
                  authenticators: authenticators.add
                }));
              }
              if (authenticators.deleteIds?.length) {
                promises.push(this.deleteAuthenticators({
                  userId,
                  authenticatorIds: authenticators.deleteIds
                }));
              }
            }
            if (oauthProviders) {
              if (oauthProviders.add?.length) {
                promises.push(this.createOauthProviders({
                  userId,
                  oauthProviders: oauthProviders.add
                }));
              }
              if (oauthProviders.deleteIds?.length) {
                promises.push(this.deleteOauthProviders({
                  userId,
                  providerIds: oauthProviders.deleteIds
                }));
              }
            }
            if (apiKeys) {
              if (apiKeys.add?.length) {
                promises.push(this.createApiKeys({
                  userId,
                  apiKeys: apiKeys.add
                }));
              }
              if (apiKeys.deleteIds?.length) {
                promises.push(this.deleteApiKeys({
                  userId,
                  apiKeyIds: apiKeys.deleteIds
                }));
              }
            }
            await Promise.all(promises);
            return true;
          } catch (error) {
            throw error;
          }
        }
      };
      TurnkeyPasskeyClient = class extends TurnkeyBrowserClient {
        constructor(config2) {
          super(config2, AuthClient.Passkey);
          this.createUserPasskey = async (config3 = {}) => {
            const challenge2 = generateRandomBuffer();
            const encodedChallenge = base64UrlEncode(challenge2);
            const authenticatorUserId = generateRandomBuffer();
            const webauthnConfig = {
              publicKey: {
                rp: {
                  id: config3.publicKey?.rp?.id ?? this.rpId,
                  name: config3.publicKey?.rp?.name ?? ""
                },
                challenge: config3.publicKey?.challenge ?? challenge2,
                pubKeyCredParams: config3.publicKey?.pubKeyCredParams ?? [
                  {
                    type: "public-key",
                    alg: -7
                  },
                  {
                    type: "public-key",
                    alg: -257
                  }
                ],
                user: {
                  id: config3.publicKey?.user?.id ?? authenticatorUserId,
                  name: config3.publicKey?.user?.name ?? "Default User",
                  displayName: config3.publicKey?.user?.displayName ?? "Default User"
                },
                authenticatorSelection: {
                  authenticatorAttachment: config3.publicKey?.authenticatorSelection?.authenticatorAttachment ?? void 0,
                  // default to empty
                  requireResidentKey: config3.publicKey?.authenticatorSelection?.requireResidentKey ?? true,
                  residentKey: config3.publicKey?.authenticatorSelection?.residentKey ?? "required",
                  userVerification: config3.publicKey?.authenticatorSelection?.userVerification ?? "preferred"
                }
              }
            };
            const attestation = await getWebAuthnAttestation(webauthnConfig);
            return {
              encodedChallenge: config3.publicKey?.challenge ? base64UrlEncode(config3.publicKey?.challenge) : encodedChallenge,
              attestation
            };
          };
          this.rpId = this.stamper.rpId;
        }
      };
      TurnkeyIframeClient = class extends TurnkeyBrowserClient {
        constructor(config2) {
          super(config2, AuthClient.Iframe);
          this.injectCredentialBundle = async (credentialBundle) => {
            return await this.stamper.injectCredentialBundle(credentialBundle);
          };
          this.injectWalletExportBundle = async (credentialBundle, organizationId) => {
            return await this.stamper.injectWalletExportBundle(credentialBundle, organizationId);
          };
          this.injectKeyExportBundle = async (credentialBundle, organizationId, keyFormat) => {
            return await this.stamper.injectKeyExportBundle(credentialBundle, organizationId, keyFormat);
          };
          this.injectImportBundle = async (bundle, organizationId, userId) => {
            return await this.stamper.injectImportBundle(bundle, organizationId, userId);
          };
          this.extractWalletEncryptedBundle = async () => {
            return await this.stamper.extractWalletEncryptedBundle();
          };
          this.extractKeyEncryptedBundle = async (keyFormat) => {
            return await this.stamper.extractKeyEncryptedBundle(keyFormat);
          };
          this.getEmbeddedPublicKey = async () => {
            return await this.stamper.getEmbeddedPublicKey();
          };
          this.clearEmbeddedKey = async () => {
            return await this.stamper.clearEmbeddedKey();
          };
          this.initEmbeddedKey = async () => {
            return await this.stamper.initEmbeddedKey();
          };
          this.iframePublicKey = this.stamper.iframePublicKey;
        }
      };
      TurnkeyWalletClient = class extends TurnkeyBrowserClient {
        constructor(config2) {
          super(config2, AuthClient.Wallet);
          this.wallet = config2.wallet;
        }
        async getPublicKey() {
          return this.wallet.getPublicKey();
        }
        getWalletInterface() {
          return this.wallet;
        }
      };
      TurnkeyIndexedDbClient = class extends TurnkeyBrowserClient {
        constructor(config2) {
          super(config2, AuthClient.IndexedDb);
          this.clear = async () => {
            return await this.stamper.clear();
          };
          this.getPublicKey = async () => {
            return await this.stamper.getPublicKey();
          };
          this.init = async () => {
            return await this.stamper.init();
          };
          this.resetKeyPair = async (externalKeyPair) => {
            return await this.stamper.resetKeyPair(externalKeyPair);
          };
        }
      };
    }
  });

  // node_modules/@turnkey/indexed-db-stamper/dist/index.mjs
  function convertEcdsaIeee1363ToDer2(ieee) {
    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
      throw new Error("Invalid IEEE P1363 signature encoding. Length: " + ieee.length);
    }
    const r = toUnsignedBigNum2(ieee.subarray(0, ieee.length / 2));
    const s = toUnsignedBigNum2(ieee.subarray(ieee.length / 2, ieee.length));
    let offset = 0;
    const length = 1 + 1 + r.length + 1 + 1 + s.length;
    let der;
    if (length >= 128) {
      der = new Uint8Array(length + 3);
      der[offset++] = 48;
      der[offset++] = 128 + 1;
      der[offset++] = length;
    } else {
      der = new Uint8Array(length + 2);
      der[offset++] = 48;
      der[offset++] = length;
    }
    der[offset++] = 2;
    der[offset++] = r.length;
    der.set(r, offset);
    offset += r.length;
    der[offset++] = 2;
    der[offset++] = s.length;
    der.set(s, offset);
    return der;
  }
  function toUnsignedBigNum2(bytes) {
    let start = 0;
    while (start < bytes.length && bytes[start] == 0) {
      start++;
    }
    if (start == bytes.length) {
      start = bytes.length - 1;
    }
    let extraZero = 0;
    if ((bytes[start] & 128) == 128) {
      extraZero = 1;
    }
    const res = new Uint8Array(bytes.length - start + extraZero);
    res.set(bytes.subarray(start), extraZero);
    return res;
  }
  var DB_NAME, DB_STORE, DB_KEY, stampHeaderName4, IndexedDbStamper;
  var init_dist9 = __esm({
    "node_modules/@turnkey/indexed-db-stamper/dist/index.mjs"() {
      init_dist();
      DB_NAME = "TurnkeyStamperDB";
      DB_STORE = "KeyStore";
      DB_KEY = "turnkeyKeyPair";
      stampHeaderName4 = "X-Stamp";
      IndexedDbStamper = class {
        constructor() {
          this.publicKeyHex = null;
          this.privateKey = null;
          if (typeof window === "undefined") {
            throw new Error("IndexedDB is only available in the browser");
          }
        }
        async openDb() {
          return new Promise((resolve, reject) => {
            const request2 = indexedDB.open(DB_NAME, 1);
            request2.onupgradeneeded = (event) => {
              const db = event.target.result;
              db.createObjectStore(DB_STORE);
            };
            request2.onsuccess = () => resolve(request2.result);
            request2.onerror = () => reject(request2.error);
          });
        }
        async storeKeyPair(publicKey, privateKey) {
          const db = await this.openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(DB_STORE, "readwrite");
            const store = tx.objectStore(DB_STORE);
            store.put(publicKey, `${DB_KEY}-pub`);
            store.put(privateKey, `${DB_KEY}-priv`);
            tx.oncomplete = () => {
              db.close();
              resolve();
            };
            tx.onerror = () => reject(tx.error);
            tx.onabort = () => reject(tx.error);
          });
        }
        async getStoredKeys() {
          const db = await this.openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(DB_STORE, "readonly");
            const store = tx.objectStore(DB_STORE);
            const getPub = store.get(`${DB_KEY}-pub`);
            const getPriv = store.get(`${DB_KEY}-priv`);
            let publicKey = null;
            let privateKey = null;
            getPub.onsuccess = () => publicKey = getPub.result || null;
            getPriv.onsuccess = () => privateKey = getPriv.result || null;
            tx.oncomplete = () => {
              db.close();
              resolve({ publicKey, privateKey });
            };
            tx.onerror = () => reject(tx.error);
          });
        }
        async init() {
          const { publicKey, privateKey } = await this.getStoredKeys();
          if (publicKey && privateKey) {
            this.publicKeyHex = publicKey;
            this.privateKey = privateKey;
          } else {
            await this.resetKeyPair();
          }
        }
        async resetKeyPair(externalKeyPair) {
          let privateKey;
          let publicKey;
          if (externalKeyPair) {
            const extractable = externalKeyPair.privateKey.extractable;
            if (extractable !== false) {
              throw new Error("Provided privateKey must be non-extractable.");
            }
            privateKey = externalKeyPair.privateKey;
            publicKey = externalKeyPair.publicKey;
          } else {
            const keyPair = await crypto.subtle.generateKey({
              name: "ECDSA",
              namedCurve: "P-256"
            }, false, ["sign", "verify"]);
            privateKey = keyPair.privateKey;
            publicKey = keyPair.publicKey;
          }
          const rawPubKey = new Uint8Array(await crypto.subtle.exportKey("raw", publicKey));
          const compressedPubKey = pointEncode(rawPubKey);
          const compressedHex = uint8ArrayToHexString(compressedPubKey);
          await this.storeKeyPair(compressedHex, privateKey);
          this.publicKeyHex = compressedHex;
          this.privateKey = privateKey;
        }
        getPublicKey() {
          return this.publicKeyHex;
        }
        async sign(payload) {
          if (!this.privateKey) {
            throw new Error("Key not initialized. Call init() first.");
          }
          const encodedPayload = new TextEncoder().encode(payload);
          const signatureIeee1363 = await crypto.subtle.sign({
            name: "ECDSA",
            hash: { name: "SHA-256" }
          }, this.privateKey, encodedPayload);
          const signatureDer = convertEcdsaIeee1363ToDer2(new Uint8Array(signatureIeee1363));
          return uint8ArrayToHexString(signatureDer);
        }
        async stamp(payload) {
          if (!this.publicKeyHex || !this.privateKey) {
            throw new Error("Key not initialized. Call init() first.");
          }
          const signature = await this.sign(payload);
          const stamp = {
            publicKey: this.publicKeyHex,
            scheme: "SIGNATURE_SCHEME_TK_API_P256",
            signature
          };
          return {
            stampHeaderName: stampHeaderName4,
            stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
          };
        }
        async clear() {
          const db = await this.openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(DB_STORE, "readwrite");
            const store = tx.objectStore(DB_STORE);
            store.delete(`${DB_KEY}-pub`);
            store.delete(`${DB_KEY}-priv`);
            tx.oncomplete = () => {
              db.close();
              this.publicKeyHex = null;
              this.privateKey = null;
              resolve();
            };
            tx.onerror = () => reject(tx.error);
          });
        }
      };
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/sdk-client.mjs
  var TurnkeyBrowserSDK;
  var init_sdk_client = __esm({
    "node_modules/@turnkey/sdk-browser/dist/sdk-client.mjs"() {
      init_dist7();
      init_dist4();
      init_dist5();
      init_window();
      init_base4();
      init_storage();
      init_browser_clients();
      init_browser_clients();
      init_version5();
      init_dist9();
      init_utils11();
      TurnkeyBrowserSDK = class {
        constructor(config2) {
          this.passkeyClient = (params) => {
            const targetRpId = params?.rpId ?? this.config.rpId ?? WindowWrapper.location.hostname;
            if (!targetRpId) {
              throw new Error("Tried to initialize a passkey client with no rpId defined");
            }
            this.stamper = new WebauthnStamper({
              rpId: targetRpId,
              ...params?.timeout !== void 0 && { timeout: params?.timeout },
              ...params?.userVerification !== void 0 && {
                userVerification: params?.userVerification
              },
              ...params?.allowCredentials !== void 0 && {
                allowCredentials: params?.allowCredentials
              }
            });
            return new TurnkeyPasskeyClient({
              stamper: this.stamper,
              apiBaseUrl: this.config.apiBaseUrl,
              organizationId: this.config.defaultOrganizationId
            });
          };
          this.iframeClient = async (params) => {
            if (!params.iframeUrl) {
              throw new Error("Tried to initialize iframeClient with no iframeUrl defined");
            }
            const TurnkeyIframeElementId = params.iframeElementId ?? "turnkey-default-iframe-element-id";
            this.stamper = new IframeStamper({
              iframeContainer: params.iframeContainer,
              iframeUrl: params.iframeUrl,
              iframeElementId: TurnkeyIframeElementId
            });
            await this.stamper.init(params.dangerouslyOverrideIframeKeyTtl ?? void 0);
            return new TurnkeyIframeClient({
              stamper: this.stamper,
              apiBaseUrl: this.config.apiBaseUrl,
              organizationId: this.config.defaultOrganizationId
            });
          };
          this.walletClient = (wallet) => {
            return new TurnkeyWalletClient({
              stamper: new WalletStamper(wallet),
              wallet,
              apiBaseUrl: this.config.apiBaseUrl,
              organizationId: this.config.defaultOrganizationId
            });
          };
          this.indexedDbClient = async () => {
            this.stamper = new IndexedDbStamper();
            return new TurnkeyIndexedDbClient({
              stamper: this.stamper,
              apiBaseUrl: this.config.apiBaseUrl,
              organizationId: this.config.defaultOrganizationId
            });
          };
          this.serverSign = async (methodName, params, serverSignUrl) => {
            const targetServerSignUrl = serverSignUrl ?? this.config.serverSignUrl;
            if (!targetServerSignUrl) {
              throw new Error("Tried to call serverSign with no serverSignUrl defined");
            }
            const stringifiedBody = JSON.stringify({
              methodName,
              params
            });
            const response = await fetch(targetServerSignUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Client-Version": VERSION2
              },
              body: stringifiedBody,
              redirect: "follow"
            });
            if (!response.ok) {
              let res;
              try {
                res = await response.json();
              } catch (_) {
                throw new Error(`${response.status} ${response.statusText}`);
              }
              throw new TurnkeyRequestError2(res);
            }
            const data = await response.json();
            return data;
          };
          this.getSession = async () => {
            const currentSession = await getStorageValue(StorageKeys.Session);
            let session;
            if (typeof currentSession === "string") {
              session = parseSession(currentSession);
            } else {
              session = currentSession;
            }
            if (session && session.expiry * 1e3 > Date.now()) {
              return session;
            }
            await removeStorageValue(StorageKeys.Session);
            return void 0;
          };
          this.getRawSession = async () => {
            const currentSession = await getStorageValue(StorageKeys.Session);
            let session;
            if (typeof currentSession === "string") {
              session = parseSession(currentSession);
              if (session && session.expiry * 1e3 > Date.now()) {
                return currentSession;
              }
            } else if (currentSession && currentSession.expiry * 1e3 > Date.now()) {
              return JSON.stringify(currentSession);
            }
            await removeStorageValue(StorageKeys.Session);
            return void 0;
          };
          this.logout = async () => {
            await removeStorageValue(StorageKeys.Client);
            await removeStorageValue(StorageKeys.Session);
            return true;
          };
          this.config = config2;
        }
      };
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/turnkey-helpers.mjs
  var defaultEthereumAccountAtIndex, DEFAULT_ETHEREUM_ACCOUNTS, defaultCosmosAccountAtIndex, DEFAULT_COSMOS_ACCOUNTS, defaultTronAccountAtIndex, DEFAULT_TRON_ACCOUNTS, defaultBitcoinMainnetP2PKHAccountAtIndex, DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS, defaultBitcoinMainnetP2WPKHAccountAtIndex, DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS, defaultBitcoinMainnetP2WSHAccountAtIndex, DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS, defaultBitcoinMainnetP2TRAccountAtIndex, DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS, defaultBitcoinMainnetP2SHAccountAtIndex, DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS, defaultBitcoinTestnetP2PKHAccountAtIndex, DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS, defaultBitcoinTestnetP2WPKHAccountAtIndex, DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS, defaultBitcoinTestnetP2WSHAccountAtIndex, DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS, defaultBitcoinTestnetP2TRAccountAtIndex, DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS, defaultBitcoinTestnetP2SHAccountAtIndex, DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS, defaultBitcoinSignetP2PKHAccountAtIndex, DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS, defaultBitcoinSignetP2WPKHAccountAtIndex, DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS, defaultBitcoinSignetP2WSHAccountAtIndex, DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS, defaultBitcoinSignetP2TRAccountAtIndex, DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS, defaultBitcoinSignetP2SHAccountAtIndex, DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS, defaultBitcoinRegtestP2PKHAccountAtIndex, DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS, defaultBitcoinRegtestP2WPKHAccountAtIndex, DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS, defaultBitcoinRegtestP2WSHAccountAtIndex, DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS, defaultBitcoinRegtestP2TRAccountAtIndex, DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS, defaultBitcoinRegtestP2SHAccountAtIndex, DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS, defaultDogeMainnetAccountAtIndex, DEFAULT_DOGE_MAINNET_ACCOUNTS, defaultDogeTestnetAccountAtIndex, DEFAULT_DOGE_TESTNET_ACCOUNTS, defaultSeiAccountAtIndex, defaultXrpAccountAtIndex, DEFAULT_SEI_ACCOUNTS, defaultSolanaAccountAtIndex, DEFAULT_SOLANA_ACCOUNTS, defaultSuiAccountAtIndex, DEFAULT_SUI_ACCOUNTS, defaultAptosAccountAtIndex, DEFAULT_APTOS_ACCOUNTS, defaultXlmAccountAtIndex, DEFAULT_XLM_ACCOUNTS, defaultTonV3r2AccountAtIndex, DEFAULT_TON_V3R2_ACCOUNTS, defaultTonV4r2AccountAtIndex, DEFAULT_TON_V4R2_ACCOUNTS;
  var init_turnkey_helpers = __esm({
    "node_modules/@turnkey/sdk-browser/dist/turnkey-helpers.mjs"() {
      defaultEthereumAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/60'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_ETHEREUM"
        };
      };
      DEFAULT_ETHEREUM_ACCOUNTS = [
        defaultEthereumAccountAtIndex(0)
      ];
      defaultCosmosAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/118'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_COSMOS"
        };
      };
      DEFAULT_COSMOS_ACCOUNTS = [
        defaultCosmosAccountAtIndex(0)
      ];
      defaultTronAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/195'/${pathIndex}'`,
          addressFormat: "ADDRESS_FORMAT_TRON"
        };
      };
      DEFAULT_TRON_ACCOUNTS = [
        defaultTronAccountAtIndex(0)
      ];
      defaultBitcoinMainnetP2PKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/0'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
        };
      };
      DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS = [
        defaultBitcoinMainnetP2PKHAccountAtIndex(0)
      ];
      defaultBitcoinMainnetP2WPKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/84'/0'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
        };
      };
      DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS = [
        defaultBitcoinMainnetP2WPKHAccountAtIndex(0)
      ];
      defaultBitcoinMainnetP2WSHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/48'/0'/${pathIndex}'/2'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
        };
      };
      DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS = [
        defaultBitcoinMainnetP2WSHAccountAtIndex(0)
      ];
      defaultBitcoinMainnetP2TRAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/86'/0'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
        };
      };
      DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS = [
        defaultBitcoinMainnetP2TRAccountAtIndex(0)
      ];
      defaultBitcoinMainnetP2SHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/0'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
        };
      };
      DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS = [
        defaultBitcoinMainnetP2SHAccountAtIndex(0)
      ];
      defaultBitcoinTestnetP2PKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
        };
      };
      DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS = [
        defaultBitcoinTestnetP2PKHAccountAtIndex(0)
      ];
      defaultBitcoinTestnetP2WPKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/84'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
        };
      };
      DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS = [
        defaultBitcoinTestnetP2WPKHAccountAtIndex(0)
      ];
      defaultBitcoinTestnetP2WSHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/48'/1'/${pathIndex}'/2'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
        };
      };
      DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS = [
        defaultBitcoinTestnetP2WSHAccountAtIndex(0)
      ];
      defaultBitcoinTestnetP2TRAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/86'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
        };
      };
      DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS = [
        defaultBitcoinTestnetP2TRAccountAtIndex(0)
      ];
      defaultBitcoinTestnetP2SHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
        };
      };
      DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS = [
        defaultBitcoinTestnetP2SHAccountAtIndex(0)
      ];
      defaultBitcoinSignetP2PKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
        };
      };
      DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS = [
        defaultBitcoinSignetP2PKHAccountAtIndex(0)
      ];
      defaultBitcoinSignetP2WPKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/84'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
        };
      };
      DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS = [
        defaultBitcoinSignetP2WPKHAccountAtIndex(0)
      ];
      defaultBitcoinSignetP2WSHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/48'/1'/${pathIndex}'/2'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
        };
      };
      DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS = [
        defaultBitcoinSignetP2WSHAccountAtIndex(0)
      ];
      defaultBitcoinSignetP2TRAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/86'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
        };
      };
      DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS = [
        defaultBitcoinSignetP2TRAccountAtIndex(0)
      ];
      defaultBitcoinSignetP2SHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
        };
      };
      DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS = [
        defaultBitcoinSignetP2SHAccountAtIndex(0)
      ];
      defaultBitcoinRegtestP2PKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
        };
      };
      DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS = [
        defaultBitcoinRegtestP2PKHAccountAtIndex(0)
      ];
      defaultBitcoinRegtestP2WPKHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/84'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
        };
      };
      DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS = [
        defaultBitcoinRegtestP2WPKHAccountAtIndex(0)
      ];
      defaultBitcoinRegtestP2WSHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/48'/1'/${pathIndex}'/2'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
        };
      };
      DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS = [
        defaultBitcoinRegtestP2WSHAccountAtIndex(0)
      ];
      defaultBitcoinRegtestP2TRAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/86'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
        };
      };
      DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS = [
        defaultBitcoinRegtestP2TRAccountAtIndex(0)
      ];
      defaultBitcoinRegtestP2SHAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/1'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
        };
      };
      DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS = [
        defaultBitcoinRegtestP2SHAccountAtIndex(0)
      ];
      defaultDogeMainnetAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/3'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_DOGE_MAINNET"
        };
      };
      DEFAULT_DOGE_MAINNET_ACCOUNTS = [
        defaultDogeMainnetAccountAtIndex(0)
      ];
      defaultDogeTestnetAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/3'/${pathIndex}'/0/0`,
          addressFormat: "ADDRESS_FORMAT_DOGE_TESTNET"
        };
      };
      DEFAULT_DOGE_TESTNET_ACCOUNTS = [
        defaultDogeTestnetAccountAtIndex(0)
      ];
      defaultSeiAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/118'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_SEI"
        };
      };
      defaultXrpAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_SECP256K1",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/144'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_XRP"
        };
      };
      DEFAULT_SEI_ACCOUNTS = [
        defaultSeiAccountAtIndex(0)
      ];
      defaultSolanaAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/501'/${pathIndex}'/0'`,
          addressFormat: "ADDRESS_FORMAT_SOLANA"
        };
      };
      DEFAULT_SOLANA_ACCOUNTS = [
        defaultSolanaAccountAtIndex(0)
      ];
      defaultSuiAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/784'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_SUI"
        };
      };
      DEFAULT_SUI_ACCOUNTS = [
        defaultSuiAccountAtIndex(0)
      ];
      defaultAptosAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/637'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_APTOS"
        };
      };
      DEFAULT_APTOS_ACCOUNTS = [
        defaultAptosAccountAtIndex(0)
      ];
      defaultXlmAccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/148'/${pathIndex}'`,
          addressFormat: "ADDRESS_FORMAT_XLM"
        };
      };
      DEFAULT_XLM_ACCOUNTS = [
        defaultXlmAccountAtIndex(0)
      ];
      defaultTonV3r2AccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/607'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_TON_V3R2"
        };
      };
      DEFAULT_TON_V3R2_ACCOUNTS = [
        defaultTonV3r2AccountAtIndex(0)
      ];
      defaultTonV4r2AccountAtIndex = (pathIndex) => {
        return {
          curve: "CURVE_ED25519",
          pathFormat: "PATH_FORMAT_BIP32",
          path: `m/44'/607'/${pathIndex}'/0'/0'`,
          addressFormat: "ADDRESS_FORMAT_TON_V4R2"
        };
      };
      DEFAULT_TON_V4R2_ACCOUNTS = [
        defaultTonV4r2AccountAtIndex(0)
      ];
    }
  });

  // node_modules/@turnkey/sdk-browser/dist/index.mjs
  var dist_exports4 = {};
  __export(dist_exports4, {
    ApiKeyStamper: () => ApiKeyStamper,
    AuthClient: () => AuthClient,
    DEFAULT_APTOS_ACCOUNTS: () => DEFAULT_APTOS_ACCOUNTS,
    DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS: () => DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS,
    DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS: () => DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS,
    DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS: () => DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS,
    DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS: () => DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS,
    DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS: () => DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS,
    DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS: () => DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS,
    DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS: () => DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS,
    DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS: () => DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS,
    DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS: () => DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS,
    DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS: () => DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS,
    DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS: () => DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS,
    DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS: () => DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS,
    DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS: () => DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS,
    DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS: () => DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS,
    DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS: () => DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS,
    DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS: () => DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS,
    DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS: () => DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS,
    DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS: () => DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS,
    DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS: () => DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS,
    DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS: () => DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS,
    DEFAULT_COSMOS_ACCOUNTS: () => DEFAULT_COSMOS_ACCOUNTS,
    DEFAULT_DOGE_MAINNET_ACCOUNTS: () => DEFAULT_DOGE_MAINNET_ACCOUNTS,
    DEFAULT_DOGE_TESTNET_ACCOUNTS: () => DEFAULT_DOGE_TESTNET_ACCOUNTS,
    DEFAULT_ETHEREUM_ACCOUNTS: () => DEFAULT_ETHEREUM_ACCOUNTS,
    DEFAULT_SEI_ACCOUNTS: () => DEFAULT_SEI_ACCOUNTS,
    DEFAULT_SOLANA_ACCOUNTS: () => DEFAULT_SOLANA_ACCOUNTS,
    DEFAULT_SUI_ACCOUNTS: () => DEFAULT_SUI_ACCOUNTS,
    DEFAULT_TON_V3R2_ACCOUNTS: () => DEFAULT_TON_V3R2_ACCOUNTS,
    DEFAULT_TON_V4R2_ACCOUNTS: () => DEFAULT_TON_V4R2_ACCOUNTS,
    DEFAULT_TRON_ACCOUNTS: () => DEFAULT_TRON_ACCOUNTS,
    DEFAULT_XLM_ACCOUNTS: () => DEFAULT_XLM_ACCOUNTS,
    IframeEventType: () => IframeEventType,
    IframeStamper: () => IframeStamper,
    MethodType: () => MethodType,
    SessionType: () => SessionType,
    StorageKeys: () => StorageKeys,
    Turnkey: () => TurnkeyBrowserSDK,
    TurnkeyActivityError: () => TurnkeyActivityError,
    TurnkeyApi: () => public_api_fetcher_exports,
    TurnkeyBrowserClient: () => TurnkeyBrowserClient,
    TurnkeyIframeClient: () => TurnkeyIframeClient,
    TurnkeyIndexedDbClient: () => TurnkeyIndexedDbClient,
    TurnkeyPasskeyClient: () => TurnkeyPasskeyClient,
    TurnkeyRequestError: () => TurnkeyRequestError,
    TurnkeyWalletClient: () => TurnkeyWalletClient,
    WebauthnStamper: () => WebauthnStamper,
    createActivityPoller: () => createActivityPoller,
    defaultAptosAccountAtIndex: () => defaultAptosAccountAtIndex,
    defaultBitcoinMainnetP2PKHAccountAtIndex: () => defaultBitcoinMainnetP2PKHAccountAtIndex,
    defaultBitcoinMainnetP2SHAccountAtIndex: () => defaultBitcoinMainnetP2SHAccountAtIndex,
    defaultBitcoinMainnetP2TRAccountAtIndex: () => defaultBitcoinMainnetP2TRAccountAtIndex,
    defaultBitcoinMainnetP2WPKHAccountAtIndex: () => defaultBitcoinMainnetP2WPKHAccountAtIndex,
    defaultBitcoinMainnetP2WSHAccountAtIndex: () => defaultBitcoinMainnetP2WSHAccountAtIndex,
    defaultBitcoinRegtestP2PKHAccountAtIndex: () => defaultBitcoinRegtestP2PKHAccountAtIndex,
    defaultBitcoinRegtestP2SHAccountAtIndex: () => defaultBitcoinRegtestP2SHAccountAtIndex,
    defaultBitcoinRegtestP2TRAccountAtIndex: () => defaultBitcoinRegtestP2TRAccountAtIndex,
    defaultBitcoinRegtestP2WPKHAccountAtIndex: () => defaultBitcoinRegtestP2WPKHAccountAtIndex,
    defaultBitcoinRegtestP2WSHAccountAtIndex: () => defaultBitcoinRegtestP2WSHAccountAtIndex,
    defaultBitcoinSignetP2PKHAccountAtIndex: () => defaultBitcoinSignetP2PKHAccountAtIndex,
    defaultBitcoinSignetP2SHAccountAtIndex: () => defaultBitcoinSignetP2SHAccountAtIndex,
    defaultBitcoinSignetP2TRAccountAtIndex: () => defaultBitcoinSignetP2TRAccountAtIndex,
    defaultBitcoinSignetP2WPKHAccountAtIndex: () => defaultBitcoinSignetP2WPKHAccountAtIndex,
    defaultBitcoinSignetP2WSHAccountAtIndex: () => defaultBitcoinSignetP2WSHAccountAtIndex,
    defaultBitcoinTestnetP2PKHAccountAtIndex: () => defaultBitcoinTestnetP2PKHAccountAtIndex,
    defaultBitcoinTestnetP2SHAccountAtIndex: () => defaultBitcoinTestnetP2SHAccountAtIndex,
    defaultBitcoinTestnetP2TRAccountAtIndex: () => defaultBitcoinTestnetP2TRAccountAtIndex,
    defaultBitcoinTestnetP2WPKHAccountAtIndex: () => defaultBitcoinTestnetP2WPKHAccountAtIndex,
    defaultBitcoinTestnetP2WSHAccountAtIndex: () => defaultBitcoinTestnetP2WSHAccountAtIndex,
    defaultCosmosAccountAtIndex: () => defaultCosmosAccountAtIndex,
    defaultDogeMainnetAccountAtIndex: () => defaultDogeMainnetAccountAtIndex,
    defaultDogeTestnetAccountAtIndex: () => defaultDogeTestnetAccountAtIndex,
    defaultEthereumAccountAtIndex: () => defaultEthereumAccountAtIndex,
    defaultSeiAccountAtIndex: () => defaultSeiAccountAtIndex,
    defaultSolanaAccountAtIndex: () => defaultSolanaAccountAtIndex,
    defaultSuiAccountAtIndex: () => defaultSuiAccountAtIndex,
    defaultTonV3r2AccountAtIndex: () => defaultTonV3r2AccountAtIndex,
    defaultTonV4r2AccountAtIndex: () => defaultTonV4r2AccountAtIndex,
    defaultTronAccountAtIndex: () => defaultTronAccountAtIndex,
    defaultXlmAccountAtIndex: () => defaultXlmAccountAtIndex,
    defaultXrpAccountAtIndex: () => defaultXrpAccountAtIndex,
    getStorageValue: () => getStorageValue,
    getWebAuthnAttestation: () => getWebAuthnAttestation,
    sealAndStampRequestBody: () => sealAndStampRequestBody,
    setStorageValue: () => setStorageValue,
    signWithApiKey: () => signWithApiKey4
  });
  var init_dist10 = __esm({
    "node_modules/@turnkey/sdk-browser/dist/index.mjs"() {
      init_dist3();
      init_dist2();
      init_dist4();
      init_dist5();
      init_sdk_client();
      init_storage();
      init_turnkey_helpers();
      init_base4();
      init_dist8();
      init_browser_clients();
    }
  });

  // node_modules/@turnkey/telegram-cloud-storage-stamper/dist/errors.mjs
  var TelegramCloudStorageStamperError, TelegramSuccessButFalseError;
  var init_errors6 = __esm({
    "node_modules/@turnkey/telegram-cloud-storage-stamper/dist/errors.mjs"() {
      TelegramCloudStorageStamperError = class extends Error {
        constructor(message) {
          super(`TelegramCloudStorageStamperError: ${message}`);
        }
      };
      TelegramSuccessButFalseError = class extends Error {
        constructor(message) {
          super(`TelegramSuccessButFalseError: ${message}`);
        }
      };
    }
  });

  // node_modules/@turnkey/telegram-cloud-storage-stamper/dist/index.mjs
  var dist_exports5 = {};
  __export(dist_exports5, {
    DEFAULT_TURNKEY_CLOUD_STORAGE_KEY: () => DEFAULT_TURNKEY_CLOUD_STORAGE_KEY,
    TelegramCloudStorageStamper: () => TelegramCloudStorageStamper
  });
  var DEFAULT_TURNKEY_CLOUD_STORAGE_KEY, TelegramCloudStorageStamper;
  var init_dist11 = __esm({
    "node_modules/@turnkey/telegram-cloud-storage-stamper/dist/index.mjs"() {
      init_dist2();
      init_errors6();
      DEFAULT_TURNKEY_CLOUD_STORAGE_KEY = "TURNKEY_API_KEY";
      TelegramCloudStorageStamper = class _TelegramCloudStorageStamper {
        // the constructor checks if we're in a telegram mini app context, and then gives the developer an interface into looking into CloudStorage even without having an API key attached
        constructor() {
          this.checkTelegramContext();
        }
        // create a telegram stamper by getting/setting the private/public API key values from/to telegram cloud storage
        static async create(config2) {
          let telegramStamper = new _TelegramCloudStorageStamper();
          await telegramStamper.setSigningKey(config2);
          return telegramStamper;
        }
        async stamp(payload) {
          this.checkTelegramContext();
          if (!this.stamper) {
            throw new TelegramCloudStorageStamperError("Cannot stamp with uninitialized telegram stamper, try running .create() or .setSigningKey()");
          }
          return await this.stamper.stamp(payload);
        }
        // set the API key that is used by the telegram cloud storage for signing requests
        async setSigningKey(config2) {
          if (!config2) {
            let { apiPublicKey, apiPrivateKey } = await this.getAPIKey(DEFAULT_TURNKEY_CLOUD_STORAGE_KEY) ?? {};
            if (apiPublicKey && apiPrivateKey) {
              this.stamper = new ApiKeyStamper({
                apiPublicKey,
                apiPrivateKey
              });
              return;
            }
          } else if (config2.cloudStorageKey && !config2.cloudStorageAPIKey) {
            let { apiPublicKey, apiPrivateKey } = await this.getAPIKey(config2.cloudStorageKey) ?? {};
            if (apiPublicKey && apiPrivateKey) {
              this.stamper = new ApiKeyStamper({
                apiPublicKey,
                apiPrivateKey
              });
              return;
            }
          } else if (!config2.cloudStorageKey && config2.cloudStorageAPIKey) {
            await this.insertAPIKey(config2.cloudStorageAPIKey.apiPublicKey, config2.cloudStorageAPIKey.apiPrivateKey, DEFAULT_TURNKEY_CLOUD_STORAGE_KEY);
            this.stamper = new ApiKeyStamper({
              apiPublicKey: config2.cloudStorageAPIKey.apiPublicKey,
              apiPrivateKey: config2.cloudStorageAPIKey.apiPrivateKey
            });
            return;
          } else if (config2.cloudStorageKey && config2.cloudStorageAPIKey) {
            await this.insertAPIKey(config2.cloudStorageAPIKey.apiPublicKey, config2.cloudStorageAPIKey.apiPrivateKey, config2.cloudStorageKey);
            this.stamper = new ApiKeyStamper({
              apiPublicKey: config2.cloudStorageAPIKey.apiPublicKey,
              apiPrivateKey: config2.cloudStorageAPIKey.apiPrivateKey
            });
            return;
          }
          throw new TelegramCloudStorageStamperError("Invalid configuration received for signing key");
        }
        async insertAPIKey(apiPublicKey, apiPrivateKey, key = DEFAULT_TURNKEY_CLOUD_STORAGE_KEY) {
          return await this.setItem(key, this.stringifyAPIKey(apiPublicKey, apiPrivateKey));
        }
        async getAPIKey(key = DEFAULT_TURNKEY_CLOUD_STORAGE_KEY) {
          try {
            const apiKey = await this.getItem(key);
            if (!apiKey) {
              return null;
            }
            return this.parseAPIKey(apiKey);
          } catch {
            return null;
          }
        }
        checkTelegramContext() {
          if (window?.Telegram?.WebApp?.CloudStorage == null) {
            throw new TelegramCloudStorageStamperError("Cannot use telegram stamper in non telegram mini-app environment, window.Telegram.WebApp.CloudStorage is not defined");
          }
        }
        stringifyAPIKey(apiPublicKey, apiPrivateKey) {
          return JSON.stringify({
            apiPublicKey,
            apiPrivateKey
          });
        }
        parseAPIKey(apiKey) {
          try {
            const parsedApiKey = JSON.parse(apiKey);
            if (!this.isCloudStorageAPIKey(parsedApiKey)) {
              return null;
            }
            return {
              apiPublicKey: parsedApiKey.apiPublicKey,
              apiPrivateKey: parsedApiKey.apiPrivateKey
            };
          } catch (err) {
            throw new TelegramCloudStorageStamperError("Failed parsing API key from Telegram Cloud Storage");
          }
        }
        // determines if a passed object is of type CloudStorageAPIKey
        isCloudStorageAPIKey(apiKey) {
          return typeof apiKey.apiPublicKey === "string" && typeof apiKey.apiPrivateKey === "string";
        }
        async getItem(key) {
          return new Promise((resolve, reject) => {
            window.Telegram.WebApp.CloudStorage.getItem(key, (err, value) => {
              if (err != null) {
                reject(new TelegramCloudStorageStamperError(`Failed getting value: ${key} from Telegram Cloud Storage${err && `: ${err}`}`));
              }
              resolve(value);
            });
          });
        }
        async setItem(key, value) {
          return new Promise((resolve, reject) => {
            window.Telegram.WebApp.CloudStorage.setItem(key, value, (err, stored) => {
              if (err != null) {
                reject(new TelegramCloudStorageStamperError(`Failed inserting value: ${value} into Telegram Cloud Storage at key: ${key}${err && `: ${err}`}`));
              }
              if (!stored) {
                reject(new TelegramSuccessButFalseError("Telegram indicated success for storing key, but also returned false, see documention: https://core.telegram.org/bots/webapps#cloudstorage"));
              }
              resolve();
            });
          });
        }
        // clear key from telegram cloud storage
        async clearItem(key) {
          this.checkTelegramContext();
          return new Promise((resolve, reject) => {
            window.Telegram.WebApp.CloudStorage.removeItem(key, (err, removed) => {
              if (err) {
                reject(new TelegramCloudStorageStamperError(`Failed removing key: ${key}${err && `: ${err}`}`));
              }
              if (!removed) {
                reject(new TelegramSuccessButFalseError("Telegram indicated success for removing key, but also returned false, see documention: https://core.telegram.org/bots/webapps#cloudstorage"));
              }
              resolve();
            });
          });
        }
      };
    }
  });

  // turnkey-entry.js
  console.log("turnkey-entry.js starting...");
  (async () => {
    try {
      let base64urlToHex2 = function(base64url) {
        let base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
        while (base64.length % 4) base64 += "=";
        const binary = atob(base64);
        let hex = "";
        for (let i = 0; i < binary.length; i++) {
          hex += binary.charCodeAt(i).toString(16).padStart(2, "0");
        }
        return hex;
      };
      var base64urlToHex = base64urlToHex2;
      const { TurnkeyBrowserClient: TurnkeyBrowserClient2 } = await Promise.resolve().then(() => (init_dist10(), dist_exports4));
      const { IframeStamper: IframeStamper2 } = await Promise.resolve().then(() => (init_dist4(), dist_exports2));
      const { getWebAuthnAttestation: getWebAuthnAttestation2 } = await Promise.resolve().then(() => (init_dist3(), dist_exports));
      const { TelegramCloudStorageStamper: TelegramCloudStorageStamper2 } = await Promise.resolve().then(() => (init_dist11(), dist_exports5));
      window.Turnkey = {
        TurnkeyBrowserClient: TurnkeyBrowserClient2,
        IframeStamper: IframeStamper2,
        getWebAuthnAttestation: getWebAuthnAttestation2,
        TelegramCloudStorageStamper: TelegramCloudStorageStamper2,
        // Decryption methods
        decryptExportBundle: async ({ exportBundle, privateKey }) => {
          const { decryptExportBundle: decryptExportBundle2 } = await Promise.resolve().then(() => (init_dist6(), dist_exports3));
          return await decryptExportBundle2({
            exportBundle,
            embeddedKey: privateKey,
            keyFormat: "KEY_FORMAT_HEXADECIMAL"
          });
        },
        // For persistent API keys (ECDSA for signing)
        generateP256ApiKeyPair: async () => {
          const keyPair = await crypto.subtle.generateKey(
            { name: "ECDSA", namedCurve: "P-256" },
            true,
            ["sign", "verify"]
          );
          const publicJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
          const privateJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
          const xHex = base64urlToHex2(publicJwk.x).padStart(64, "0");
          const yHex = base64urlToHex2(publicJwk.y).padStart(64, "0");
          const yLastByte = parseInt(yHex.slice(-2), 16);
          const prefix = yLastByte % 2 === 0 ? "02" : "03";
          const publicHex = prefix + xHex;
          const privateHex = base64urlToHex2(privateJwk.d).padStart(64, "0");
          console.log("Generated API keyPair:", { publicKey: publicHex, privateKey: privateHex });
          return { publicKey: publicHex, privateKey: privateHex };
        },
        // For ephemeral keys (ECDH for HPKE decryption)
        generateP256EphemeralKeyPair: async () => {
          const keyPair = await crypto.subtle.generateKey(
            { name: "ECDH", namedCurve: "P-256" },
            true,
            ["deriveKey", "deriveBits"]
          );
          const publicJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
          const privateJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
          const xHex = base64urlToHex2(publicJwk.x).padStart(64, "0");
          const yHex = base64urlToHex2(publicJwk.y).padStart(64, "0");
          const yLastByte = parseInt(yHex.slice(-2), 16);
          const prefix = yLastByte % 2 === 0 ? "02" : "03";
          const publicHex = prefix + xHex;
          const uncompressedPublic = "04" + xHex + yHex;
          const privateHex = base64urlToHex2(privateJwk.d).padStart(64, "0");
          console.log("Generated ephemeral keyPair:", { publicKey: publicHex, privateKey: privateHex, uncompressedPublic });
          return { publicKey: publicHex, privateKey: privateHex, uncompressedPublic };
        }
      };
      console.log("turnkey-entry.js finished \u2013 window.Turnkey set.");
    } catch (error) {
      console.error("Error in turnkey-entry.js:", error);
    }
  })();
})();
/*! Bundled license information:

@turnkey/api-key-stamper/dist/tink/bytes.mjs:
  (**
   * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
   *
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs:
  (**
   * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
   * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
   * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
   * - Method isP256CurvePoint added to check whether an uncompressed point is valid
   *
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/nist.js:
@noble/curves/esm/p256.js:
@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=turnkey.js.map
