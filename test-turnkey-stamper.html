<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turnkey Cloud Stamper Test</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/turnkey.js?v=2"></script>
    <script src="/mini-app/encryption-utils.js"></script>
    <script src="/mini-app/login.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: white;
        }
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .btn:hover { background: #0056b3; }
        .btn:disabled { background: #666; cursor: not-allowed; }
        .btn.danger { background: #dc3545; }
        .btn.success { background: #28a745; }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .status.success { background: rgba(40, 167, 69, 0.2); border: 1px solid #28a745; }
        .status.error { background: rgba(220, 53, 69, 0.2); border: 1px solid #dc3545; }
        .status.info { background: rgba(0, 123, 255, 0.2); border: 1px solid #007bff; }
    </style>
</head>
<body>
    <h1>üîê Turnkey Cloud Stamper Test</h1>
    
    <div class="test-section">
        <h3>1. Environment Check</h3>
        <button onclick="checkEnvironment()" class="btn">Check Environment</button>
        <div id="env-status"></div>
    </div>

    <div class="test-section">
        <h3>2. Cloud Storage Test</h3>
        <button onclick="testCloudStorage()" class="btn">Test Cloud Storage</button>
        <button onclick="clearCloudStorage()" class="btn danger">Clear Storage</button>
        <div id="storage-status"></div>
    </div>

    <div class="test-section">
        <h3>3. Custom Stamper Test (Your System)</h3>
        <button onclick="testCustomStamper()" class="btn">Test Custom Stamper</button>
        <button onclick="checkEncryptedKeys()" class="btn">Check Encrypted Keys</button>
        <div id="stamper-status"></div>
    </div>

    <div class="test-section">
        <h3>4. Mock Transaction Signing</h3>
        <button onclick="testMockSigning()" class="btn success">Test Mock Signing</button>
        <div id="signing-status"></div>
    </div>

    <div class="test-section">
        <h3>5. Test Logs</h3>
        <button onclick="clearLogs()" class="btn">Clear Logs</button>
        <div id="logs" class="log"></div>
    </div>

    <script>
        let stamper = null;
        let testResults = {};

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
            const logsDiv = document.getElementById('logs');
            logsDiv.textContent += logEntry;
            logsDiv.scrollTop = logsDiv.scrollHeight;
            console.log(logEntry.trim());
        }

        function clearLogs() {
            document.getElementById('logs').textContent = '';
        }

        function showStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        async function checkEnvironment() {
            log('Checking environment...');
            
            try {
                // Check Telegram WebApp
                if (typeof Telegram === 'undefined' || !Telegram.WebApp) {
                    throw new Error('Telegram WebApp not available');
                }
                log('‚úÖ Telegram WebApp available');

                // Check Turnkey
                if (typeof Turnkey === 'undefined') {
                    throw new Error('Turnkey library not loaded');
                }
                log('‚úÖ Turnkey library loaded');

                // Check Cloud Storage
                if (!Telegram.WebApp.CloudStorage) {
                    throw new Error('Telegram Cloud Storage not available');
                }
                log('‚úÖ Telegram Cloud Storage available');

                showStatus('env-status', '‚úÖ Environment check passed!', 'success');
                testResults.environment = true;

            } catch (error) {
                log(`‚ùå Environment check failed: ${error.message}`, 'error');
                showStatus('env-status', `‚ùå Environment check failed: ${error.message}`, 'error');
                testResults.environment = false;
            }
        }

        async function testCloudStorage() {
            log('Testing Cloud Storage...');
            
            try {
                // Test write
                const testData = {
                    test: true,
                    timestamp: Date.now(),
                    message: 'Cloud storage test'
                };

                await new Promise((resolve, reject) => {
                    Telegram.WebApp.CloudStorage.setItem('TEST_KEY', JSON.stringify(testData), (error) => {
                        if (error) reject(error);
                        else resolve();
                    });
                });
                log('‚úÖ Cloud storage write successful');

                // Test read
                const readData = await new Promise((resolve, reject) => {
                    Telegram.WebApp.CloudStorage.getItem('TEST_KEY', (error, value) => {
                        if (error) reject(error);
                        else resolve(value);
                    });
                });
                
                const parsedData = JSON.parse(readData);
                log(`‚úÖ Cloud storage read successful: ${JSON.stringify(parsedData)}`);

                showStatus('storage-status', '‚úÖ Cloud storage test passed!', 'success');
                testResults.cloudStorage = true;

            } catch (error) {
                log(`‚ùå Cloud storage test failed: ${error.message}`, 'error');
                showStatus('storage-status', `‚ùå Cloud storage test failed: ${error.message}`, 'error');
                testResults.cloudStorage = false;
            }
        }

        async function clearCloudStorage() {
            log('Clearing Cloud Storage...');
            
            try {
                await new Promise((resolve, reject) => {
                    Telegram.WebApp.CloudStorage.removeItem('TEST_KEY', (error) => {
                        if (error) reject(error);
                        else resolve();
                    });
                });
                log('‚úÖ Cloud storage cleared');
                showStatus('storage-status', '‚úÖ Cloud storage cleared', 'success');
            } catch (error) {
                log(`‚ùå Failed to clear cloud storage: ${error.message}`, 'error');
                showStatus('storage-status', `‚ùå Failed to clear cloud storage: ${error.message}`, 'error');
            }
        }

        async function testStamperInit() {
            log('Testing Stamper Initialization...');
            
            try {
                if (!Turnkey.TelegramCloudStorageStamper) {
                    throw new Error('TelegramCloudStorageStamper not available');
                }

                // Try to create stamper with existing API key from Cloud Storage
                log('üîç Attempting to create stamper with existing API key...');
                stamper = await Turnkey.TelegramCloudStorageStamper.create();
                log('‚úÖ Stamper initialized successfully with existing API key');
                
                // Debug: Log available methods
                log(`üîç Available stamper methods: ${Object.getOwnPropertyNames(Object.getPrototypeOf(stamper)).join(', ')}`);
                log(`üîç Stamper object keys: ${Object.keys(stamper).join(', ')}`);

                showStatus('stamper-status', '‚úÖ Stamper initialization successful!', 'success');
                testResults.stamper = true;

            } catch (error) {
                log(`‚ùå Stamper initialization failed: ${error.message}`, 'error');
                log('üí° This might be expected if no API key is stored yet');
                showStatus('stamper-status', `‚ùå Stamper initialization failed: ${error.message}`, 'error');
                testResults.stamper = false;
            }
        }

        async function checkEncryptedKeys() {
            log('Checking for encrypted API keys in Cloud Storage...');
            
            try {
                // Check if there's encrypted data stored
                const encryptedData = await new Promise((resolve, reject) => {
                    Telegram.WebApp.CloudStorage.getItem('TURNKEY_API_KEY', (error, value) => {
                        if (error) reject(error);
                        else resolve(value);
                    });
                });
                
                if (encryptedData) {
                    log('‚úÖ Found encrypted data in Cloud Storage');
                    log(`üìã Encrypted data length: ${encryptedData.length} characters`);
                    
                    // Try to parse as JSON to see the structure
                    try {
                        const parsed = JSON.parse(encryptedData);
                        log('üìã Data structure:');
                        log(`   - encryptedPrivateKey: ${parsed.encryptedPrivateKey ? 'Present' : 'Missing'}`);
                        log(`   - iv: ${parsed.iv ? 'Present' : 'Missing'}`);
                        log(`   - publicKey: ${parsed.publicKey ? 'Present' : 'Missing'}`);
                        log(`   - salt: ${parsed.salt ? 'Present' : 'Missing'}`);
                        
                        showStatus('stamper-status', '‚úÖ Encrypted keys found in Cloud Storage', 'success');
                    } catch (parseError) {
                        log('üìã Data appears to be encrypted (not JSON)');
                        showStatus('stamper-status', '‚úÖ Encrypted keys found in Cloud Storage', 'success');
                    }
                } else {
                    log('‚ùå No encrypted data found in Cloud Storage');
                    log('üí° You need to register first to store encrypted API keys');
                    showStatus('stamper-status', '‚ùå No encrypted keys found. Please register first.', 'error');
                }
                
            } catch (error) {
                log(`‚ùå Failed to check encrypted keys: ${error.message}`, 'error');
                showStatus('stamper-status', `‚ùå Failed to check encrypted keys: ${error.message}`, 'error');
            }
        }

        async function testCustomStamper() {
            log('Testing Custom Stamper (Your System)...');
            
            try {
                // Check if EncryptionUtils is available
                if (!window.EncryptionUtils) {
                    throw new Error('EncryptionUtils not available - need to load encryption-utils.js');
                }
                
                log('‚úÖ EncryptionUtils available');
                
                // Check if keys are encrypted
                const isEncrypted = await window.EncryptionUtils.isKeyEncrypted();
                log(`üîê Keys are encrypted: ${isEncrypted}`);
                
                if (!isEncrypted) {
                    throw new Error('No encrypted keys found - please register first');
                }
                
                // Simulate password prompt (in real app, this would be user input)
                const password = prompt('Enter your password to decrypt keys:');
                if (!password) {
                    throw new Error('Password required for decryption');
                }
                
                log('üîì Attempting to decrypt keys...');
                
                // Decrypt the keys using your system
                const apiKey = await window.EncryptionUtils.retrieveTelegramKey(password);
                log('‚úÖ Keys decrypted successfully');
                log(`üìã API Public Key: ${apiKey.apiPublicKey.substring(0, 20)}...`);
                log(`üìã API Private Key: ${apiKey.apiPrivateKey.substring(0, 20)}...`);
                
                // Test direct signing approach (bypassing ManualStamper for now)
                log('üîê Testing direct signing approach...');
                
                // Helper function to convert hex to Uint8Array
                function hexToUint8Array(hex) {
                    const cleanHex = hex.replace(/^0x/, '');
                    const pairs = [];
                    for (let i = 0; i < cleanHex.length; i += 2) {
                        pairs.push(cleanHex.substr(i, 2));
                    }
                    return new Uint8Array(pairs.map(byte => parseInt(byte, 16)));
                }
                
                // Helper function to convert array buffer to hex
                function arrayBufferToHex(buffer) {
                    return [...new Uint8Array(buffer)].map(b => b.toString(16).padStart(2, '0')).join('');
                }
                
                // Helper function to encode signature in DER format
                function derEncodeSignature(sigBuffer) {
                    const sigBytes = new Uint8Array(sigBuffer);
                    const rBytes = sigBytes.slice(0, 32);
                    let s = BigInt('0x' + arrayBufferToHex(sigBytes.slice(32)));
                    const n = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                    if (s > n / 2n) {
                        s = n - s;
                    }
                    const sHex = s.toString(16).padStart(64, '0');
                    const sBytes = hexToUint8Array(sHex);

                    let r = [...rBytes];
                    let sArr = [...sBytes];
                    if (r[0] > 127) r = [0, ...r];
                    if (sArr[0] > 127) sArr = [0, ...sArr];

                    const rLen = r.length;
                    const sLen = sArr.length;
                    const totalLen = 2 + rLen + 2 + sLen;

                    const der = new Uint8Array(2 + totalLen);
                    let offset = 0;
                    der[offset++] = 0x30; // SEQUENCE
                    der[offset++] = totalLen;
                    der[offset++] = 0x02; // INTEGER
                    der[offset++] = rLen;
                    der.set(r, offset);
                    offset += rLen;
                    der[offset++] = 0x02; // INTEGER
                    der[offset++] = sLen;
                    der.set(sArr, offset);

                    return arrayBufferToHex(der);
                }
                
                // Create a mock request to sign
                const mockRequest = {
                    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
                    timestampMs: Date.now().toString(),
                    organizationId: "test-org-id",
                    parameters: {
                        signWith: "test-key-id",
                        payload: "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                        hashFunction: "HASH_FUNCTION_NO_OP"
                    }
                };
                
                const payload = JSON.stringify(mockRequest);
                log(`üìã Payload to sign: ${payload.substring(0, 100)}...`);
                
                // Import private key using JWK format (correct for hex strings)
                const privateKeyBuffer = hexToUint8Array(apiKey.apiPrivateKey);
                log('‚úÖ Private key converted to buffer');
                
                // Convert to base64url for JWK
                function bytesToBase64url(bytes) {
                    const base64 = btoa(String.fromCharCode(...bytes));
                    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                }
                
                const d = bytesToBase64url(privateKeyBuffer);
                log('‚úÖ Private key converted to base64url');
                
                // Create JWK for P-256
                const privateJwk = {
                    kty: "EC",
                    crv: "P-256",
                    d: d
                };
                
                const privateKeyCrypto = await crypto.subtle.importKey(
                    "jwk",
                    privateJwk,
                    { name: "ECDSA", namedCurve: "P-256" },
                    true,
                    ["sign"]
                );
                log('‚úÖ Private key imported successfully');
                
                // Sign the payload
                const payloadBytes = new TextEncoder().encode(payload);
                const sigBuffer = await crypto.subtle.sign(
                    { name: "ECDSA", hash: "SHA-256" },
                    privateKeyCrypto,
                    payloadBytes
                );
                log('‚úÖ Payload signed successfully');
                
                // Encode signature in DER format
                const sigHex = derEncodeSignature(sigBuffer);
                log('‚úÖ Signature encoded in DER format');
                
                // Create stamp object (same format as ManualStamper)
                const stamp = {
                    publicKey: apiKey.apiPublicKey,
                    scheme: "SIGNATURE_SCHEME_TK_API_P256",
                    signature: sigHex
                };
                
                log('‚úÖ Stamp created successfully');
                log(`üìã Stamp object: ${JSON.stringify(stamp, null, 2)}`);
                
                showStatus('stamper-status', '‚úÖ Custom stamper test successful!', 'success');
                testResults.customStamper = true;
                
            } catch (error) {
                log(`‚ùå Custom stamper test failed: ${error.message}`, 'error');
                showStatus('stamper-status', `‚ùå Custom stamper test failed: ${error.message}`, 'error');
                testResults.customStamper = false;
            }
        }

        async function testMockSigning() {
            log('Testing Mock Transaction Signing with Custom Stamper...');
            
            try {
                // Check if we have a custom stamper ready
                if (!testResults.customStamper) {
                    throw new Error('Custom stamper not ready. Run "Test Custom Stamper" first.');
                }

                // Create a mock transaction hash (this is what we'd get from Stellar SDK)
                const mockTxHash = '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
                log(`üìù Mock transaction hash: ${mockTxHash}`);

                // Simulate the real-world scenario
                log('üîê Simulating real transaction signing flow...');
                
                // 1. Decrypt keys (same as in your wallet)
                const password = prompt('Enter password again for transaction signing:');
                if (!password) {
                    throw new Error('Password required for transaction signing');
                }
                
                const apiKey = await window.EncryptionUtils.retrieveTelegramKey(password);
                log('‚úÖ Keys decrypted for transaction signing');
                
                // 2. Create custom stamper (using direct approach)
                log('‚úÖ Using direct signing approach for transaction');
                
                // 3. Create the request body for signRawPayload
                const requestBody = {
                    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
                    timestampMs: Date.now().toString(),
                    organizationId: "test-org-id", // This would come from user's stored data
                    parameters: {
                        signWith: "test-key-id", // This would come from user's stored data
                        payload: mockTxHash,
                        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                        hashFunction: "HASH_FUNCTION_NO_OP"
                    }
                };

                log(`üìã Request body: ${JSON.stringify(requestBody, null, 2)}`);

                // 4. Create a stamp using direct signing (same as above)
                const payload = JSON.stringify(requestBody);
                
                // Helper functions (same as above)
                function hexToUint8Array(hex) {
                    const cleanHex = hex.replace(/^0x/, '');
                    const pairs = [];
                    for (let i = 0; i < cleanHex.length; i += 2) {
                        pairs.push(cleanHex.substr(i, 2));
                    }
                    return new Uint8Array(pairs.map(byte => parseInt(byte, 16)));
                }
                
                function arrayBufferToHex(buffer) {
                    return [...new Uint8Array(buffer)].map(b => b.toString(16).padStart(2, '0')).join('');
                }
                
                function derEncodeSignature(sigBuffer) {
                    const sigBytes = new Uint8Array(sigBuffer);
                    const rBytes = sigBytes.slice(0, 32);
                    let s = BigInt('0x' + arrayBufferToHex(sigBytes.slice(32)));
                    const n = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                    if (s > n / 2n) {
                        s = n - s;
                    }
                    const sHex = s.toString(16).padStart(64, '0');
                    const sBytes = hexToUint8Array(sHex);

                    let r = [...rBytes];
                    let sArr = [...sBytes];
                    if (r[0] > 127) r = [0, ...r];
                    if (sArr[0] > 127) sArr = [0, ...sArr];

                    const rLen = r.length;
                    const sLen = sArr.length;
                    const totalLen = 2 + rLen + 2 + sLen;

                    const der = new Uint8Array(2 + totalLen);
                    let offset = 0;
                    der[offset++] = 0x30; // SEQUENCE
                    der[offset++] = totalLen;
                    der[offset++] = 0x02; // INTEGER
                    der[offset++] = rLen;
                    der.set(r, offset);
                    offset += rLen;
                    der[offset++] = 0x02; // INTEGER
                    der[offset++] = sLen;
                    der.set(sArr, offset);

                    return arrayBufferToHex(der);
                }
                
                // Import and sign using JWK format
                const privateKeyBuffer = hexToUint8Array(apiKey.apiPrivateKey);
                
                // Convert to base64url for JWK
                function bytesToBase64url(bytes) {
                    const base64 = btoa(String.fromCharCode(...bytes));
                    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                }
                
                const d = bytesToBase64url(privateKeyBuffer);
                
                // Create JWK for P-256
                const privateJwk = {
                    kty: "EC",
                    crv: "P-256",
                    d: d
                };
                
                const privateKeyCrypto = await crypto.subtle.importKey(
                    "jwk",
                    privateJwk,
                    { name: "ECDSA", namedCurve: "P-256" },
                    true,
                    ["sign"]
                );
                
                const payloadBytes = new TextEncoder().encode(payload);
                const sigBuffer = await crypto.subtle.sign(
                    { name: "ECDSA", hash: "SHA-256" },
                    privateKeyCrypto,
                    payloadBytes
                );
                
                const sigHex = derEncodeSignature(sigBuffer);
                
                const stamp = {
                    publicKey: apiKey.apiPublicKey,
                    scheme: "SIGNATURE_SCHEME_TK_API_P256",
                    signature: sigHex
                };
                
                log(`‚úÖ Stamp created successfully: ${JSON.stringify(stamp).substring(0, 50)}...`);

                // 5. Simulate API call (in production, this would go to your backend proxy)
                log('üì° Simulating API call to Turnkey...');
                log('üîó In production, this would go to: POST /mini-app/sign-transaction');
                log('üìã Headers: { "X-Stamp": stamp, "Content-Type": "application/json" }');
                log('üìã Body: JSON.stringify(requestBody)');

                // 6. Show what the response would look like
                log('üìä Expected Turnkey API response:');
                log('   {');
                log('     "activity": {');
                log('       "result": {');
                log('         "signRawPayloadResult": {');
                log('           "r": "signature_r_component",');
                log('           "s": "signature_s_component",');
                log('           "v": "signature_v_component"');
                log('         }');
                log('       }');
                log('     }');
                log('   }');

                showStatus('signing-status', '‚úÖ Custom stamper transaction signing test successful!', 'success');
                testResults.signing = true;

            } catch (error) {
                log(`‚ùå Mock signing test failed: ${error.message}`, 'error');
                showStatus('signing-status', `‚ùå Mock signing test failed: ${error.message}`, 'error');
                testResults.signing = false;
            }
        }

        // Auto-run environment check on load
        window.addEventListener('load', () => {
            log('üöÄ Turnkey Cloud Stamper Test Page Loaded');
            setTimeout(checkEnvironment, 1000);
        });
    </script>
</body>
</html>

